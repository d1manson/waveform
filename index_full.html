<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico?">
<title>Waveform</title>

<script> 
document.addEventListener('keydown', function(e){
    if(wav.disable_shortcuts){
        e.stopImmediatePropagation(); // for this to be effective it needs to be the first registered listener
        return;
    }
}, true);

window.Polymer = {dom: 'shadow'}; // this tells Polymer to use fast native dom
</script>

<link rel="import" href="bower_components/polymer/polymer.html">
<link rel="import" href="bower_components/iron-localstorage/iron-localstorage.html">
<link rel="import" href="bower_components/paper-tooltip/paper-tooltip.html">
<link rel="import" href="bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="bower_components/paper-slider/paper-slider.html">
<link rel="import" href="bower_components/paper-button/paper-button.html">  
<link rel="import" href="bower_components/paper-toggle-button/paper-toggle-button.html">
<link rel="import" href="bower_components/iron-icons/iron-icons.html">
<link rel="import" href="bower_components/paper-toolbar/paper-toolbar.html">
<link rel="import" href="bower_components/iron-a11y-keys/iron-a11y-keys.html">
<link rel="import" href="tile-wall.html">
<link rel="import" href="bower_components/iron-splitter/iron-splitter.html">
<link rel="import" href="tile-element.html">
<link rel="import" href="cross-hair.html">
<link rel="import" href="undo-stack-view.html">
<link rel="import" href="cut-object.html">
<link rel="import" href="parsed-data.html">
<link rel="import" href="file-organiser.html">
<link rel="import" href="drop-zone.html">
<link rel="import" href="floating-pane.html">
<link rel="import" href="document-focus-marker.html">
<link rel="import" href="header-view.html">
<link rel="import" href="managed-canvas.html">
<link rel="import" href="value-transform.html">
<link rel="import" href="rm-plots.html">
<link rel="import" href="tac-plots.html">
<link rel="import" href="wave-plots.html">
<link rel="import" href="cluster-plots.html">
<link rel="prefetch" href="img/demo_youtube_hover.png">
<style is="custom-style">
:root {
user-drag: none;
-webkit-user-drag: none;
user-select: none;
-webkit-user-select: none;
--paper-toolbar-height: 40px;
--paper-toolbar-background: #efefef;
--paper-toolbar-color: #000;
--paper-tooltip-opacity: 0.96;
--paper-icon-button: {
      width: 38px;
      height: 38px;
    };
--grabber-hover: {
border: 3px solid red;
background: rgba(255,0,0,0.2);
cursor: pointer;    
};
}

p, ul, ol{
margin-top: 6px;
margin-bottom: 6px;
}
ul, ol{
padding-left:10px;
margin-left:10px;
}
canvas, img{
vertical-align: bottom;
}
body{
overflow:hidden;
font-family: sans-serif;
font-size: 0.8em;
position: fixed;
top: 0px;
left: 0px;
height: 100%;
width: 100%;
display: flex;
flex-direction: column;
margin: 0;
}
.info_summary{
position: absolute;
padding: 3px;
top: 0px;
left: 0px;
background: rgba(255,255,255,0.5);
-webkit-transition: opacity 0.5s ease-in-out;
transition: opacity 0.5s ease-in-out;
}
.hidden_clipboard{
opacity: 0;
position: absolute;
top: -10000px;
right: 0;
-webkit-user-select: initial;
-khtml-user-select: inital;
-moz-user-select: -moz-initial;
-o-user-select: initial;
user-select: initial;
}
.slider_val{
font-weight: bold;
}
.github_button_filedrop{
cursor: pointer;
margin: 20px 0px 0px 0px;
border: 1px solid #999;
display: inline-block;
padding: 4px 10px 4px 10px;
border-radius: 4px;
background: #eee;
}
.github_button_filedrop:hover{
background: #ddd;
border-color: #777;
}
.youtube_demo_img:hover {
content: url('img/demo_youtube_hover.png');
}

paper-button{
min-width: 40px;
font-size: 0.8em;
border: 1px solid;
}
paper-button[selected] {
background-color: #ffffe0;
color: #c77;
}
paper-toolbar{
box-shadow: inset 0 0 2px 1px #ccc;
transition: height 1s;
}

.grabber_signifier{
position: fixed;
top: 6px;
right: 45px;
color: #f00;
font-weight: bold;
border: 2px solid #f00;
padding: 4px 6px 4px 6px;
border-radius: 4px;
}
.menu_toggle {
position: fixed;
top: 0px;
right: 0px;
background: #efefef;
}
iron-splitter {
background-image: url(img/handle.svg);
}
iron-splitter.horizontal{
background-image: url(img/handle-h.svg);
}

::-webkit-scrollbar {
width: 10px;
height: 10px;
}
::-webkit-scrollbar-button {
width: 0;
height: 0;
display: none;
}
::-webkit-scrollbar-thumb {
background-color: rgba(0,0,0,0.2);
-webkit-box-shadow: inset 1px 1px 0 rgba(0,0,0,0.10),inset 0 -1px 0 rgba(0,0,0,0.07);
}
</style>

</head>

<body>
<paper-iconset id="meta"></paper-iconset>

<template is="dom-bind" id="wav">

    <iron-localstorage name="waveform" value="{{stored_options}}"></iron-localstorage>
    <value-transform value_b="{{options}}" value_a="{{stored_options}}"
        a_to_b="_sanitize_options"></value-transform>

    <div class="hidden_clipboard"></div>

    <div style="position: absolute;">
            
        <floating-pane id="action_info" grabber_mode="[[grabber_mode]]" hidden>
            <div class='pane_title'>Action List [z]</div>
            <undo-stack-view 
                    undo_stack="[[cut_undo_stack]]"
                    redo_stack="[[cut_redo_stack]]"></undo-stack-view>
        </floating-pane>
        

        <floating-pane id="tc_info" grabber_mode="[[grabber_mode]]" hidden>
            <div class='pane_title'>Temporal auto correlation [t]</div>
            <p class="nodrag">
                Time window <span class="slider_val">[[options.max_delta_t]] ms</span><br>
                <paper-slider pin snaps min="20" max="5000" step="20" value="{{options.max_delta_t}}" style='width:300px;'></paper-slider><br>
            </p><p>
                The number of bins is fixed at 100.
            </p>
        </floating-pane>

        <floating-pane id="drift_info" grabber_mode="[[grabber_mode]]" hidden>
            <div class='pane_title'>Drift [d]</div>
            Render the cluster plots and spatial spike plot using a palette that shows the average time for spikes in each pixel (smoothing is applied in the case of the cluster plots but not for the spatial plot). <br><br>
            <div style="/* background:#f00; */color: #fff; text-align: center;background: -moz-linear-gradient(left, #ff0000 0%, #00ff00 100%); /* FF3.6+ */  background: -webkit-gradient(linear, left top, right top, color-stop(0%,#ff0000), color-stop(100%,#00ff00)); /* Chrome,Safari4+ */  background: -webkit-linear-gradient(left, #ff0000 0%,#00ff00 100%); /* Chrome10+,Safari5.1+ */  background: -o-linear-gradient(left, #ff0000 0%,#00ff00 100%); /* Opera 11.10+ */  background: -ms-linear-gradient(left, #ff0000 0%,#00ff00 100%); /* IE10+ */  background: linear-gradient(to right, #ff0000 0%,#00ff00 100%); /* W3C */;">early mean time ------ late mean time</div><br><br>
            So red means that the spikes have "dissapeared" from that area of the plot as the trial progressed, while green means "new" spikes have "appeared" (scare quotes needed because it could be more complciated than this).<br>
        </floating-pane>
                    
        <floating-pane id="shortcut_info" grabber_mode="[[grabber_mode]]" style="max-height: 350px;" hidden>
            <div class='pane_title'>Shortcuts [k]</div>
            <p>
                For most of the following shortcuts, if you use <b>alt-x</b> instead of just <b>x</b> you will toggle the settings 
                pane for the given feature, e.g. <b>alt-r</b> toggles the settings pane for spatial ratemap, whereas <b>r</b> 
                by itself toggles the actual ratemap plots.  (In some cases <b>alt</b> is not needed because toggling the pane is
                the only action linked to the shortcut.)
            </p><p>
                 Shorcuts for the plots shown for each group; use <b>shift</b> to select multiple:
                <ul>
                <li><b>w</b> waveforms</li>
                <li><b>r</b> spatial ratemap</li>
                <li><b>c</b> directional ratemap ("c" is for circle)</li>
                <li><b>v</b> speed ratemap ("v" is for velocity)</li>
                <li><b>t</b> temporal autocorrelogram</li>
                </ul>
            </p><p>
                Shorcuts applied to the "active" group, which is the one under the cursor:
                <ul>
                <li><b>e</b> set the cluster painting destination group to the active group.</li>
                <li><b>f</b> set the cluster painting srouce group to the active group. Note you can hold down shift to toggle multiple source groups on/off.</li>
                <li><b>s</b> launch the swap dialog for the "active" group.</li>
                <li><b>ctrl-c</b> copy the active group's plots and some info text to the system clipboard.</li>
                </ul>           
            </p><p>
                Other shortcuts:
                <ul>
                <li><b>0-9</b> jump to tetrode number with 1s digit 0-9</li>
                <li><b>o</b> (the letter "o") toggle 10s digit of tetrode number</li>
                <li><b>d</b> toggle drift rendering on/off</li>
                <li><b>space</b> hold down space and click with mouse for plot grabbing or removal</li>
                <li><b>+/-</b> grow/shrink size of cluster plots (note that "+" is actually the "=" key)</li>
                <li><b>enter</b> increment cluster painting destination group</li>
                <li><b>esc</b> open/close the toolbar</li>
                <li><b>p</b> toggle waveform palette</li>
                <li><b>h</b> show header info</li>
                <li><b>x</b> show pos settings</li>
                <li><b>k</b> show this info ("k" is for keyboard)</li>
                <li><b>?</b> open GitHub info in a new tab</li>
                </ul>   
            </p>                    
        </floating-pane>
        
        <floating-pane id="speed_info" grabber_mode="[[grabber_mode]]" hidden>
            <div class='pane_title'>Speed ratemap [v]</div>
            <p>
                Bin size <span class="slider_val">4 cm/s</span><br>
                Upper limit <span class="slider_val">45 cm/s</span>
            </p><p>
                Histogram shows slowest speed at the top, and upper limit speed at the bottom.
            </p><p>
                WARNING: speed plots are still in alpha testing (unlike everything else which is just about in beta!).
            </p>
        </floating-pane>

        <floating-pane id="waves_info" grabber_mode="[[grabber_mode]]" hidden>
            <div class='pane_title'>Waves [w]</div>
            <p>
                There are two palette modes. 
            </p><p class="nodrag">
                Render in <span class="slider_val">[[options.waves_render_mode]]</span> mode.<br>
                <paper-toggle-button checked="{{waves_toggle_raw}}"></paper-toggle-button>
                <value-transform value_a="{{options.waves_render_mode}}" value_b="{{waves_toggle_raw}}"
                        b_to_a="_to_render_mode_str" a_to_b="_from_render_mode_str"
                        ></value-transform>
            </p><p>
                In "flag" mode, each group from 0 to 30 gets its own color, and is rendered solidly in that color.
            </p><p>
                In "density" mode, the color of each pixel reflects the proportion of the waves which cross it.
            </p>
        </floating-pane>

        <floating-pane id='header_info' grabber_mode="[[grabber_mode]]" has_search search_text="{{options.header_filter}}" 
                    search_placeholder="filter headers" disable_shortcuts="{{disable_shortcuts}}" hidden>
            <div class='pane_title'>File headers [h]</div>
            <header-view 
            set_header="[[set_header]]"
            pos_header="[[pos_header]]"
            tet_header="[[tet_header]]"
            cut_header="[[_get_safe(cut_box,'header')]]"
            header_filter="[[options.header_filter]]"
            ></header-view>
        </floating-pane>

        <floating-pane id="rm_info" grabber_mode="[[grabber_mode]]" hidden>
            <div class='pane_title'>Spatial ratemap [r]</div>
            <p class="nodrag">
                Bin size <span class="slider_val">[[options.cm_per_spa_bin]] cm</span><br>
                <paper-slider pin snaps min="0.5" max="10" step="0.5" value="{{options.cm_per_spa_bin}}" style='width:300px'></paper-slider>
            </p><p class="nodrag">
                Smoothing kernel boxcar <span class="slider_val">(2x[[options.smoothing_spa_bins]]+1) by (2x[[options.smoothing_spa_bins]]+1) bins</span><br>
                <paper-slider pin snaps min="0" max="5" step="1" value="{{options.smoothing_spa_bins}}" style='width:300px;'></paper-slider>
            </p><p class="nodrag">
                Ratemap frequency values are <span class="slider_val">{{_make_max_rate_caption(options.max_rate_spa)}}</span><br>
                <paper-slider pin snaps min="0" max="20" step="1" value="{{options.max_rate_spa}}" style='width:300px'></paper-slider>
            </p><p>
                The true peak rate is shown as "spa max" when you move your cursor over a group.
            </p>
            <p class="nodrag">
                Ratemap height:<span class="slider_val">{{_make_spa_rm_height_caption(options.spa_rm_height)}}</span><br>
                <paper-slider pin snaps min="0" max="400" step="20" value="{{options.spa_rm_height}}"></paper-slider>
            </p>
        </floating-pane>
        
        <floating-pane id="dir_info" grabber_mode="[[grabber_mode]]" hidden>
            <div class='pane_title'>Directional ratemap [c]</div>
            <p class="nodrag">
                Bin size <span class="slider_val">[[options.deg_per_dir_bin]] degrees</span><br>
                <paper-slider  pin snaps min="2" max="15" step="1" value="{{options.deg_per_dir_bin}}" style='width:300px'></paper-slider>
            </p><p class="nodrag">
                Smoothing kernel boxcar <span class="slider_val">([[options.smoothing_dir_bins]]x2+1) bins</span><br>
                <paper-slider pin snaps min="0" max="10" step="1" value="{{options.smoothing_dir_bins}}" style='width:300px'></paper-slider>
            </p><p>
                Note that in 2-spot LED mode, the relative position of the two LEDs is used, in 1-spot LED mode,
                 the direction of movement is used (this is sometimes refered to as "displacement direction").
            </p><p>
                The true peak rate is shown as "dir max" when you move your cursor over a group.
            </p>
        </floating-pane>

        <floating-pane id="pos_info" grabber_mode="[[grabber_mode]]" hidden>
            <div class='pane_title'>position post processing</div>
            <p>
                If you tracked with two LEDs you can read in both data streams.  "Standard" post-processing will be applied to decide when
                the two spots have swapped.
            </p><p class="nodrag">
                Use <span class="slider_val">[[options.use_n_leds]] LEDs</span>:<br>
                <paper-slider class="nodrag" pin snaps min="1" max="2" step="1" value="{{options.use_n_leds}}" style='width:80px'></paper-slider>
            </p><p>
                The following filtering and smoothing is applied to the one/two data streams separately.
                If two LEDs are used, a single estimate of position is produced at the end, using a weighted sum.
            </p><p class="nodrag">
                Speed <span class="slider_val">{{_make_max_speed_caption(options.speed_filter_mps)}}</span><br>
                <paper-slider class="nodrag" pin snaps min="0" max="10" step="0.25" value="{{options.speed_filter_mps}}" style='width:300px'></paper-slider><br>
            </p><p>
                Where the speed appears to rise above this threshold the data is considered invalid.
            </p><p>
                Where data is missing (either because no pixels were tracked for the given sample or the above filter invalidated the data),
                new values are created by linearly interpolated across the gaps.
            </p><p class="nodrag">
                Smoothing <span class="slider_val">{{_make_pos_smoothing_caption(options.pos_smoothing_s)}}</span><br>
                <paper-slider class="nodrag" pin snaps min="0" max="4" step="0.1" value="{{options.pos_smoothing_s}}" style='width:300px'></paper-slider>
            </p><p>
                Following filtering for speed and interpolation, the X and Y data is smoothed using a boxcar (i.e. moving average) of the above width.
            </p>
        </floating-pane>

        <template is="dom-repeat" items="[[grabbed_tiles]]">
            <floating-pane 
                  grabber_mode="[[grabber_mode]]"
                  initial_x='[[item.x]]'
                  initial_y='[[item.y]]'
                  on-close="_close_grabbed_tile" style="max-width:initial;" >
                <div class='pane_title'>[[item.title]]</div>
                <tile-element group_model='[[item.group]]' group_num='[[item.group_num]]' class="noborder"></tile-element>
            </floating-pane>
        </template>

    </div>
        
    <paper-toolbar style$="{{_style_toolbar(options.toggle_toolbar)}}">
        <div>
            <paper-icon-button icon="flip-to-front" on-tap="open_github"></paper-icon-button>
            <paper-tooltip position="right">help on GitHub [?]</paper-tooltip>
        </div>

        <div>
            <paper-icon-button icon="list" on-tap="toggle_shorcut_pane"></paper-icon-button>
            <paper-tooltip>keyboard shortcuts [k]</paper-tooltip>
        </div>

        <div>
            <paper-icon-button icon="reply" id="undo_button"></paper-icon-button>
            <paper-tooltip>undo [z]</paper-tooltip>
        </div>

        <div>
            <paper-icon-button icon="info" id='file_headers_button' on-tap="toggle_header_pane"></paper-icon-button>
            <paper-tooltip>file headers [h]</paper-tooltip>
        </div>

        <div>
            <paper-icon-button icon="swap-horiz" id='drift_button'></paper-icon-button>
            <paper-tooltip>toggle drift [d]</paper-tooltip>
        </div>

        <div>
            <paper-icon-button icon="sort" id='reorder_n_button'></paper-icon-button>
            <paper-tooltip>sort on group size [n]</paper-tooltip>
        </div>

        <div>
            <paper-icon-button icon="settings-applications" id='pos_settings' on-tap="toggle_pos_pane"></paper-icon-button>
            <paper-tooltip>position post processing settings [x]</paper-tooltip>
        </div>

        <div>
            <paper-button selected$="{{_yn_to_bool(options.show_waves, 0)}}" on-tap="show_tap" id="show_wav">wav</paper-button>
            <paper-tooltip>waves [w]</paper-tooltip>
        </div>

        <div>
            <paper-button selected$="{{_yn_to_bool(options.show_rms, 0)}}" on-tap="show_tap" id="show_rm">rm</paper-button>
            <paper-tooltip>spatial ratemap [r]</paper-tooltip>
        </div>

        <div>
            <paper-button selected$="{{_yn_to_bool(options.show_rms, 1)}}" on-tap="show_tap" id="show_dir">dir</paper-button>
            <paper-tooltip>directional ratemap [c]</paper-tooltip>
        </div>

        <div>
            <paper-button selected$="{{_yn_to_bool(options.show_rms, 2)}}" on-tap="show_tap" id="show_spd">spd</paper-button>
            <paper-tooltip>speed ratemap [v]</paper-tooltip>
        </div>

        <div>
            <paper-button selected$="{{_yn_to_bool(options.show_tac, 0)}}" on-tap="show_tap" id="show_tc">tc</paper-button>
            <paper-tooltip>temporal autocorrelation [t]</paper-tooltip>
        </div>

    </paper-toolbar>

    <div style="flex: 1; display:flex; flex-direction:row; position:relative;">
        <document-focus-marker></document-focus-marker>
        
        <iron-resize-notifier style="display:flex; flex-direction:column;">

            <file-organiser style="flex:0 0 0%;"
                is_dragging_in="{{drop_in_progress}}"
                no_files="{{no_files}}"
                selected_files="{{selected_files}}"
                selected_trial="{{selected_trial}}"
                selected_tet_num="{{selected_tet_num}}"
            ></file-organiser>
            
            <iron-splitter direction="up" size="{{options.splitter_a_size}}"></iron-splitter>

            <div style="flex:1 1 0%; position:relative;display: flex; flex-direction: row;">
                <managed-canvas style="margin:0 auto;" stretch_height ckey="[[pos_path]]" ></managed-canvas>
                <div class="info_summary">
                    <div class="info_summary_text">
                    </div>
                    <canvas id="speedhist" width="50" height= "84"></canvas>
                    <div id="speedhist_labels" style="display:inline;position:relative;">
                        <div style="position:absolute;right:0px;color:#888;font-size:8px;bottom:-2px;">45&nbsp;cm/s</div>
                    </div>
                </div>
            </div>

            <iron-splitter direction="down" size="{{options.splitter_b_size}}"></iron-splitter>
                    
            <cluster-plots id="cluster_plots"  style="flex:0 0 0%;"
               groups="[[cut_groups]]"
               painter_state="{{cut_painter_state}}"
               amplitudes="[[amplitudes]]"
               canvas_size="{{options.cluster_plot_size}}"
               want_amplitudes="{{want_amplitudes}}"
               active_group_a="{{active_group_a}}"
               painter_r="{{options.cluster_painter_r}}"
               on-paint="_paint">
               </cluster-plots>

        </iron-resize-notifier>

        <iron-splitter direction="left" size="{{options.splitter_c_size}}"></iron-splitter>
        
        <tile-wall style="flex:1 1 0%; position:relative;"
            groups="{{cut_groups}}"
            options="[[options]]"
            active_group_a="{{active_group_a}}"
            active_group_b="{{active_group_b}}"
            grabber_mode="[[grabber_mode]]"
            is_empty="[[tile_wall_is_empty]]"
            splitter_state="[[splitter_state]]"
            on-merge_groups="_merge_groups"
            on-grab_group="_grab_group"
            on-splitter="_splitter"
            on-tap_group="_highlight_group"
            ></tile-wall>

    </div>

    <paper-icon-button icon="menu" class="menu_toggle" on-tap="_toggle_toolbar"></paper-icon-button>
    
    <div class="grabber_signifier" style$="{{_show(grabber_mode)}}">
        grabber mode
    </div>


    <drop-zone
        show_initial="[[no_files]]"
        drop_in_progress="[[drop_in_progress]]">
        <div class="primary_text">
            drag &amp; drop files here
        </div>
        <div class='secondary_text'>
            the following types of data files are recognised: 
            <b><br>set | pos | tet | cut | clu</b><br>
            you can drag further files onto the window at any point<br>
            other file types will be ignored
        </div>
        <div class="initial_extra_under_secondary">
            <div class="github_button github_button_filedrop" on-tap="open_github">
                goto <b>readme, code, and issues</b> on github
            </div><br><br>
            <a href="https://www.youtube.com/watch?v=36o69CPu-1E" target="_blank">
                <img class="youtube_demo_img" src="img/demo_youtube.png" width="560" height="315"/>
            </a>
        </div>
        <div class='initial_extra_bottom_right'>
            Waveform v1.0, by DM<br> Tested with Chrome 49 <img src="img/chromelogo.png" width="15px" style="float:right;margin-left:2px;"/>
        </div>
    </drop-zone>

    <parsed-data 
        selected_files="[[selected_files]]"
        use_n_leds="[[options.use_n_leds]]"
        speed_filter_mps="[[options.speed_filter_mps]]"
        pos_smoothing_s="[[options.pos_smoothing_s]]"
        duration="{{duration}}"
        spike_times="{{spike_times}}"
        pos_xy="{{pos_xy}}"
        pos_dir="{{pos_dir}}"
        pos_speed="{{pos_speed}}"
        amplitudes="{{amplitudes}}"
        data_for_gl="{{data_for_gl}}"
        cut_box="{{cut_box}}"
        tet_header="{{tet_header}}"
        pos_header="{{pos_header}}"
        set_header="{{set_header}}"
        want_data_for_gl="{{want_data_for_gl}}"
        want_amplitudes="{{want_amplitudes}}"
        want_spike_times="{{want_spike_times}}"
        no_groups="{{tile_wall_is_empty}}"
        ></parsed-data>

    <cut-object id="cut"
        groups="{{cut_groups}}"
        painter_state="{{cut_painter_state}}"
        cut_box="[[cut_box]]"
        undo_stack_descriptions="{{cut_undo_stack}}"
        redo_stack_descriptions="{{cut_redo_stack}}"></cut-object>

    <rm-plots  
        groups="{{cut_groups}}" 
        pos_path="{{pos_path}}"
        active_group_a="{{active_group_a}}"
        active_group_b="{{active_group_b}}"
        spike_times="[[spike_times]]"
        pos_xy="[[pos_xy]]"
        pos_dir="[[pos_dir]]"
        pos_speed="[[pos_speed]]"
        show="[[options.show_rms]]"
        cm_per_spa_bin="[[options.cm_per_spa_bin]]"
        smoothing_spa_bins="[[options.smoothing_spa_bins]]"
        max_rate_spa="[[options.max_rate_spa]]"
        deg_per_dir_bin="[[options.deg_per_dir_bin]]"
        smoothing_dir_bins="[[options.smoothing_dir_bins]]"
        want_spike_times="{{want_spike_times}}"></rm-plots> 

    <tac-plots 
        groups="{{cut_groups}}" 
        max_delta_t="[[options.max_delta_t]]"
        spike_times="[[spike_times]]"
        show="[[options.show_tac]]"
        want_spike_times="{{want_spike_times}}"></tac-plots> 
                
    <wave-plots id="wave_plots"
        groups="{{cut_groups}}" 
        data_for_gl="[[data_for_gl]]"
        palette_mode="[[options.waves_render_mode]]"
        show_chans="[[options.show_waves]]"
        want_data_for_gl="{{want_data_for_gl}}"></wave-plots> 
    
    <iron-a11y-keys keys="esc" on-keys-pressed="_toggle_toolbar"              target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="h+only alt+h" on-keys-pressed="toggle_header_pane" target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="alt+p alt+w" on-keys-pressed="toggle_palette_pane" target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="p+only" on-keys-pressed="toggle_palette"           target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="alt+r" on-keys-pressed="toggle_spa_rm_pane"        target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="alt+c" on-keys-pressed="toggle_dir_rm_pane"        target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="alt+v" on-keys-pressed="toggle_speed_rm_pane"      target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="alt+t" on-keys-pressed="toggle_tac_pane"           target="[[keyboard_target]]"></iron-a11y-keys>    
    <iron-a11y-keys keys="k+only alt+k" on-keys-pressed="toggle_keyboard_pane" target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="alt+z" on-keys-pressed="toggle_action_pane"        target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="x+only alt+x" on-keys-pressed="toggle_pos_pane"    target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="w+only w+shift" on-keys-pressed="show_key_wav"     target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="r+only r+shift" on-keys-pressed="show_key_rm"      target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="c+only c+shift" on-keys-pressed="show_key_dir"     target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="v+only v+shift" on-keys-pressed="show_key_spd"     target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="t+only t+shift" on-keys-pressed="show_key_tc"      target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="s+only" on-keys-pressed="swap_groups"              target="[[keyboard_target]]"></iron-a11y-keys>

     <!-- TODO: use question mark key when bug is fixed: https://github.com/PolymerElements/iron-a11y-keys-behavior/issues/27#issuecomment-184833697 --> 
    <iron-a11y-keys keys="Â¿+only" on-keys-pressed="open_github"              target="[[keyboard_target]]"></iron-a11y-keys>
    
    
</template>





<script>
"use strict";
var wav = document.getElementById('wav')

wav.keyboard_target = document.querySelector('body'); // passed through to iron-a11y-keys

// :::: define default options and validate values read from localStorage :::::::::::::::

wav._sanitize_options = function(stored_options) {

    let opts = {
        max_delta_t: 500,
        show_rms: 'yyy',
        show_tac: 'y',
        show_waves: 'yyyy',
        cm_per_spa_bin: 2,
        smoothing_spa_bins: 2,
        max_rate_spa: -1,
        deg_per_dir_bin: 6,
        smoothing_dir_bins: 3,
        waves_render_mode: "density",
        use_n_leds: 2,
        speed_filter_mps: 4,
        pos_smoothing_s: 0.2,
        header_filter: '',
        spa_rm_height: 120,
        cluster_plot_size: 128,
        cluster_painter_r: 15,
        splitter_a_size: "200px",
        splitter_b_size: "300px",
        splitter_c_size: "350px",
        toggle_toolbar: true
    };

    if(!stored_options){
        return opts;
    }

    for(let k in opts){
        if(stored_options[k] !== undefined){
            opts[k] = stored_options[k];
        }
    }
    return opts;
}

// :::: the cutting tools: split, paint, merge, swap ::::::::::::::::::::::::::

wav._splitter = function(e){
    if(e.detail.state === "finalize" || e.detail.state === "cancel"){
        if(e.detail.state === "cancel"){
            if(wav.splitter_state.group_b){
                wav.$.cut.undo();
            }
        }
        wav.splitter_state._akey_full = null;
        wav.set('splitter_state.group_a', null);
        wav.set('splitter_state.group_b', null);
        wav.set('splitter_state.metrics', null);
        this.set('disable_shortcuts', false);
        return;
    }

    if(e.detail.state === "start"){
        wav.splitter_state._akey_full = e.detail.group.akey;
        wav.set('splitter_state.group_a', e.detail.group);
        this.set('disable_shortcuts', true); // TODO: probably should disable more than just shortcuts or else have a mechanism for reseting the split.
    } 
    if(e.detail.point !== null){
        wav.splitter_state._point = e.detail.point;
        wav.set('splitter_state.metrics', {
            x: e.detail.x,
            y: e.detail.y,
            w: e.detail.w
        });       
    }
    if(e.detail.state === "update"){
        if(wav.splitter_state.group_b){
            wav.$.cut.undo();
        }
        let m = this.$.wave_plots.mask_at_vt(wav.splitter_state._akey_full.array, wav.splitter_state._point);
        let group_num_a = wav.splitter_state.group_a.group_num;
        wav.$.cut.split_group(group_num_a, m);
        wav.set('splitter_state.group_a', wav.cut_groups[group_num_a]);
        wav.set('splitter_state.group_b', wav.cut_groups[group_num_a + 1]);
    }
}

wav._paint = function(e){
    if(e.detail.state === "start"){
        wav.set('disable_shortcuts', true); // TODO: probably should disable more than just shortcuts
    }

    if(e.detail.state === "end"){
        wav.set('disable_shortcuts', false);
        wav.$.cut.transplant_groups(e.detail.dest, e.detail.src_masks);
    }
}

wav._merge_groups = function(e){
    if(wav.tile_wall_is_empty){
        return;
    }
    wav.$.cut.merge_groups(e.detail.a, e.detail.b);
}

wav.swap_groups = function(){
    if(wav.tile_wall_is_empty){
        return;
    }

    let a, b;
    if(!wav.active_group_a){
        a = parseInt(prompt("Swap two groups. Enter first group:", ""));
        if(!(a>=0)){
            return;
        }
        b = parseInt(prompt("Swap two groups. Enter second group:", ""));
    } else {
        a = wav.active_group_a.group_num;
        b = parseInt(prompt("Enter group to swap with group " + a + ":", ""));
    }
    if(!(b>=0)){
        return;
    }

    wav.$.cut.swap_groups(a, b);
}

// :::: the grab tools: tile, (TODO: clusters & path) ::::::::::::::::::::::::::

wav._grab_group = function(e){
    if(!wav.grabbed_tiles){
        this.set('grabbed_tiles', []);
    }

    // for simplicity we make new canvases for this tile
    let cm = Utils.canvas_manager;
    let group = e.detail.group;
    this.push('grabbed_tiles', {
        title: wav.selected_trial +
               " t" + wav.selected_tet_num + 
                "c" + group.group_num + " [Grabbed]",
        group_num: group.group_num,
        group: {
            waves: cm.clone_ckey(group.waves),
            tac: cm.clone_ckey(group.tac),
            rm_spa: cm.clone_ckey(group.rm_spa),
            rm_dir: cm.clone_ckey(group.rm_dir),
            rm_speed: cm.clone_ckey(group.rm_speed)
        },
        x: e.detail.src_client_x + 20,
        y: e.detail.src_client_y + 20
    });
}

wav._close_grabbed_tile = function(e){
    // remove the grabbed tile from the list
    wav.splice('grabbed_tiles', wav.grabbed_tiles.indexOf(e.model.item), 1);
}


// :::: plot toggling :::::::::::::::::::::::::::::::

wav.toggle_show = function(id, shiftKey){
    // This is a bit ugly sadly. We want to allow basic toggling
    // without shift, and multi-toggling with shift.
    let result;
    if(!shiftKey){
        result = {
            waves: 'nnnn',
            tac: 'n',
            rms: 'nnn'
        };
        switch (id){
            case "show_wav":
            result.waves = 'yyyy';
            break;

            case "show_tc":
            result.tac = 'y';
            break;

            case "show_rm":
            result.rms = "ynn";
            break;

            case "show_dir":
            result.rms = "nyn";
            break;

            case "show_spd":
            result.rms = "nny";
            break;
        } 
    } else {
        result = {
            waves: wav.options.show_waves,
            tac: wav.options.show_tac,
            rms: wav.options.show_rms
        };
        let n_selected = (result.waves.indexOf('y') > -1) + 
                       (result.tac === 'y') + 
                       (result.rms[0] === 'y') + (result.rms[1] === 'y') + (result.rms[2] === 'y');

        switch (id){
            case "show_wav":
            if(result.waves === "yyyy" && n_selected > 1){
                result.waves = 'nnnn';                
            } else {
                result.waves = 'yyyy';
            }
            break;

            case "show_tc":
            if(result.tac === "y" && n_selected > 1){
                result.tac = 'n';                
            } else {
                result.tac = 'y';
            }
            break;

            case "show_rm":
            if(result.rms[0] === "y" && n_selected > 1){
                result.rms = "n" + result.rms.slice(1);                
            } else {
                result.rms = 'y' + result.rms.slice(1);
            }
            break;

            case "show_dir":
            if(result.rms[1] === "y" && n_selected > 1){
                result.rms = result.rms[0] + "n" + result.rms[2];                
            } else {
                result.rms = result.rms[0] + 'y' + result.rms[2];
            }
            break;

            case "show_spd":
            if(result.rms[2] === "y" && n_selected > 1){
                result.rms = result.rms.slice(0,-1) + "n";                
            } else {
                result.rms = result.rms.slice(0,-1) + 'y';
            }
            break;
        } 
    }
    wav.set('options.show_waves', result.waves);
    wav.set('options.show_tac', result.tac);
    wav.set('options.show_rms', result.rms);
}

wav.show_tap = function(e){
    wav.toggle_show(e.target.id, e.detail.sourceEvent.shiftKey);
    e.preventDefault(); 
}

wav.addEventListener('dom-change', function(){
    // remove keyboard handlers from buttons. Note that ripple still shows.
    let els =   Array.from(document.getElementsByTagName('paper-button'))
        .concat(Array.from(document.getElementsByTagName('paper-icon-button')));
    for(let el of els){
        el._unlistenKeyEventListeners();
    }

    // initialize some things which aren't part of options, and aren't initialzied elsewhere
    wav.set('splitter_state', {
        group_a: null,
        group_b: null,
        metrics: null,
        _akey_full: null,
        _point: null
    });
    wav.set('grabber_mode', false);
})


// :::: some very simple functions (this is the new ES6 "arrow function" syntax) :::::::::::::::

wav._to_render_mode_str = (is_checked) =>  is_checked ? "density" : "flag";
wav._from_render_mode_str = (str) => (str==="density");
wav._make_max_rate_caption = (v) => v > 0 ? "scaled to max of " + v + "Hz" : "individually scaled";
wav._make_max_speed_caption = (v) => v > 0 ? "capped at " + v + " m/s" : "not limited";
wav._make_pos_smoothing_caption = (v) =>  v > 0 ? v + " s" : "turned off";
wav._make_spa_rm_height_caption = (v) =>  v > 0 ? "stretch to " + v + "px" : "one pixel per bin";
wav._show = (v) => v ? '' : 'display: none;';
wav._yn_to_bool = (v, index) => (v && v[index] === 'y');
wav._style_toolbar = (toggle_toolbar) => toggle_toolbar ? '' : 'height:0px;overflow:hidden';
wav._get_safe = (a,b) => a && a[b]; // see https://github.com/Polymer/polymer/issues/1877
wav.toggle_action_pane = () => wav.$.action_info.toggle();
wav.toggle_keyboard_pane = () => wav.$.shortcut_info.toggle();
wav.toggle_tac_pane = () => wav.$.tc_info.toggle();
wav.toggle_spa_rm_pane = () => wav.$.rm_info.toggle();
wav.toggle_dir_rm_pane = () => wav.$.dir_info.toggle();
wav.toggle_speed_rm_pane = () => wav.$.speed_info.toggle();
wav.toggle_pos_pane = () => wav.$.pos_info.toggle();
wav.toggle_palette_pane = () => wav.$.waves_info.toggle();
wav.toggle_header_pane = () => wav.$.header_info.toggle();
wav.toggle_shorcut_pane = () => wav.$.shortcut_info.toggle();
wav.show_key_wav = (e) => wav.toggle_show('show_wav', e.detail.keyboardEvent.shiftKey);
wav.show_key_rm = (e) => wav.toggle_show('show_rm', e.detail.keyboardEvent.shiftKey);
wav.show_key_dir = (e) => wav.toggle_show('show_dir', e.detail.keyboardEvent.shiftKey);
wav.show_key_spd = (e) => wav.toggle_show('show_spd', e.detail.keyboardEvent.shiftKey);
wav.show_key_tc = (e) => wav.toggle_show('show_tc', e.detail.keyboardEvent.shiftKey);
wav._highlight_group = (e) => wav.$.cluster_plots.highlight_group(e.detail.group_num);
wav.toggle_palette = () =>  wav.set('options.waves_render_mode', wav.options.waves_render_mode === "density" ? "flag" : "density");
wav.open_github = () => window.open('https://github.com/d1manson/waveform', '_blank');
wav._toggle_toolbar = () => wav.set('options.toggle_toolbar', !wav.options.toggle_toolbar);

// :::: and then some stuff that doesn't sit so well with polymer ::::::::

document.addEventListener('contextmenu', function(e){
    e.preventDefault();
});
document.addEventListener('keydown', function(e){
    if(e.which === 32){//  space
        wav.set('grabber_mode', true);
    }
    if(e.which == 32){ //space
        e.preventDefault(); // normally does things like toggle buttons and scroll divs
    } 
}, true);
document.addEventListener('keyup', function(e){
    if(e.which === 32){
        wav.set('grabber_mode', false);
    }
})


</script>

</body>
</html>