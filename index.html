<!DOCTYPE html><html lang="en"><head><!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE
The complete set of authors may be found at http://polymer.github.io/AUTHORS
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS
--><!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico?">
<title>Waveform</title>

<script> 
console.log("")
console.log("%cWaveform v0.9.9 by DM", "color: blue; font-size: large; background: #ccc; border: 1px solid blue;padding: 4px 10px;");
console.log("")
document.addEventListener('keydown', function(e){
    if(wav.disable_shortcuts){
        e.stopImmediatePropagation(); // for this to be effective it needs to be the first registered listener
        return;
    }
}, true);

window.Polymer = {dom: 'shadow'}; // this tells Polymer to use fast native dom
</script>

<link rel="prefetch" href="img/demo_youtube_hover.png">
<style is="custom-style">
:root {
user-drag: none;
-webkit-user-drag: none;
user-select: none;
-webkit-user-select: none;
--paper-toolbar-height: 40px;
--paper-toolbar-background: #efefef;
--paper-toolbar-color: #000;
--paper-tooltip-opacity: 0.96;
--paper-icon-button: {
      width: 38px;
      height: 38px;
    };
--grabber-hover: {
border: 3px solid red;
background: rgba(255,0,0,0.2);
cursor: pointer;    
};
--cluster-plot-style:{
border: 1px solid #000;
padding: 1px;
margin-right: 2px;
margin-bottom: 2px;
};
}

a {
color: inherit;
}

p, ul, ol{
margin-top: 6px;
margin-bottom: 6px;
}

ul, ol{
padding-left:10px;
margin-left:10px;
}

canvas, img{
vertical-align: bottom;
}

body{
overflow:hidden;
font-family: sans-serif;
font-size: 0.8em;
position: fixed;
top: 0px;
left: 0px;
height: 100%;
width: 100%;
display: flex;
flex-direction: column;
margin: 0;
}

.info_summary{
position: absolute;
padding: 3px;
top: 0px;
left: 0px;
background: rgba(255,255,255,0.5);
-webkit-transition: opacity 0.5s ease-in-out;
transition: opacity 0.5s ease-in-out;
}

.slider_val{
font-weight: bold;
}

.github_button_filedrop{
cursor: pointer;
margin: 20px 0px 0px 0px;
border: 1px solid #999;
display: inline-block;
padding: 4px 10px 4px 10px;
border-radius: 4px;
background: #eee;
}

.github_button_filedrop:hover{
background: #ddd;
border-color: #777;
}
.youtube_demo_img:hover {
content: url('img/demo_youtube_hover.png');
}

paper-button{
min-width: 40px;
font-size: 0.8em;
border: 1px solid;
}
paper-button[selected] {
background-color: #ffffe0;
color: #c77;
}
paper-toolbar{
box-shadow: inset 0 0 2px 1px #ccc;
transition: height 1s;
}

.grabber_signifier{
position: fixed;
top: 6px;
right: 45px;
color: #f00;
font-weight: bold;
border: 2px solid #f00;
padding: 4px 6px 4px 6px;
border-radius: 4px;
}

.menu_toggle {
position: fixed;
top: 0px;
right: 0px;
background: #efefef;
}
iron-splitter {
background-image: url(img/handle.svg);
}
iron-splitter.horizontal{
background-image: url(img/handle-h.svg);
}

::-webkit-scrollbar {
width: 10px;
height: 10px;
}
::-webkit-scrollbar-button {
width: 0;
height: 0;
display: none;
}
::-webkit-scrollbar-thumb {
background-color: rgba(0,0,0,0.2);
-webkit-box-shadow: inset 1px 1px 0 rgba(0,0,0,0.10),inset 0 -1px 0 rgba(0,0,0,0.07);
}
.cluster_plot{
@apply(--cluster-plot-style);
}

.toolbar_divider{
margin: 0px 3px;
height: 70%;
width: 1px;
background: #B1B1B1;
}
</style>

</head>

<body><div hidden="" by-vulcanize=""><script>(function () {
function resolve() {
document.body.removeAttribute('unresolved');
}
if (window.WebComponents) {
addEventListener('WebComponentsReady', resolve);
} else {
if (document.readyState === 'interactive' || document.readyState === 'complete') {
resolve();
} else {
addEventListener('DOMContentLoaded', resolve);
}
}
}());
window.Polymer = {
Settings: function () {
var settings = window.Polymer || {};
var parts = location.search.slice(1).split('&');
for (var i = 0, o; i < parts.length && (o = parts[i]); i++) {
o = o.split('=');
o[0] && (settings[o[0]] = o[1] || true);
}
settings.wantShadow = settings.dom === 'shadow';
settings.hasShadow = Boolean(Element.prototype.createShadowRoot);
settings.nativeShadow = settings.hasShadow && !window.ShadowDOMPolyfill;
settings.useShadow = settings.wantShadow && settings.hasShadow;
settings.hasNativeImports = Boolean('import' in document.createElement('link'));
settings.useNativeImports = settings.hasNativeImports;
settings.useNativeCustomElements = !window.CustomElements || window.CustomElements.useNative;
settings.useNativeShadow = settings.useShadow && settings.nativeShadow;
settings.usePolyfillProto = !settings.useNativeCustomElements && !Object.__proto__;
return settings;
}()
};
(function () {
var userPolymer = window.Polymer;
window.Polymer = function (prototype) {
if (typeof prototype === 'function') {
prototype = prototype.prototype;
}
if (!prototype) {
prototype = {};
}
var factory = desugar(prototype);
prototype = factory.prototype;
var options = { prototype: prototype };
if (prototype.extends) {
options.extends = prototype.extends;
}
Polymer.telemetry._registrate(prototype);
document.registerElement(prototype.is, options);
return factory;
};
var desugar = function (prototype) {
var base = Polymer.Base;
if (prototype.extends) {
base = Polymer.Base._getExtendedPrototype(prototype.extends);
}
prototype = Polymer.Base.chainObject(prototype, base);
prototype.registerCallback();
return prototype.constructor;
};
if (userPolymer) {
for (var i in userPolymer) {
Polymer[i] = userPolymer[i];
}
}
Polymer.Class = desugar;
}());
Polymer.telemetry = {
registrations: [],
_regLog: function (prototype) {
console.log('[' + prototype.is + ']: registered');
},
_registrate: function (prototype) {
this.registrations.push(prototype);
Polymer.log && this._regLog(prototype);
},
dumpRegistrations: function () {
this.registrations.forEach(this._regLog);
}
};
Object.defineProperty(window, 'currentImport', {
enumerable: true,
configurable: true,
get: function () {
return (document._currentScript || document.currentScript).ownerDocument;
}
});
Polymer.RenderStatus = {
_ready: false,
_callbacks: [],
whenReady: function (cb) {
if (this._ready) {
cb();
} else {
this._callbacks.push(cb);
}
},
_makeReady: function () {
this._ready = true;
for (var i = 0; i < this._callbacks.length; i++) {
this._callbacks[i]();
}
this._callbacks = [];
},
_catchFirstRender: function () {
requestAnimationFrame(function () {
Polymer.RenderStatus._makeReady();
});
},
_afterNextRenderQueue: [],
_waitingNextRender: false,
afterNextRender: function (element, fn, args) {
this._watchNextRender();
this._afterNextRenderQueue.push([
element,
fn,
args
]);
},
_watchNextRender: function () {
if (!this._waitingNextRender) {
this._waitingNextRender = true;
var fn = function () {
Polymer.RenderStatus._flushNextRender();
};
if (!this._ready) {
this.whenReady(fn);
} else {
requestAnimationFrame(fn);
}
}
},
_flushNextRender: function () {
var self = this;
setTimeout(function () {
self._flushRenderCallbacks(self._afterNextRenderQueue);
self._afterNextRenderQueue = [];
self._waitingNextRender = false;
});
},
_flushRenderCallbacks: function (callbacks) {
for (var i = 0, h; i < callbacks.length; i++) {
h = callbacks[i];
h[1].apply(h[0], h[2] || Polymer.nar);
}
}
};
if (window.HTMLImports) {
HTMLImports.whenReady(function () {
Polymer.RenderStatus._catchFirstRender();
});
} else {
Polymer.RenderStatus._catchFirstRender();
}
Polymer.ImportStatus = Polymer.RenderStatus;
Polymer.ImportStatus.whenLoaded = Polymer.ImportStatus.whenReady;
(function () {
'use strict';
var settings = Polymer.Settings;
Polymer.Base = {
__isPolymerInstance__: true,
_addFeature: function (feature) {
this.extend(this, feature);
},
registerCallback: function () {
this._desugarBehaviors();
this._doBehavior('beforeRegister');
this._registerFeatures();
if (!settings.lazyRegister) {
this.ensureRegisterFinished();
}
},
createdCallback: function () {
if (!this.__hasRegisterFinished) {
this._ensureRegisterFinished(this.__proto__);
}
Polymer.telemetry.instanceCount++;
this.root = this;
this._doBehavior('created');
this._initFeatures();
},
ensureRegisterFinished: function () {
this._ensureRegisterFinished(this);
},
_ensureRegisterFinished: function (proto) {
if (proto.__hasRegisterFinished !== proto.is) {
proto.__hasRegisterFinished = proto.is;
if (proto._finishRegisterFeatures) {
proto._finishRegisterFeatures();
}
proto._doBehavior('registered');
}
},
attachedCallback: function () {
var self = this;
Polymer.RenderStatus.whenReady(function () {
self.isAttached = true;
self._doBehavior('attached');
});
},
detachedCallback: function () {
this.isAttached = false;
this._doBehavior('detached');
},
attributeChangedCallback: function (name, oldValue, newValue) {
this._attributeChangedImpl(name);
this._doBehavior('attributeChanged', [
name,
oldValue,
newValue
]);
},
_attributeChangedImpl: function (name) {
this._setAttributeToProperty(this, name);
},
extend: function (prototype, api) {
if (prototype && api) {
var n$ = Object.getOwnPropertyNames(api);
for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
this.copyOwnProperty(n, api, prototype);
}
}
return prototype || api;
},
mixin: function (target, source) {
for (var i in source) {
target[i] = source[i];
}
return target;
},
copyOwnProperty: function (name, source, target) {
var pd = Object.getOwnPropertyDescriptor(source, name);
if (pd) {
Object.defineProperty(target, name, pd);
}
},
_log: console.log.apply.bind(console.log, console),
_warn: console.warn.apply.bind(console.warn, console),
_error: console.error.apply.bind(console.error, console),
_logf: function () {
return this._logPrefix.concat([this.is]).concat(Array.prototype.slice.call(arguments, 0));
}
};
Polymer.Base._logPrefix = function () {
var color = window.chrome || /firefox/i.test(navigator.userAgent);
return color ? [
'%c[%s::%s]:',
'font-weight: bold; background-color:#EEEE00;'
] : ['[%s::%s]:'];
}();
Polymer.Base.chainObject = function (object, inherited) {
if (object && inherited && object !== inherited) {
if (!Object.__proto__) {
object = Polymer.Base.extend(Object.create(inherited), object);
}
object.__proto__ = inherited;
}
return object;
};
Polymer.Base = Polymer.Base.chainObject(Polymer.Base, HTMLElement.prototype);
if (window.CustomElements) {
Polymer.instanceof = CustomElements.instanceof;
} else {
Polymer.instanceof = function (obj, ctor) {
return obj instanceof ctor;
};
}
Polymer.isInstance = function (obj) {
return Boolean(obj && obj.__isPolymerInstance__);
};
Polymer.telemetry.instanceCount = 0;
}());
(function () {
var modules = {};
var lcModules = {};
var findModule = function (id) {
return modules[id] || lcModules[id.toLowerCase()];
};
var DomModule = function () {
return document.createElement('dom-module');
};
DomModule.prototype = Object.create(HTMLElement.prototype);
Polymer.Base.extend(DomModule.prototype, {
constructor: DomModule,
createdCallback: function () {
this.register();
},
register: function (id) {
id = id || this.id || this.getAttribute('name') || this.getAttribute('is');
if (id) {
this.id = id;
modules[id] = this;
lcModules[id.toLowerCase()] = this;
}
},
import: function (id, selector) {
if (id) {
var m = findModule(id);
if (!m) {
forceDomModulesUpgrade();
m = findModule(id);
}
if (m && selector) {
m = m.querySelector(selector);
}
return m;
}
}
});
var cePolyfill = window.CustomElements && !CustomElements.useNative;
document.registerElement('dom-module', DomModule);
function forceDomModulesUpgrade() {
if (cePolyfill) {
var script = document._currentScript || document.currentScript;
var doc = script && script.ownerDocument || document;
var modules = doc.querySelectorAll('dom-module');
for (var i = modules.length - 1, m; i >= 0 && (m = modules[i]); i--) {
if (m.__upgraded__) {
return;
} else {
CustomElements.upgrade(m);
}
}
}
}
}());
Polymer.Base._addFeature({
_prepIs: function () {
if (!this.is) {
var module = (document._currentScript || document.currentScript).parentNode;
if (module.localName === 'dom-module') {
var id = module.id || module.getAttribute('name') || module.getAttribute('is');
this.is = id;
}
}
if (this.is) {
this.is = this.is.toLowerCase();
}
}
});
Polymer.Base._addFeature({
behaviors: [],
_desugarBehaviors: function () {
if (this.behaviors.length) {
this.behaviors = this._desugarSomeBehaviors(this.behaviors);
}
},
_desugarSomeBehaviors: function (behaviors) {
var behaviorSet = [];
behaviors = this._flattenBehaviorsList(behaviors);
for (var i = behaviors.length - 1; i >= 0; i--) {
var b = behaviors[i];
if (behaviorSet.indexOf(b) === -1) {
this._mixinBehavior(b);
behaviorSet.unshift(b);
}
}
return behaviorSet;
},
_flattenBehaviorsList: function (behaviors) {
var flat = [];
for (var i = 0; i < behaviors.length; i++) {
var b = behaviors[i];
if (b instanceof Array) {
flat = flat.concat(this._flattenBehaviorsList(b));
} else if (b) {
flat.push(b);
} else {
this._warn(this._logf('_flattenBehaviorsList', 'behavior is null, check for missing or 404 import'));
}
}
return flat;
},
_mixinBehavior: function (b) {
var n$ = Object.getOwnPropertyNames(b);
for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
if (!Polymer.Base._behaviorProperties[n] && !this.hasOwnProperty(n)) {
this.copyOwnProperty(n, b, this);
}
}
},
_prepBehaviors: function () {
this._prepFlattenedBehaviors(this.behaviors);
},
_prepFlattenedBehaviors: function (behaviors) {
for (var i = 0, l = behaviors.length; i < l; i++) {
this._prepBehavior(behaviors[i]);
}
this._prepBehavior(this);
},
_doBehavior: function (name, args) {
for (var i = 0; i < this.behaviors.length; i++) {
this._invokeBehavior(this.behaviors[i], name, args);
}
this._invokeBehavior(this, name, args);
},
_invokeBehavior: function (b, name, args) {
var fn = b[name];
if (fn) {
fn.apply(this, args || Polymer.nar);
}
},
_marshalBehaviors: function () {
for (var i = 0; i < this.behaviors.length; i++) {
this._marshalBehavior(this.behaviors[i]);
}
this._marshalBehavior(this);
}
});
Polymer.Base._behaviorProperties = {
hostAttributes: true,
beforeRegister: true,
registered: true,
properties: true,
observers: true,
listeners: true,
created: true,
attached: true,
detached: true,
attributeChanged: true,
ready: true
};
Polymer.Base._addFeature({
_getExtendedPrototype: function (tag) {
return this._getExtendedNativePrototype(tag);
},
_nativePrototypes: {},
_getExtendedNativePrototype: function (tag) {
var p = this._nativePrototypes[tag];
if (!p) {
var np = this.getNativePrototype(tag);
p = this.extend(Object.create(np), Polymer.Base);
this._nativePrototypes[tag] = p;
}
return p;
},
getNativePrototype: function (tag) {
return Object.getPrototypeOf(document.createElement(tag));
}
});
Polymer.Base._addFeature({
_prepConstructor: function () {
this._factoryArgs = this.extends ? [
this.extends,
this.is
] : [this.is];
var ctor = function () {
return this._factory(arguments);
};
if (this.hasOwnProperty('extends')) {
ctor.extends = this.extends;
}
Object.defineProperty(this, 'constructor', {
value: ctor,
writable: true,
configurable: true
});
ctor.prototype = this;
},
_factory: function (args) {
var elt = document.createElement.apply(document, this._factoryArgs);
if (this.factoryImpl) {
this.factoryImpl.apply(elt, args);
}
return elt;
}
});
Polymer.nob = Object.create(null);
Polymer.Base._addFeature({
properties: {},
getPropertyInfo: function (property) {
var info = this._getPropertyInfo(property, this.properties);
if (!info) {
for (var i = 0; i < this.behaviors.length; i++) {
info = this._getPropertyInfo(property, this.behaviors[i].properties);
if (info) {
return info;
}
}
}
return info || Polymer.nob;
},
_getPropertyInfo: function (property, properties) {
var p = properties && properties[property];
if (typeof p === 'function') {
p = properties[property] = { type: p };
}
if (p) {
p.defined = true;
}
return p;
},
_prepPropertyInfo: function () {
this._propertyInfo = {};
for (var i = 0; i < this.behaviors.length; i++) {
this._addPropertyInfo(this._propertyInfo, this.behaviors[i].properties);
}
this._addPropertyInfo(this._propertyInfo, this.properties);
this._addPropertyInfo(this._propertyInfo, this._propertyEffects);
},
_addPropertyInfo: function (target, source) {
if (source) {
var t, s;
for (var i in source) {
t = target[i];
s = source[i];
if (i[0] === '_' && !s.readOnly) {
continue;
}
if (!target[i]) {
target[i] = {
type: typeof s === 'function' ? s : s.type,
readOnly: s.readOnly,
attribute: Polymer.CaseMap.camelToDashCase(i)
};
} else {
if (!t.type) {
t.type = s.type;
}
if (!t.readOnly) {
t.readOnly = s.readOnly;
}
}
}
}
}
});
Polymer.CaseMap = {
_caseMap: {},
_rx: {
dashToCamel: /-[a-z]/g,
camelToDash: /([A-Z])/g
},
dashToCamelCase: function (dash) {
return this._caseMap[dash] || (this._caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(this._rx.dashToCamel, function (m) {
return m[1].toUpperCase();
}));
},
camelToDashCase: function (camel) {
return this._caseMap[camel] || (this._caseMap[camel] = camel.replace(this._rx.camelToDash, '-$1').toLowerCase());
}
};
Polymer.Base._addFeature({
_addHostAttributes: function (attributes) {
if (!this._aggregatedAttributes) {
this._aggregatedAttributes = {};
}
if (attributes) {
this.mixin(this._aggregatedAttributes, attributes);
}
},
_marshalHostAttributes: function () {
if (this._aggregatedAttributes) {
this._applyAttributes(this, this._aggregatedAttributes);
}
},
_applyAttributes: function (node, attr$) {
for (var n in attr$) {
if (!this.hasAttribute(n) && n !== 'class') {
var v = attr$[n];
this.serializeValueToAttribute(v, n, this);
}
}
},
_marshalAttributes: function () {
this._takeAttributesToModel(this);
},
_takeAttributesToModel: function (model) {
if (this.hasAttributes()) {
for (var i in this._propertyInfo) {
var info = this._propertyInfo[i];
if (this.hasAttribute(info.attribute)) {
this._setAttributeToProperty(model, info.attribute, i, info);
}
}
}
},
_setAttributeToProperty: function (model, attribute, property, info) {
if (!this._serializing) {
property = property || Polymer.CaseMap.dashToCamelCase(attribute);
info = info || this._propertyInfo && this._propertyInfo[property];
if (info && !info.readOnly) {
var v = this.getAttribute(attribute);
model[property] = this.deserialize(v, info.type);
}
}
},
_serializing: false,
reflectPropertyToAttribute: function (property, attribute, value) {
this._serializing = true;
value = value === undefined ? this[property] : value;
this.serializeValueToAttribute(value, attribute || Polymer.CaseMap.camelToDashCase(property));
this._serializing = false;
},
serializeValueToAttribute: function (value, attribute, node) {
var str = this.serialize(value);
node = node || this;
if (str === undefined) {
node.removeAttribute(attribute);
} else {
node.setAttribute(attribute, str);
}
},
deserialize: function (value, type) {
switch (type) {
case Number:
value = Number(value);
break;
case Boolean:
value = value != null;
break;
case Object:
try {
value = JSON.parse(value);
} catch (x) {
}
break;
case Array:
try {
value = JSON.parse(value);
} catch (x) {
value = null;
console.warn('Polymer::Attributes: couldn`t decode Array as JSON');
}
break;
case Date:
value = new Date(value);
break;
case String:
default:
break;
}
return value;
},
serialize: function (value) {
switch (typeof value) {
case 'boolean':
return value ? '' : undefined;
case 'object':
if (value instanceof Date) {
return value.toString();
} else if (value) {
try {
return JSON.stringify(value);
} catch (x) {
return '';
}
}
default:
return value != null ? value : undefined;
}
}
});
Polymer.version = '1.4.0';
Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepBehaviors();
this._prepConstructor();
this._prepPropertyInfo();
},
_prepBehavior: function (b) {
this._addHostAttributes(b.hostAttributes);
},
_marshalBehavior: function (b) {
},
_initFeatures: function () {
this._marshalHostAttributes();
this._marshalBehaviors();
}
});</script><script>Polymer.Base._addFeature({
_prepTemplate: function () {
if (this._template === undefined) {
this._template = Polymer.DomModule.import(this.is, 'template');
}
if (this._template && this._template.hasAttribute('is')) {
this._warn(this._logf('_prepTemplate', 'top-level Polymer template ' + 'must not be a type-extension, found', this._template, 'Move inside simple <template>.'));
}
if (this._template && !this._template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
HTMLTemplateElement.decorate(this._template);
}
},
_stampTemplate: function () {
if (this._template) {
this.root = this.instanceTemplate(this._template);
}
},
instanceTemplate: function (template) {
var dom = document.importNode(template._content || template.content, true);
return dom;
}
});
(function () {
var baseAttachedCallback = Polymer.Base.attachedCallback;
Polymer.Base._addFeature({
_hostStack: [],
ready: function () {
},
_registerHost: function (host) {
this.dataHost = host = host || Polymer.Base._hostStack[Polymer.Base._hostStack.length - 1];
if (host && host._clients) {
host._clients.push(this);
}
this._clients = null;
this._clientsReadied = false;
},
_beginHosting: function () {
Polymer.Base._hostStack.push(this);
if (!this._clients) {
this._clients = [];
}
},
_endHosting: function () {
Polymer.Base._hostStack.pop();
},
_tryReady: function () {
this._readied = false;
if (this._canReady()) {
this._ready();
}
},
_canReady: function () {
return !this.dataHost || this.dataHost._clientsReadied;
},
_ready: function () {
this._beforeClientsReady();
if (this._template) {
this._setupRoot();
this._readyClients();
}
this._clientsReadied = true;
this._clients = null;
this._afterClientsReady();
this._readySelf();
},
_readyClients: function () {
this._beginDistribute();
var c$ = this._clients;
if (c$) {
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
c._ready();
}
}
this._finishDistribute();
},
_readySelf: function () {
this._doBehavior('ready');
this._readied = true;
if (this._attachedPending) {
this._attachedPending = false;
this.attachedCallback();
}
},
_beforeClientsReady: function () {
},
_afterClientsReady: function () {
},
_beforeAttached: function () {
},
attachedCallback: function () {
if (this._readied) {
this._beforeAttached();
baseAttachedCallback.call(this);
} else {
this._attachedPending = true;
}
}
});
}());
Polymer.ArraySplice = function () {
function newSplice(index, removed, addedCount) {
return {
index: index,
removed: removed,
addedCount: addedCount
};
}
var EDIT_LEAVE = 0;
var EDIT_UPDATE = 1;
var EDIT_ADD = 2;
var EDIT_DELETE = 3;
function ArraySplice() {
}
ArraySplice.prototype = {
calcEditDistances: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
var rowCount = oldEnd - oldStart + 1;
var columnCount = currentEnd - currentStart + 1;
var distances = new Array(rowCount);
for (var i = 0; i < rowCount; i++) {
distances[i] = new Array(columnCount);
distances[i][0] = i;
}
for (var j = 0; j < columnCount; j++)
distances[0][j] = j;
for (i = 1; i < rowCount; i++) {
for (j = 1; j < columnCount; j++) {
if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))
distances[i][j] = distances[i - 1][j - 1];
else {
var north = distances[i - 1][j] + 1;
var west = distances[i][j - 1] + 1;
distances[i][j] = north < west ? north : west;
}
}
}
return distances;
},
spliceOperationsFromEditDistances: function (distances) {
var i = distances.length - 1;
var j = distances[0].length - 1;
var current = distances[i][j];
var edits = [];
while (i > 0 || j > 0) {
if (i == 0) {
edits.push(EDIT_ADD);
j--;
continue;
}
if (j == 0) {
edits.push(EDIT_DELETE);
i--;
continue;
}
var northWest = distances[i - 1][j - 1];
var west = distances[i - 1][j];
var north = distances[i][j - 1];
var min;
if (west < north)
min = west < northWest ? west : northWest;
else
min = north < northWest ? north : northWest;
if (min == northWest) {
if (northWest == current) {
edits.push(EDIT_LEAVE);
} else {
edits.push(EDIT_UPDATE);
current = northWest;
}
i--;
j--;
} else if (min == west) {
edits.push(EDIT_DELETE);
i--;
current = west;
} else {
edits.push(EDIT_ADD);
j--;
current = north;
}
}
edits.reverse();
return edits;
},
calcSplices: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
var prefixCount = 0;
var suffixCount = 0;
var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
if (currentStart == 0 && oldStart == 0)
prefixCount = this.sharedPrefix(current, old, minLength);
if (currentEnd == current.length && oldEnd == old.length)
suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);
currentStart += prefixCount;
oldStart += prefixCount;
currentEnd -= suffixCount;
oldEnd -= suffixCount;
if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
return [];
if (currentStart == currentEnd) {
var splice = newSplice(currentStart, [], 0);
while (oldStart < oldEnd)
splice.removed.push(old[oldStart++]);
return [splice];
} else if (oldStart == oldEnd)
return [newSplice(currentStart, [], currentEnd - currentStart)];
var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
splice = undefined;
var splices = [];
var index = currentStart;
var oldIndex = oldStart;
for (var i = 0; i < ops.length; i++) {
switch (ops[i]) {
case EDIT_LEAVE:
if (splice) {
splices.push(splice);
splice = undefined;
}
index++;
oldIndex++;
break;
case EDIT_UPDATE:
if (!splice)
splice = newSplice(index, [], 0);
splice.addedCount++;
index++;
splice.removed.push(old[oldIndex]);
oldIndex++;
break;
case EDIT_ADD:
if (!splice)
splice = newSplice(index, [], 0);
splice.addedCount++;
index++;
break;
case EDIT_DELETE:
if (!splice)
splice = newSplice(index, [], 0);
splice.removed.push(old[oldIndex]);
oldIndex++;
break;
}
}
if (splice) {
splices.push(splice);
}
return splices;
},
sharedPrefix: function (current, old, searchLength) {
for (var i = 0; i < searchLength; i++)
if (!this.equals(current[i], old[i]))
return i;
return searchLength;
},
sharedSuffix: function (current, old, searchLength) {
var index1 = current.length;
var index2 = old.length;
var count = 0;
while (count < searchLength && this.equals(current[--index1], old[--index2]))
count++;
return count;
},
calculateSplices: function (current, previous) {
return this.calcSplices(current, 0, current.length, previous, 0, previous.length);
},
equals: function (currentValue, previousValue) {
return currentValue === previousValue;
}
};
return new ArraySplice();
}();
Polymer.domInnerHTML = function () {
var escapeAttrRegExp = /[&\u00A0"]/g;
var escapeDataRegExp = /[&\u00A0<>]/g;
function escapeReplace(c) {
switch (c) {
case '&':
return '&amp;';
case '<':
return '&lt;';
case '>':
return '&gt;';
case '"':
return '&quot;';
case '\xA0':
return '&nbsp;';
}
}
function escapeAttr(s) {
return s.replace(escapeAttrRegExp, escapeReplace);
}
function escapeData(s) {
return s.replace(escapeDataRegExp, escapeReplace);
}
function makeSet(arr) {
var set = {};
for (var i = 0; i < arr.length; i++) {
set[arr[i]] = true;
}
return set;
}
var voidElements = makeSet([
'area',
'base',
'br',
'col',
'command',
'embed',
'hr',
'img',
'input',
'keygen',
'link',
'meta',
'param',
'source',
'track',
'wbr'
]);
var plaintextParents = makeSet([
'style',
'script',
'xmp',
'iframe',
'noembed',
'noframes',
'plaintext',
'noscript'
]);
function getOuterHTML(node, parentNode, composed) {
switch (node.nodeType) {
case Node.ELEMENT_NODE:
var tagName = node.localName;
var s = '<' + tagName;
var attrs = node.attributes;
for (var i = 0, attr; attr = attrs[i]; i++) {
s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
}
s += '>';
if (voidElements[tagName]) {
return s;
}
return s + getInnerHTML(node, composed) + '</' + tagName + '>';
case Node.TEXT_NODE:
var data = node.data;
if (parentNode && plaintextParents[parentNode.localName]) {
return data;
}
return escapeData(data);
case Node.COMMENT_NODE:
return '<!--' + node.data + '-->';
default:
console.error(node);
throw new Error('not implemented');
}
}
function getInnerHTML(node, composed) {
if (node instanceof HTMLTemplateElement)
node = node.content;
var s = '';
var c$ = Polymer.dom(node).childNodes;
for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {
s += getOuterHTML(child, node, composed);
}
return s;
}
return { getInnerHTML: getInnerHTML };
}();
(function () {
'use strict';
var nativeInsertBefore = Element.prototype.insertBefore;
var nativeAppendChild = Element.prototype.appendChild;
var nativeRemoveChild = Element.prototype.removeChild;
Polymer.TreeApi = {
arrayCopyChildNodes: function (parent) {
var copy = [], i = 0;
for (var n = parent.firstChild; n; n = n.nextSibling) {
copy[i++] = n;
}
return copy;
},
arrayCopyChildren: function (parent) {
var copy = [], i = 0;
for (var n = parent.firstElementChild; n; n = n.nextElementSibling) {
copy[i++] = n;
}
return copy;
},
arrayCopy: function (a$) {
var l = a$.length;
var copy = new Array(l);
for (var i = 0; i < l; i++) {
copy[i] = a$[i];
}
return copy;
}
};
Polymer.TreeApi.Logical = {
hasParentNode: function (node) {
return Boolean(node.__dom && node.__dom.parentNode);
},
hasChildNodes: function (node) {
return Boolean(node.__dom && node.__dom.childNodes !== undefined);
},
getChildNodes: function (node) {
return this.hasChildNodes(node) ? this._getChildNodes(node) : node.childNodes;
},
_getChildNodes: function (node) {
if (!node.__dom.childNodes) {
node.__dom.childNodes = [];
for (var n = node.__dom.firstChild; n; n = n.__dom.nextSibling) {
node.__dom.childNodes.push(n);
}
}
return node.__dom.childNodes;
},
getParentNode: function (node) {
return node.__dom && node.__dom.parentNode !== undefined ? node.__dom.parentNode : node.parentNode;
},
getFirstChild: function (node) {
return node.__dom && node.__dom.firstChild !== undefined ? node.__dom.firstChild : node.firstChild;
},
getLastChild: function (node) {
return node.__dom && node.__dom.lastChild !== undefined ? node.__dom.lastChild : node.lastChild;
},
getNextSibling: function (node) {
return node.__dom && node.__dom.nextSibling !== undefined ? node.__dom.nextSibling : node.nextSibling;
},
getPreviousSibling: function (node) {
return node.__dom && node.__dom.previousSibling !== undefined ? node.__dom.previousSibling : node.previousSibling;
},
getFirstElementChild: function (node) {
return node.__dom && node.__dom.firstChild !== undefined ? this._getFirstElementChild(node) : node.firstElementChild;
},
_getFirstElementChild: function (node) {
var n = node.__dom.firstChild;
while (n && n.nodeType !== Node.ELEMENT_NODE) {
n = n.__dom.nextSibling;
}
return n;
},
getLastElementChild: function (node) {
return node.__dom && node.__dom.lastChild !== undefined ? this._getLastElementChild(node) : node.lastElementChild;
},
_getLastElementChild: function (node) {
var n = node.__dom.lastChild;
while (n && n.nodeType !== Node.ELEMENT_NODE) {
n = n.__dom.previousSibling;
}
return n;
},
getNextElementSibling: function (node) {
return node.__dom && node.__dom.nextSibling !== undefined ? this._getNextElementSibling(node) : node.nextElementSibling;
},
_getNextElementSibling: function (node) {
var n = node.__dom.nextSibling;
while (n && n.nodeType !== Node.ELEMENT_NODE) {
n = n.__dom.nextSibling;
}
return n;
},
getPreviousElementSibling: function (node) {
return node.__dom && node.__dom.previousSibling !== undefined ? this._getPreviousElementSibling(node) : node.previousElementSibling;
},
_getPreviousElementSibling: function (node) {
var n = node.__dom.previousSibling;
while (n && n.nodeType !== Node.ELEMENT_NODE) {
n = n.__dom.previousSibling;
}
return n;
},
saveChildNodes: function (node) {
if (!this.hasChildNodes(node)) {
node.__dom = node.__dom || {};
node.__dom.firstChild = node.firstChild;
node.__dom.lastChild = node.lastChild;
node.__dom.childNodes = [];
for (var n = node.firstChild; n; n = n.nextSibling) {
n.__dom = n.__dom || {};
n.__dom.parentNode = node;
node.__dom.childNodes.push(n);
n.__dom.nextSibling = n.nextSibling;
n.__dom.previousSibling = n.previousSibling;
}
}
},
recordInsertBefore: function (node, container, ref_node) {
container.__dom.childNodes = null;
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
for (var n = node.firstChild; n; n = n.nextSibling) {
this._linkNode(n, container, ref_node);
}
} else {
this._linkNode(node, container, ref_node);
}
},
_linkNode: function (node, container, ref_node) {
node.__dom = node.__dom || {};
container.__dom = container.__dom || {};
if (ref_node) {
ref_node.__dom = ref_node.__dom || {};
}
node.__dom.previousSibling = ref_node ? ref_node.__dom.previousSibling : container.__dom.lastChild;
if (node.__dom.previousSibling) {
node.__dom.previousSibling.__dom.nextSibling = node;
}
node.__dom.nextSibling = ref_node;
if (node.__dom.nextSibling) {
node.__dom.nextSibling.__dom.previousSibling = node;
}
node.__dom.parentNode = container;
if (ref_node) {
if (ref_node === container.__dom.firstChild) {
container.__dom.firstChild = node;
}
} else {
container.__dom.lastChild = node;
if (!container.__dom.firstChild) {
container.__dom.firstChild = node;
}
}
container.__dom.childNodes = null;
},
recordRemoveChild: function (node, container) {
node.__dom = node.__dom || {};
container.__dom = container.__dom || {};
if (node === container.__dom.firstChild) {
container.__dom.firstChild = node.__dom.nextSibling;
}
if (node === container.__dom.lastChild) {
container.__dom.lastChild = node.__dom.previousSibling;
}
var p = node.__dom.previousSibling;
var n = node.__dom.nextSibling;
if (p) {
p.__dom.nextSibling = n;
}
if (n) {
n.__dom.previousSibling = p;
}
node.__dom.parentNode = node.__dom.previousSibling = node.__dom.nextSibling = undefined;
container.__dom.childNodes = null;
}
};
Polymer.TreeApi.Composed = {
getChildNodes: function (node) {
return Polymer.TreeApi.arrayCopyChildNodes(node);
},
getParentNode: function (node) {
return node.parentNode;
},
clearChildNodes: function (node) {
node.textContent = '';
},
insertBefore: function (parentNode, newChild, refChild) {
return nativeInsertBefore.call(parentNode, newChild, refChild || null);
},
appendChild: function (parentNode, newChild) {
return nativeAppendChild.call(parentNode, newChild);
},
removeChild: function (parentNode, node) {
return nativeRemoveChild.call(parentNode, node);
}
};
}());
Polymer.DomApi = function () {
'use strict';
var Settings = Polymer.Settings;
var TreeApi = Polymer.TreeApi;
var DomApi = function (node) {
this.node = needsToWrap ? DomApi.wrap(node) : node;
};
var needsToWrap = Settings.hasShadow && !Settings.nativeShadow;
DomApi.wrap = window.wrap ? window.wrap : function (node) {
return node;
};
DomApi.prototype = {
flush: function () {
Polymer.dom.flush();
},
deepContains: function (node) {
if (this.node.contains(node)) {
return true;
}
var n = node;
var doc = node.ownerDocument;
while (n && n !== doc && n !== this.node) {
n = Polymer.dom(n).parentNode || n.host;
}
return n === this.node;
},
queryDistributedElements: function (selector) {
var c$ = this.getEffectiveChildNodes();
var list = [];
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.nodeType === Node.ELEMENT_NODE && DomApi.matchesSelector.call(c, selector)) {
list.push(c);
}
}
return list;
},
getEffectiveChildNodes: function () {
var list = [];
var c$ = this.childNodes;
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.localName === CONTENT) {
var d$ = dom(c).getDistributedNodes();
for (var j = 0; j < d$.length; j++) {
list.push(d$[j]);
}
} else {
list.push(c);
}
}
return list;
},
observeNodes: function (callback) {
if (callback) {
if (!this.observer) {
this.observer = this.node.localName === CONTENT ? new DomApi.DistributedNodesObserver(this) : new DomApi.EffectiveNodesObserver(this);
}
return this.observer.addListener(callback);
}
},
unobserveNodes: function (handle) {
if (this.observer) {
this.observer.removeListener(handle);
}
},
notifyObserver: function () {
if (this.observer) {
this.observer.notify();
}
},
_query: function (matcher, node, halter) {
node = node || this.node;
var list = [];
this._queryElements(TreeApi.Logical.getChildNodes(node), matcher, halter, list);
return list;
},
_queryElements: function (elements, matcher, halter, list) {
for (var i = 0, l = elements.length, c; i < l && (c = elements[i]); i++) {
if (c.nodeType === Node.ELEMENT_NODE) {
if (this._queryElement(c, matcher, halter, list)) {
return true;
}
}
}
},
_queryElement: function (node, matcher, halter, list) {
var result = matcher(node);
if (result) {
list.push(node);
}
if (halter && halter(result)) {
return result;
}
this._queryElements(TreeApi.Logical.getChildNodes(node), matcher, halter, list);
}
};
var CONTENT = DomApi.CONTENT = 'content';
var dom = DomApi.factory = function (node) {
node = node || document;
if (!node.__domApi) {
node.__domApi = new DomApi.ctor(node);
}
return node.__domApi;
};
DomApi.hasApi = function (node) {
return Boolean(node.__domApi);
};
DomApi.ctor = DomApi;
Polymer.dom = function (obj, patch) {
if (obj instanceof Event) {
return Polymer.EventApi.factory(obj);
} else {
return DomApi.factory(obj, patch);
}
};
var p = Element.prototype;
DomApi.matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;
return DomApi;
}();
(function () {
'use strict';
var Settings = Polymer.Settings;
var DomApi = Polymer.DomApi;
var dom = DomApi.factory;
var TreeApi = Polymer.TreeApi;
var getInnerHTML = Polymer.domInnerHTML.getInnerHTML;
var CONTENT = DomApi.CONTENT;
if (Settings.useShadow) {
return;
}
var nativeCloneNode = Element.prototype.cloneNode;
var nativeImportNode = Document.prototype.importNode;
Polymer.Base.extend(DomApi.prototype, {
_lazyDistribute: function (host) {
if (host.shadyRoot && host.shadyRoot._distributionClean) {
host.shadyRoot._distributionClean = false;
Polymer.dom.addDebouncer(host.debounce('_distribute', host._distributeContent));
}
},
appendChild: function (node) {
return this.insertBefore(node);
},
insertBefore: function (node, ref_node) {
if (ref_node && TreeApi.Logical.getParentNode(ref_node) !== this.node) {
throw Error('The ref_node to be inserted before is not a child ' + 'of this node');
}
if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
var parent = TreeApi.Logical.getParentNode(node);
if (parent) {
if (DomApi.hasApi(parent)) {
dom(parent).notifyObserver();
}
this._removeNode(node);
} else {
this._removeOwnerShadyRoot(node);
}
}
if (!this._addNode(node, ref_node)) {
if (ref_node) {
ref_node = ref_node.localName === CONTENT ? this._firstComposedNode(ref_node) : ref_node;
}
var container = this.node._isShadyRoot ? this.node.host : this.node;
if (ref_node) {
TreeApi.Composed.insertBefore(container, node, ref_node);
} else {
TreeApi.Composed.appendChild(container, node);
}
}
this.notifyObserver();
return node;
},
_addNode: function (node, ref_node) {
var root = this.getOwnerRoot();
if (root) {
var ipAdded = this._maybeAddInsertionPoint(node, this.node);
if (!root._invalidInsertionPoints) {
root._invalidInsertionPoints = ipAdded;
}
this._addNodeToHost(root.host, node);
}
if (TreeApi.Logical.hasChildNodes(this.node)) {
TreeApi.Logical.recordInsertBefore(node, this.node, ref_node);
}
var handled = this._maybeDistribute(node) || this.node.shadyRoot;
if (handled) {
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
while (node.firstChild) {
TreeApi.Composed.removeChild(node, node.firstChild);
}
} else {
var parent = TreeApi.Composed.getParentNode(node);
if (parent) {
TreeApi.Composed.removeChild(parent, node);
}
}
}
return handled;
},
removeChild: function (node) {
if (TreeApi.Logical.getParentNode(node) !== this.node) {
throw Error('The node to be removed is not a child of this node: ' + node);
}
if (!this._removeNode(node)) {
var container = this.node._isShadyRoot ? this.node.host : this.node;
var parent = TreeApi.Composed.getParentNode(node);
if (container === parent) {
TreeApi.Composed.removeChild(container, node);
}
}
this.notifyObserver();
return node;
},
_removeNode: function (node) {
var logicalParent = TreeApi.Logical.hasParentNode(node) && TreeApi.Logical.getParentNode(node);
var distributed;
var root = this._ownerShadyRootForNode(node);
if (logicalParent) {
distributed = dom(node)._maybeDistributeParent();
TreeApi.Logical.recordRemoveChild(node, logicalParent);
if (root && this._removeDistributedChildren(root, node)) {
root._invalidInsertionPoints = true;
this._lazyDistribute(root.host);
}
}
this._removeOwnerShadyRoot(node);
if (root) {
this._removeNodeFromHost(root.host, node);
}
return distributed;
},
replaceChild: function (node, ref_node) {
this.insertBefore(node, ref_node);
this.removeChild(ref_node);
return node;
},
_hasCachedOwnerRoot: function (node) {
return Boolean(node._ownerShadyRoot !== undefined);
},
getOwnerRoot: function () {
return this._ownerShadyRootForNode(this.node);
},
_ownerShadyRootForNode: function (node) {
if (!node) {
return;
}
var root = node._ownerShadyRoot;
if (root === undefined) {
if (node._isShadyRoot) {
root = node;
} else {
var parent = TreeApi.Logical.getParentNode(node);
if (parent) {
root = parent._isShadyRoot ? parent : this._ownerShadyRootForNode(parent);
} else {
root = null;
}
}
if (root || document.documentElement.contains(node)) {
node._ownerShadyRoot = root;
}
}
return root;
},
_maybeDistribute: function (node) {
var fragContent = node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent && dom(node).querySelector(CONTENT);
var wrappedContent = fragContent && TreeApi.Logical.getParentNode(fragContent).nodeType !== Node.DOCUMENT_FRAGMENT_NODE;
var hasContent = fragContent || node.localName === CONTENT;
if (hasContent) {
var root = this.getOwnerRoot();
if (root) {
this._lazyDistribute(root.host);
}
}
var needsDist = this._nodeNeedsDistribution(this.node);
if (needsDist) {
this._lazyDistribute(this.node);
}
return needsDist || hasContent && !wrappedContent;
},
_maybeAddInsertionPoint: function (node, parent) {
var added;
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent) {
var c$ = dom(node).querySelectorAll(CONTENT);
for (var i = 0, n, np, na; i < c$.length && (n = c$[i]); i++) {
np = TreeApi.Logical.getParentNode(n);
if (np === node) {
np = parent;
}
na = this._maybeAddInsertionPoint(n, np);
added = added || na;
}
} else if (node.localName === CONTENT) {
TreeApi.Logical.saveChildNodes(parent);
TreeApi.Logical.saveChildNodes(node);
added = true;
}
return added;
},
_updateInsertionPoints: function (host) {
var i$ = host.shadyRoot._insertionPoints = dom(host.shadyRoot).querySelectorAll(CONTENT);
for (var i = 0, c; i < i$.length; i++) {
c = i$[i];
TreeApi.Logical.saveChildNodes(c);
TreeApi.Logical.saveChildNodes(TreeApi.Logical.getParentNode(c));
}
},
_nodeNeedsDistribution: function (node) {
return node && node.shadyRoot && DomApi.hasInsertionPoint(node.shadyRoot);
},
_addNodeToHost: function (host, node) {
if (host._elementAdd) {
host._elementAdd(node);
}
},
_removeNodeFromHost: function (host, node) {
if (host._elementRemove) {
host._elementRemove(node);
}
},
_removeDistributedChildren: function (root, container) {
var hostNeedsDist;
var ip$ = root._insertionPoints;
for (var i = 0; i < ip$.length; i++) {
var content = ip$[i];
if (this._contains(container, content)) {
var dc$ = dom(content).getDistributedNodes();
for (var j = 0; j < dc$.length; j++) {
hostNeedsDist = true;
var node = dc$[j];
var parent = TreeApi.Composed.getParentNode(node);
if (parent) {
TreeApi.Composed.removeChild(parent, node);
}
}
}
}
return hostNeedsDist;
},
_contains: function (container, node) {
while (node) {
if (node == container) {
return true;
}
node = TreeApi.Logical.getParentNode(node);
}
},
_removeOwnerShadyRoot: function (node) {
if (this._hasCachedOwnerRoot(node)) {
var c$ = TreeApi.Logical.getChildNodes(node);
for (var i = 0, l = c$.length, n; i < l && (n = c$[i]); i++) {
this._removeOwnerShadyRoot(n);
}
}
node._ownerShadyRoot = undefined;
},
_firstComposedNode: function (content) {
var n$ = dom(content).getDistributedNodes();
for (var i = 0, l = n$.length, n, p$; i < l && (n = n$[i]); i++) {
p$ = dom(n).getDestinationInsertionPoints();
if (p$[p$.length - 1] === content) {
return n;
}
}
},
querySelector: function (selector) {
var result = this._query(function (n) {
return DomApi.matchesSelector.call(n, selector);
}, this.node, function (n) {
return Boolean(n);
})[0];
return result || null;
},
querySelectorAll: function (selector) {
return this._query(function (n) {
return DomApi.matchesSelector.call(n, selector);
}, this.node);
},
getDestinationInsertionPoints: function () {
return this.node._destinationInsertionPoints || [];
},
getDistributedNodes: function () {
return this.node._distributedNodes || [];
},
_clear: function () {
while (this.childNodes.length) {
this.removeChild(this.childNodes[0]);
}
},
setAttribute: function (name, value) {
this.node.setAttribute(name, value);
this._maybeDistributeParent();
},
removeAttribute: function (name) {
this.node.removeAttribute(name);
this._maybeDistributeParent();
},
_maybeDistributeParent: function () {
if (this._nodeNeedsDistribution(this.parentNode)) {
this._lazyDistribute(this.parentNode);
return true;
}
},
cloneNode: function (deep) {
var n = nativeCloneNode.call(this.node, false);
if (deep) {
var c$ = this.childNodes;
var d = dom(n);
for (var i = 0, nc; i < c$.length; i++) {
nc = dom(c$[i]).cloneNode(true);
d.appendChild(nc);
}
}
return n;
},
importNode: function (externalNode, deep) {
var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
var n = nativeImportNode.call(doc, externalNode, false);
if (deep) {
var c$ = TreeApi.Logical.getChildNodes(externalNode);
var d = dom(n);
for (var i = 0, nc; i < c$.length; i++) {
nc = dom(doc).importNode(c$[i], true);
d.appendChild(nc);
}
}
return n;
},
_getComposedInnerHTML: function () {
return getInnerHTML(this.node, true);
}
});
Object.defineProperties(DomApi.prototype, {
activeElement: {
get: function () {
var active = document.activeElement;
if (!active) {
return null;
}
var isShadyRoot = !!this.node._isShadyRoot;
if (this.node !== document) {
if (!isShadyRoot) {
return null;
}
if (this.node.host === active || !this.node.host.contains(active)) {
return null;
}
}
var activeRoot = dom(active).getOwnerRoot();
while (activeRoot && activeRoot !== this.node) {
active = activeRoot.host;
activeRoot = dom(active).getOwnerRoot();
}
if (this.node === document) {
return activeRoot ? null : active;
} else {
return activeRoot === this.node ? active : null;
}
},
configurable: true
},
childNodes: {
get: function () {
var c$ = TreeApi.Logical.getChildNodes(this.node);
return Array.isArray(c$) ? c$ : TreeApi.arrayCopyChildNodes(this.node);
},
configurable: true
},
children: {
get: function () {
if (TreeApi.Logical.hasChildNodes(this.node)) {
return Array.prototype.filter.call(this.childNodes, function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
} else {
return TreeApi.arrayCopyChildren(this.node);
}
},
configurable: true
},
parentNode: {
get: function () {
return TreeApi.Logical.getParentNode(this.node);
},
configurable: true
},
firstChild: {
get: function () {
return TreeApi.Logical.getFirstChild(this.node);
},
configurable: true
},
lastChild: {
get: function () {
return TreeApi.Logical.getLastChild(this.node);
},
configurable: true
},
nextSibling: {
get: function () {
return TreeApi.Logical.getNextSibling(this.node);
},
configurable: true
},
previousSibling: {
get: function () {
return TreeApi.Logical.getPreviousSibling(this.node);
},
configurable: true
},
firstElementChild: {
get: function () {
return TreeApi.Logical.getFirstElementChild(this.node);
},
configurable: true
},
lastElementChild: {
get: function () {
return TreeApi.Logical.getLastElementChild(this.node);
},
configurable: true
},
nextElementSibling: {
get: function () {
return TreeApi.Logical.getNextElementSibling(this.node);
},
configurable: true
},
previousElementSibling: {
get: function () {
return TreeApi.Logical.getPreviousElementSibling(this.node);
},
configurable: true
},
textContent: {
get: function () {
var nt = this.node.nodeType;
if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
return this.node.textContent;
} else {
var tc = [];
for (var i = 0, cn = this.childNodes, c; c = cn[i]; i++) {
if (c.nodeType !== Node.COMMENT_NODE) {
tc.push(c.textContent);
}
}
return tc.join('');
}
},
set: function (text) {
var nt = this.node.nodeType;
if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
this.node.textContent = text;
} else {
this._clear();
if (text) {
this.appendChild(document.createTextNode(text));
}
}
},
configurable: true
},
innerHTML: {
get: function () {
var nt = this.node.nodeType;
if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
return null;
} else {
return getInnerHTML(this.node);
}
},
set: function (text) {
var nt = this.node.nodeType;
if (nt !== Node.TEXT_NODE || nt !== Node.COMMENT_NODE) {
this._clear();
var d = document.createElement('div');
d.innerHTML = text;
var c$ = TreeApi.arrayCopyChildNodes(d);
for (var i = 0; i < c$.length; i++) {
this.appendChild(c$[i]);
}
}
},
configurable: true
}
});
DomApi.hasInsertionPoint = function (root) {
return Boolean(root && root._insertionPoints.length);
};
}());
(function () {
'use strict';
var Settings = Polymer.Settings;
var TreeApi = Polymer.TreeApi;
var DomApi = Polymer.DomApi;
if (!Settings.useShadow) {
return;
}
Polymer.Base.extend(DomApi.prototype, {
querySelectorAll: function (selector) {
return TreeApi.arrayCopy(this.node.querySelectorAll(selector));
},
getOwnerRoot: function () {
var n = this.node;
while (n) {
if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n.host) {
return n;
}
n = n.parentNode;
}
},
importNode: function (externalNode, deep) {
var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
return doc.importNode(externalNode, deep);
},
getDestinationInsertionPoints: function () {
var n$ = this.node.getDestinationInsertionPoints && this.node.getDestinationInsertionPoints();
return n$ ? TreeApi.arrayCopy(n$) : [];
},
getDistributedNodes: function () {
var n$ = this.node.getDistributedNodes && this.node.getDistributedNodes();
return n$ ? TreeApi.arrayCopy(n$) : [];
}
});
Object.defineProperties(DomApi.prototype, {
activeElement: {
get: function () {
var node = DomApi.wrap(this.node);
var activeElement = node.activeElement;
return node.contains(activeElement) ? activeElement : null;
},
configurable: true
},
childNodes: {
get: function () {
return TreeApi.arrayCopyChildNodes(this.node);
},
configurable: true
},
children: {
get: function () {
return TreeApi.arrayCopyChildren(this.node);
},
configurable: true
},
textContent: {
get: function () {
return this.node.textContent;
},
set: function (value) {
return this.node.textContent = value;
},
configurable: true
},
innerHTML: {
get: function () {
return this.node.innerHTML;
},
set: function (value) {
return this.node.innerHTML = value;
},
configurable: true
}
});
var forwardMethods = function (m$) {
for (var i = 0; i < m$.length; i++) {
forwardMethod(m$[i]);
}
};
var forwardMethod = function (method) {
DomApi.prototype[method] = function () {
return this.node[method].apply(this.node, arguments);
};
};
forwardMethods([
'cloneNode',
'appendChild',
'insertBefore',
'removeChild',
'replaceChild',
'setAttribute',
'removeAttribute',
'querySelector'
]);
var forwardProperties = function (f$) {
for (var i = 0; i < f$.length; i++) {
forwardProperty(f$[i]);
}
};
var forwardProperty = function (name) {
Object.defineProperty(DomApi.prototype, name, {
get: function () {
return this.node[name];
},
configurable: true
});
};
forwardProperties([
'parentNode',
'firstChild',
'lastChild',
'nextSibling',
'previousSibling',
'firstElementChild',
'lastElementChild',
'nextElementSibling',
'previousElementSibling'
]);
}());
Polymer.Base.extend(Polymer.dom, {
_flushGuard: 0,
_FLUSH_MAX: 100,
_needsTakeRecords: !Polymer.Settings.useNativeCustomElements,
_debouncers: [],
_staticFlushList: [],
_finishDebouncer: null,
flush: function () {
this._flushGuard = 0;
this._prepareFlush();
while (this._debouncers.length && this._flushGuard < this._FLUSH_MAX) {
while (this._debouncers.length) {
this._debouncers.shift().complete();
}
if (this._finishDebouncer) {
this._finishDebouncer.complete();
}
this._prepareFlush();
this._flushGuard++;
}
if (this._flushGuard >= this._FLUSH_MAX) {
console.warn('Polymer.dom.flush aborted. Flush may not be complete.');
}
},
_prepareFlush: function () {
if (this._needsTakeRecords) {
CustomElements.takeRecords();
}
for (var i = 0; i < this._staticFlushList.length; i++) {
this._staticFlushList[i]();
}
},
addStaticFlush: function (fn) {
this._staticFlushList.push(fn);
},
removeStaticFlush: function (fn) {
var i = this._staticFlushList.indexOf(fn);
if (i >= 0) {
this._staticFlushList.splice(i, 1);
}
},
addDebouncer: function (debouncer) {
this._debouncers.push(debouncer);
this._finishDebouncer = Polymer.Debounce(this._finishDebouncer, this._finishFlush);
},
_finishFlush: function () {
Polymer.dom._debouncers = [];
}
});
Polymer.EventApi = function () {
'use strict';
var DomApi = Polymer.DomApi.ctor;
var Settings = Polymer.Settings;
DomApi.Event = function (event) {
this.event = event;
};
if (Settings.useShadow) {
DomApi.Event.prototype = {
get rootTarget() {
return this.event.path[0];
},
get localTarget() {
return this.event.target;
},
get path() {
var path = this.event.path;
if (!Array.isArray(path)) {
path = Array.prototype.slice.call(path);
}
return path;
}
};
} else {
DomApi.Event.prototype = {
get rootTarget() {
return this.event.target;
},
get localTarget() {
var current = this.event.currentTarget;
var currentRoot = current && Polymer.dom(current).getOwnerRoot();
var p$ = this.path;
for (var i = 0; i < p$.length; i++) {
if (Polymer.dom(p$[i]).getOwnerRoot() === currentRoot) {
return p$[i];
}
}
},
get path() {
if (!this.event._path) {
var path = [];
var current = this.rootTarget;
while (current) {
path.push(current);
var insertionPoints = Polymer.dom(current).getDestinationInsertionPoints();
if (insertionPoints.length) {
for (var i = 0; i < insertionPoints.length - 1; i++) {
path.push(insertionPoints[i]);
}
current = insertionPoints[insertionPoints.length - 1];
} else {
current = Polymer.dom(current).parentNode || current.host;
}
}
path.push(window);
this.event._path = path;
}
return this.event._path;
}
};
}
var factory = function (event) {
if (!event.__eventApi) {
event.__eventApi = new DomApi.Event(event);
}
return event.__eventApi;
};
return { factory: factory };
}();
(function () {
'use strict';
var DomApi = Polymer.DomApi.ctor;
var useShadow = Polymer.Settings.useShadow;
Object.defineProperty(DomApi.prototype, 'classList', {
get: function () {
if (!this._classList) {
this._classList = new DomApi.ClassList(this);
}
return this._classList;
},
configurable: true
});
DomApi.ClassList = function (host) {
this.domApi = host;
this.node = host.node;
};
DomApi.ClassList.prototype = {
add: function () {
this.node.classList.add.apply(this.node.classList, arguments);
this._distributeParent();
},
remove: function () {
this.node.classList.remove.apply(this.node.classList, arguments);
this._distributeParent();
},
toggle: function () {
this.node.classList.toggle.apply(this.node.classList, arguments);
this._distributeParent();
},
_distributeParent: function () {
if (!useShadow) {
this.domApi._maybeDistributeParent();
}
},
contains: function () {
return this.node.classList.contains.apply(this.node.classList, arguments);
}
};
}());
(function () {
'use strict';
var DomApi = Polymer.DomApi.ctor;
var Settings = Polymer.Settings;
DomApi.EffectiveNodesObserver = function (domApi) {
this.domApi = domApi;
this.node = this.domApi.node;
this._listeners = [];
};
DomApi.EffectiveNodesObserver.prototype = {
addListener: function (callback) {
if (!this._isSetup) {
this._setup();
this._isSetup = true;
}
var listener = {
fn: callback,
_nodes: []
};
this._listeners.push(listener);
this._scheduleNotify();
return listener;
},
removeListener: function (handle) {
var i = this._listeners.indexOf(handle);
if (i >= 0) {
this._listeners.splice(i, 1);
handle._nodes = [];
}
if (!this._hasListeners()) {
this._cleanup();
this._isSetup = false;
}
},
_setup: function () {
this._observeContentElements(this.domApi.childNodes);
},
_cleanup: function () {
this._unobserveContentElements(this.domApi.childNodes);
},
_hasListeners: function () {
return Boolean(this._listeners.length);
},
_scheduleNotify: function () {
if (this._debouncer) {
this._debouncer.stop();
}
this._debouncer = Polymer.Debounce(this._debouncer, this._notify);
this._debouncer.context = this;
Polymer.dom.addDebouncer(this._debouncer);
},
notify: function () {
if (this._hasListeners()) {
this._scheduleNotify();
}
},
_notify: function () {
this._beforeCallListeners();
this._callListeners();
},
_beforeCallListeners: function () {
this._updateContentElements();
},
_updateContentElements: function () {
this._observeContentElements(this.domApi.childNodes);
},
_observeContentElements: function (elements) {
for (var i = 0, n; i < elements.length && (n = elements[i]); i++) {
if (this._isContent(n)) {
n.__observeNodesMap = n.__observeNodesMap || new WeakMap();
if (!n.__observeNodesMap.has(this)) {
n.__observeNodesMap.set(this, this._observeContent(n));
}
}
}
},
_observeContent: function (content) {
var self = this;
var h = Polymer.dom(content).observeNodes(function () {
self._scheduleNotify();
});
h._avoidChangeCalculation = true;
return h;
},
_unobserveContentElements: function (elements) {
for (var i = 0, n, h; i < elements.length && (n = elements[i]); i++) {
if (this._isContent(n)) {
h = n.__observeNodesMap.get(this);
if (h) {
Polymer.dom(n).unobserveNodes(h);
n.__observeNodesMap.delete(this);
}
}
}
},
_isContent: function (node) {
return node.localName === 'content';
},
_callListeners: function () {
var o$ = this._listeners;
var nodes = this._getEffectiveNodes();
for (var i = 0, o; i < o$.length && (o = o$[i]); i++) {
var info = this._generateListenerInfo(o, nodes);
if (info || o._alwaysNotify) {
this._callListener(o, info);
}
}
},
_getEffectiveNodes: function () {
return this.domApi.getEffectiveChildNodes();
},
_generateListenerInfo: function (listener, newNodes) {
if (listener._avoidChangeCalculation) {
return true;
}
var oldNodes = listener._nodes;
var info = {
target: this.node,
addedNodes: [],
removedNodes: []
};
var splices = Polymer.ArraySplice.calculateSplices(newNodes, oldNodes);
for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
info.removedNodes.push(n);
}
}
for (i = 0, s; i < splices.length && (s = splices[i]); i++) {
for (j = s.index; j < s.index + s.addedCount; j++) {
info.addedNodes.push(newNodes[j]);
}
}
listener._nodes = newNodes;
if (info.addedNodes.length || info.removedNodes.length) {
return info;
}
},
_callListener: function (listener, info) {
return listener.fn.call(this.node, info);
},
enableShadowAttributeTracking: function () {
}
};
if (Settings.useShadow) {
var baseSetup = DomApi.EffectiveNodesObserver.prototype._setup;
var baseCleanup = DomApi.EffectiveNodesObserver.prototype._cleanup;
Polymer.Base.extend(DomApi.EffectiveNodesObserver.prototype, {
_setup: function () {
if (!this._observer) {
var self = this;
this._mutationHandler = function (mxns) {
if (mxns && mxns.length) {
self._scheduleNotify();
}
};
this._observer = new MutationObserver(this._mutationHandler);
this._boundFlush = function () {
self._flush();
};
Polymer.dom.addStaticFlush(this._boundFlush);
this._observer.observe(this.node, { childList: true });
}
baseSetup.call(this);
},
_cleanup: function () {
this._observer.disconnect();
this._observer = null;
this._mutationHandler = null;
Polymer.dom.removeStaticFlush(this._boundFlush);
baseCleanup.call(this);
},
_flush: function () {
if (this._observer) {
this._mutationHandler(this._observer.takeRecords());
}
},
enableShadowAttributeTracking: function () {
if (this._observer) {
this._makeContentListenersAlwaysNotify();
this._observer.disconnect();
this._observer.observe(this.node, {
childList: true,
attributes: true,
subtree: true
});
var root = this.domApi.getOwnerRoot();
var host = root && root.host;
if (host && Polymer.dom(host).observer) {
Polymer.dom(host).observer.enableShadowAttributeTracking();
}
}
},
_makeContentListenersAlwaysNotify: function () {
for (var i = 0, h; i < this._listeners.length; i++) {
h = this._listeners[i];
h._alwaysNotify = h._isContentListener;
}
}
});
}
}());
(function () {
'use strict';
var DomApi = Polymer.DomApi.ctor;
var Settings = Polymer.Settings;
DomApi.DistributedNodesObserver = function (domApi) {
DomApi.EffectiveNodesObserver.call(this, domApi);
};
DomApi.DistributedNodesObserver.prototype = Object.create(DomApi.EffectiveNodesObserver.prototype);
Polymer.Base.extend(DomApi.DistributedNodesObserver.prototype, {
_setup: function () {
},
_cleanup: function () {
},
_beforeCallListeners: function () {
},
_getEffectiveNodes: function () {
return this.domApi.getDistributedNodes();
}
});
if (Settings.useShadow) {
Polymer.Base.extend(DomApi.DistributedNodesObserver.prototype, {
_setup: function () {
if (!this._observer) {
var root = this.domApi.getOwnerRoot();
var host = root && root.host;
if (host) {
var self = this;
this._observer = Polymer.dom(host).observeNodes(function () {
self._scheduleNotify();
});
this._observer._isContentListener = true;
if (this._hasAttrSelect()) {
Polymer.dom(host).observer.enableShadowAttributeTracking();
}
}
}
},
_hasAttrSelect: function () {
var select = this.node.getAttribute('select');
return select && select.match(/[[.]+/);
},
_cleanup: function () {
var root = this.domApi.getOwnerRoot();
var host = root && root.host;
if (host) {
Polymer.dom(host).unobserveNodes(this._observer);
}
this._observer = null;
}
});
}
}());
(function () {
var DomApi = Polymer.DomApi;
var TreeApi = Polymer.TreeApi;
Polymer.Base._addFeature({
_prepShady: function () {
this._useContent = this._useContent || Boolean(this._template);
},
_setupShady: function () {
this.shadyRoot = null;
if (!this.__domApi) {
this.__domApi = null;
}
if (!this.__dom) {
this.__dom = null;
}
if (!this._ownerShadyRoot) {
this._ownerShadyRoot = undefined;
}
},
_poolContent: function () {
if (this._useContent) {
TreeApi.Logical.saveChildNodes(this);
}
},
_setupRoot: function () {
if (this._useContent) {
this._createLocalRoot();
if (!this.dataHost) {
upgradeLogicalChildren(TreeApi.Logical.getChildNodes(this));
}
}
},
_createLocalRoot: function () {
this.shadyRoot = this.root;
this.shadyRoot._distributionClean = false;
this.shadyRoot._hasDistributed = false;
this.shadyRoot._isShadyRoot = true;
this.shadyRoot._dirtyRoots = [];
var i$ = this.shadyRoot._insertionPoints = !this._notes || this._notes._hasContent ? this.shadyRoot.querySelectorAll('content') : [];
TreeApi.Logical.saveChildNodes(this.shadyRoot);
for (var i = 0, c; i < i$.length; i++) {
c = i$[i];
TreeApi.Logical.saveChildNodes(c);
TreeApi.Logical.saveChildNodes(c.parentNode);
}
this.shadyRoot.host = this;
},
get domHost() {
var root = Polymer.dom(this).getOwnerRoot();
return root && root.host;
},
distributeContent: function (updateInsertionPoints) {
if (this.shadyRoot) {
this.shadyRoot._invalidInsertionPoints = this.shadyRoot._invalidInsertionPoints || updateInsertionPoints;
var host = getTopDistributingHost(this);
Polymer.dom(this)._lazyDistribute(host);
}
},
_distributeContent: function () {
if (this._useContent && !this.shadyRoot._distributionClean) {
if (this.shadyRoot._invalidInsertionPoints) {
Polymer.dom(this)._updateInsertionPoints(this);
this.shadyRoot._invalidInsertionPoints = false;
}
this._beginDistribute();
this._distributeDirtyRoots();
this._finishDistribute();
}
},
_beginDistribute: function () {
if (this._useContent && DomApi.hasInsertionPoint(this.shadyRoot)) {
this._resetDistribution();
this._distributePool(this.shadyRoot, this._collectPool());
}
},
_distributeDirtyRoots: function () {
var c$ = this.shadyRoot._dirtyRoots;
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
c._distributeContent();
}
this.shadyRoot._dirtyRoots = [];
},
_finishDistribute: function () {
if (this._useContent) {
this.shadyRoot._distributionClean = true;
if (DomApi.hasInsertionPoint(this.shadyRoot)) {
this._composeTree();
notifyContentObservers(this.shadyRoot);
} else {
if (!this.shadyRoot._hasDistributed) {
TreeApi.Composed.clearChildNodes(this);
this.appendChild(this.shadyRoot);
} else {
var children = this._composeNode(this);
this._updateChildNodes(this, children);
}
}
if (!this.shadyRoot._hasDistributed) {
notifyInitialDistribution(this);
}
this.shadyRoot._hasDistributed = true;
}
},
elementMatches: function (selector, node) {
node = node || this;
return DomApi.matchesSelector.call(node, selector);
},
_resetDistribution: function () {
var children = TreeApi.Logical.getChildNodes(this);
for (var i = 0; i < children.length; i++) {
var child = children[i];
if (child._destinationInsertionPoints) {
child._destinationInsertionPoints = undefined;
}
if (isInsertionPoint(child)) {
clearDistributedDestinationInsertionPoints(child);
}
}
var root = this.shadyRoot;
var p$ = root._insertionPoints;
for (var j = 0; j < p$.length; j++) {
p$[j]._distributedNodes = [];
}
},
_collectPool: function () {
var pool = [];
var children = TreeApi.Logical.getChildNodes(this);
for (var i = 0; i < children.length; i++) {
var child = children[i];
if (isInsertionPoint(child)) {
pool.push.apply(pool, child._distributedNodes);
} else {
pool.push(child);
}
}
return pool;
},
_distributePool: function (node, pool) {
var p$ = node._insertionPoints;
for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
this._distributeInsertionPoint(p, pool);
maybeRedistributeParent(p, this);
}
},
_distributeInsertionPoint: function (content, pool) {
var anyDistributed = false;
for (var i = 0, l = pool.length, node; i < l; i++) {
node = pool[i];
if (!node) {
continue;
}
if (this._matchesContentSelect(node, content)) {
distributeNodeInto(node, content);
pool[i] = undefined;
anyDistributed = true;
}
}
if (!anyDistributed) {
var children = TreeApi.Logical.getChildNodes(content);
for (var j = 0; j < children.length; j++) {
distributeNodeInto(children[j], content);
}
}
},
_composeTree: function () {
this._updateChildNodes(this, this._composeNode(this));
var p$ = this.shadyRoot._insertionPoints;
for (var i = 0, l = p$.length, p, parent; i < l && (p = p$[i]); i++) {
parent = TreeApi.Logical.getParentNode(p);
if (!parent._useContent && parent !== this && parent !== this.shadyRoot) {
this._updateChildNodes(parent, this._composeNode(parent));
}
}
},
_composeNode: function (node) {
var children = [];
var c$ = TreeApi.Logical.getChildNodes(node.shadyRoot || node);
for (var i = 0; i < c$.length; i++) {
var child = c$[i];
if (isInsertionPoint(child)) {
var distributedNodes = child._distributedNodes;
for (var j = 0; j < distributedNodes.length; j++) {
var distributedNode = distributedNodes[j];
if (isFinalDestination(child, distributedNode)) {
children.push(distributedNode);
}
}
} else {
children.push(child);
}
}
return children;
},
_updateChildNodes: function (container, children) {
var composed = TreeApi.Composed.getChildNodes(container);
var splices = Polymer.ArraySplice.calculateSplices(children, composed);
for (var i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
if (TreeApi.Composed.getParentNode(n) === container) {
TreeApi.Composed.removeChild(container, n);
}
composed.splice(s.index + d, 1);
}
d -= s.addedCount;
}
for (var i = 0, s, next; i < splices.length && (s = splices[i]); i++) {
next = composed[s.index];
for (j = s.index, n; j < s.index + s.addedCount; j++) {
n = children[j];
TreeApi.Composed.insertBefore(container, n, next);
composed.splice(j, 0, n);
}
}
},
_matchesContentSelect: function (node, contentElement) {
var select = contentElement.getAttribute('select');
if (!select) {
return true;
}
select = select.trim();
if (!select) {
return true;
}
if (!(node instanceof Element)) {
return false;
}
var validSelectors = /^(:not\()?[*.#[a-zA-Z_|]/;
if (!validSelectors.test(select)) {
return false;
}
return this.elementMatches(select, node);
},
_elementAdd: function () {
},
_elementRemove: function () {
}
});
function distributeNodeInto(child, insertionPoint) {
insertionPoint._distributedNodes.push(child);
var points = child._destinationInsertionPoints;
if (!points) {
child._destinationInsertionPoints = [insertionPoint];
} else {
points.push(insertionPoint);
}
}
function clearDistributedDestinationInsertionPoints(content) {
var e$ = content._distributedNodes;
if (e$) {
for (var i = 0; i < e$.length; i++) {
var d = e$[i]._destinationInsertionPoints;
if (d) {
d.splice(d.indexOf(content) + 1, d.length);
}
}
}
}
function maybeRedistributeParent(content, host) {
var parent = TreeApi.Logical.getParentNode(content);
if (parent && parent.shadyRoot && DomApi.hasInsertionPoint(parent.shadyRoot) && parent.shadyRoot._distributionClean) {
parent.shadyRoot._distributionClean = false;
host.shadyRoot._dirtyRoots.push(parent);
}
}
function isFinalDestination(insertionPoint, node) {
var points = node._destinationInsertionPoints;
return points && points[points.length - 1] === insertionPoint;
}
function isInsertionPoint(node) {
return node.localName == 'content';
}
function getTopDistributingHost(host) {
while (host && hostNeedsRedistribution(host)) {
host = host.domHost;
}
return host;
}
function hostNeedsRedistribution(host) {
var c$ = TreeApi.Logical.getChildNodes(host);
for (var i = 0, c; i < c$.length; i++) {
c = c$[i];
if (c.localName && c.localName === 'content') {
return host.domHost;
}
}
}
function notifyContentObservers(root) {
for (var i = 0, c; i < root._insertionPoints.length; i++) {
c = root._insertionPoints[i];
if (DomApi.hasApi(c)) {
Polymer.dom(c).notifyObserver();
}
}
}
function notifyInitialDistribution(host) {
if (DomApi.hasApi(host)) {
Polymer.dom(host).notifyObserver();
}
}
var needsUpgrade = window.CustomElements && !CustomElements.useNative;
function upgradeLogicalChildren(children) {
if (needsUpgrade && children) {
for (var i = 0; i < children.length; i++) {
CustomElements.upgrade(children[i]);
}
}
}
}());
if (Polymer.Settings.useShadow) {
Polymer.Base._addFeature({
_poolContent: function () {
},
_beginDistribute: function () {
},
distributeContent: function () {
},
_distributeContent: function () {
},
_finishDistribute: function () {
},
_createLocalRoot: function () {
this.createShadowRoot();
this.shadowRoot.appendChild(this.root);
this.root = this.shadowRoot;
}
});
}
Polymer.Async = {
_currVal: 0,
_lastVal: 0,
_callbacks: [],
_twiddleContent: 0,
_twiddle: document.createTextNode(''),
run: function (callback, waitTime) {
if (waitTime > 0) {
return ~setTimeout(callback, waitTime);
} else {
this._twiddle.textContent = this._twiddleContent++;
this._callbacks.push(callback);
return this._currVal++;
}
},
cancel: function (handle) {
if (handle < 0) {
clearTimeout(~handle);
} else {
var idx = handle - this._lastVal;
if (idx >= 0) {
if (!this._callbacks[idx]) {
throw 'invalid async handle: ' + handle;
}
this._callbacks[idx] = null;
}
}
},
_atEndOfMicrotask: function () {
var len = this._callbacks.length;
for (var i = 0; i < len; i++) {
var cb = this._callbacks[i];
if (cb) {
try {
cb();
} catch (e) {
i++;
this._callbacks.splice(0, i);
this._lastVal += i;
this._twiddle.textContent = this._twiddleContent++;
throw e;
}
}
}
this._callbacks.splice(0, len);
this._lastVal += len;
}
};
new window.MutationObserver(function () {
Polymer.Async._atEndOfMicrotask();
}).observe(Polymer.Async._twiddle, { characterData: true });
Polymer.Debounce = function () {
var Async = Polymer.Async;
var Debouncer = function (context) {
this.context = context;
var self = this;
this.boundComplete = function () {
self.complete();
};
};
Debouncer.prototype = {
go: function (callback, wait) {
var h;
this.finish = function () {
Async.cancel(h);
};
h = Async.run(this.boundComplete, wait);
this.callback = callback;
},
stop: function () {
if (this.finish) {
this.finish();
this.finish = null;
}
},
complete: function () {
if (this.finish) {
this.stop();
this.callback.call(this.context);
}
}
};
function debounce(debouncer, callback, wait) {
if (debouncer) {
debouncer.stop();
} else {
debouncer = new Debouncer(this);
}
debouncer.go(callback, wait);
return debouncer;
}
return debounce;
}();
Polymer.Base._addFeature({
_setupDebouncers: function () {
this._debouncers = {};
},
debounce: function (jobName, callback, wait) {
return this._debouncers[jobName] = Polymer.Debounce.call(this, this._debouncers[jobName], callback, wait);
},
isDebouncerActive: function (jobName) {
var debouncer = this._debouncers[jobName];
return !!(debouncer && debouncer.finish);
},
flushDebouncer: function (jobName) {
var debouncer = this._debouncers[jobName];
if (debouncer) {
debouncer.complete();
}
},
cancelDebouncer: function (jobName) {
var debouncer = this._debouncers[jobName];
if (debouncer) {
debouncer.stop();
}
}
});
Polymer.DomModule = document.createElement('dom-module');
Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepBehaviors();
this._prepConstructor();
this._prepTemplate();
this._prepShady();
this._prepPropertyInfo();
},
_prepBehavior: function (b) {
this._addHostAttributes(b.hostAttributes);
},
_initFeatures: function () {
this._registerHost();
if (this._template) {
this._poolContent();
this._beginHosting();
this._stampTemplate();
this._endHosting();
}
this._marshalHostAttributes();
this._setupDebouncers();
this._marshalBehaviors();
this._tryReady();
},
_marshalBehavior: function (b) {
}
});</script><script>Polymer.nar = [];
Polymer.Annotations = {
parseAnnotations: function (template) {
var list = [];
var content = template._content || template.content;
this._parseNodeAnnotations(content, list, template.hasAttribute('strip-whitespace'));
return list;
},
_parseNodeAnnotations: function (node, list, stripWhiteSpace) {
return node.nodeType === Node.TEXT_NODE ? this._parseTextNodeAnnotation(node, list) : this._parseElementAnnotations(node, list, stripWhiteSpace);
},
_bindingRegex: function () {
var IDENT = '(?:' + '[a-zA-Z_$][\\w.:$\\-*]*' + ')';
var NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
var SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
var DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
var STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
var ARGUMENT = '(?:' + IDENT + '|' + NUMBER + '|' + STRING + '\\s*' + ')';
var ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
var ARGUMENT_LIST = '(?:' + '\\(\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\)\\s*' + ')';
var BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')';
var OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
var CLOSE_BRACKET = '(?:]]|}})';
var NEGATE = '(?:(!)\\s*)?';
var EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
return new RegExp(EXPRESSION, 'g');
}(),
_parseBindings: function (text) {
var re = this._bindingRegex;
var parts = [];
var lastIndex = 0;
var m;
while ((m = re.exec(text)) !== null) {
if (m.index > lastIndex) {
parts.push({ literal: text.slice(lastIndex, m.index) });
}
var mode = m[1][0];
var negate = Boolean(m[2]);
var value = m[3].trim();
var customEvent, notifyEvent, colon;
if (mode == '{' && (colon = value.indexOf('::')) > 0) {
notifyEvent = value.substring(colon + 2);
value = value.substring(0, colon);
customEvent = true;
}
parts.push({
compoundIndex: parts.length,
value: value,
mode: mode,
negate: negate,
event: notifyEvent,
customEvent: customEvent
});
lastIndex = re.lastIndex;
}
if (lastIndex && lastIndex < text.length) {
var literal = text.substring(lastIndex);
if (literal) {
parts.push({ literal: literal });
}
}
if (parts.length) {
return parts;
}
},
_literalFromParts: function (parts) {
var s = '';
for (var i = 0; i < parts.length; i++) {
var literal = parts[i].literal;
s += literal || '';
}
return s;
},
_parseTextNodeAnnotation: function (node, list) {
var parts = this._parseBindings(node.textContent);
if (parts) {
node.textContent = this._literalFromParts(parts) || ' ';
var annote = {
bindings: [{
kind: 'text',
name: 'textContent',
parts: parts,
isCompound: parts.length !== 1
}]
};
list.push(annote);
return annote;
}
},
_parseElementAnnotations: function (element, list, stripWhiteSpace) {
var annote = {
bindings: [],
events: []
};
if (element.localName === 'content') {
list._hasContent = true;
}
this._parseChildNodesAnnotations(element, annote, list, stripWhiteSpace);
if (element.attributes) {
this._parseNodeAttributeAnnotations(element, annote, list);
if (this.prepElement) {
this.prepElement(element);
}
}
if (annote.bindings.length || annote.events.length || annote.id) {
list.push(annote);
}
return annote;
},
_parseChildNodesAnnotations: function (root, annote, list, stripWhiteSpace) {
if (root.firstChild) {
var node = root.firstChild;
var i = 0;
while (node) {
var next = node.nextSibling;
if (node.localName === 'template' && !node.hasAttribute('preserve-content')) {
this._parseTemplate(node, i, list, annote);
}
if (node.nodeType === Node.TEXT_NODE) {
var n = next;
while (n && n.nodeType === Node.TEXT_NODE) {
node.textContent += n.textContent;
next = n.nextSibling;
root.removeChild(n);
n = next;
}
if (stripWhiteSpace && !node.textContent.trim()) {
root.removeChild(node);
i--;
}
}
if (node.parentNode) {
var childAnnotation = this._parseNodeAnnotations(node, list, stripWhiteSpace);
if (childAnnotation) {
childAnnotation.parent = annote;
childAnnotation.index = i;
}
}
node = next;
i++;
}
}
},
_parseTemplate: function (node, index, list, parent) {
var content = document.createDocumentFragment();
content._notes = this.parseAnnotations(node);
content.appendChild(node.content);
list.push({
bindings: Polymer.nar,
events: Polymer.nar,
templateContent: content,
parent: parent,
index: index
});
},
_parseNodeAttributeAnnotations: function (node, annotation) {
var attrs = Array.prototype.slice.call(node.attributes);
for (var i = attrs.length - 1, a; a = attrs[i]; i--) {
var n = a.name;
var v = a.value;
var b;
if (n.slice(0, 3) === 'on-') {
node.removeAttribute(n);
annotation.events.push({
name: n.slice(3),
value: v
});
} else if (b = this._parseNodeAttributeAnnotation(node, n, v)) {
annotation.bindings.push(b);
} else if (n === 'id') {
annotation.id = v;
}
}
},
_parseNodeAttributeAnnotation: function (node, name, value) {
var parts = this._parseBindings(value);
if (parts) {
var origName = name;
var kind = 'property';
if (name[name.length - 1] == '$') {
name = name.slice(0, -1);
kind = 'attribute';
}
var literal = this._literalFromParts(parts);
if (literal && kind == 'attribute') {
node.setAttribute(name, literal);
}
if (node.localName === 'input' && origName === 'value') {
node.setAttribute(origName, '');
}
node.removeAttribute(origName);
var propertyName = Polymer.CaseMap.dashToCamelCase(name);
if (kind === 'property') {
name = propertyName;
}
return {
kind: kind,
name: name,
propertyName: propertyName,
parts: parts,
literal: literal,
isCompound: parts.length !== 1
};
}
},
findAnnotatedNode: function (root, annote) {
var parent = annote.parent && Polymer.Annotations.findAnnotatedNode(root, annote.parent);
if (parent) {
for (var n = parent.firstChild, i = 0; n; n = n.nextSibling) {
if (annote.index === i++) {
return n;
}
}
} else {
return root;
}
}
};
(function () {
function resolveCss(cssText, ownerDocument) {
return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {
return pre + '\'' + resolve(url.replace(/["']/g, ''), ownerDocument) + '\'' + post;
});
}
function resolveAttrs(element, ownerDocument) {
for (var name in URL_ATTRS) {
var a$ = URL_ATTRS[name];
for (var i = 0, l = a$.length, a, at, v; i < l && (a = a$[i]); i++) {
if (name === '*' || element.localName === name) {
at = element.attributes[a];
v = at && at.value;
if (v && v.search(BINDING_RX) < 0) {
at.value = a === 'style' ? resolveCss(v, ownerDocument) : resolve(v, ownerDocument);
}
}
}
}
}
function resolve(url, ownerDocument) {
if (url && url[0] === '#') {
return url;
}
var resolver = getUrlResolver(ownerDocument);
resolver.href = url;
return resolver.href || url;
}
var tempDoc;
var tempDocBase;
function resolveUrl(url, baseUri) {
if (!tempDoc) {
tempDoc = document.implementation.createHTMLDocument('temp');
tempDocBase = tempDoc.createElement('base');
tempDoc.head.appendChild(tempDocBase);
}
tempDocBase.href = baseUri;
return resolve(url, tempDoc);
}
function getUrlResolver(ownerDocument) {
return ownerDocument.__urlResolver || (ownerDocument.__urlResolver = ownerDocument.createElement('a'));
}
var CSS_URL_RX = /(url\()([^)]*)(\))/g;
var URL_ATTRS = {
'*': [
'href',
'src',
'style',
'url'
],
form: ['action']
};
var BINDING_RX = /\{\{|\[\[/;
Polymer.ResolveUrl = {
resolveCss: resolveCss,
resolveAttrs: resolveAttrs,
resolveUrl: resolveUrl
};
}());
Polymer.Base._addFeature({
_prepAnnotations: function () {
if (!this._template) {
this._notes = [];
} else {
var self = this;
Polymer.Annotations.prepElement = function (element) {
self._prepElement(element);
};
if (this._template._content && this._template._content._notes) {
this._notes = this._template._content._notes;
} else {
this._notes = Polymer.Annotations.parseAnnotations(this._template);
this._processAnnotations(this._notes);
}
Polymer.Annotations.prepElement = null;
}
},
_processAnnotations: function (notes) {
for (var i = 0; i < notes.length; i++) {
var note = notes[i];
for (var j = 0; j < note.bindings.length; j++) {
var b = note.bindings[j];
for (var k = 0; k < b.parts.length; k++) {
var p = b.parts[k];
if (!p.literal) {
var signature = this._parseMethod(p.value);
if (signature) {
p.signature = signature;
} else {
p.model = this._modelForPath(p.value);
}
}
}
}
if (note.templateContent) {
this._processAnnotations(note.templateContent._notes);
var pp = note.templateContent._parentProps = this._discoverTemplateParentProps(note.templateContent._notes);
var bindings = [];
for (var prop in pp) {
bindings.push({
index: note.index,
kind: 'property',
name: '_parent_' + prop,
parts: [{
mode: '{',
model: prop,
value: prop
}]
});
}
note.bindings = note.bindings.concat(bindings);
}
}
},
_discoverTemplateParentProps: function (notes) {
var pp = {};
for (var i = 0, n; i < notes.length && (n = notes[i]); i++) {
for (var j = 0, b$ = n.bindings, b; j < b$.length && (b = b$[j]); j++) {
for (var k = 0, p$ = b.parts, p; k < p$.length && (p = p$[k]); k++) {
if (p.signature) {
var args = p.signature.args;
for (var kk = 0; kk < args.length; kk++) {
var model = args[kk].model;
if (model) {
pp[model] = true;
}
}
} else {
if (p.model) {
pp[p.model] = true;
}
}
}
}
if (n.templateContent) {
var tpp = n.templateContent._parentProps;
Polymer.Base.mixin(pp, tpp);
}
}
return pp;
},
_prepElement: function (element) {
Polymer.ResolveUrl.resolveAttrs(element, this._template.ownerDocument);
},
_findAnnotatedNode: Polymer.Annotations.findAnnotatedNode,
_marshalAnnotationReferences: function () {
if (this._template) {
this._marshalIdNodes();
this._marshalAnnotatedNodes();
this._marshalAnnotatedListeners();
}
},
_configureAnnotationReferences: function () {
var notes = this._notes;
var nodes = this._nodes;
for (var i = 0; i < notes.length; i++) {
var note = notes[i];
var node = nodes[i];
this._configureTemplateContent(note, node);
this._configureCompoundBindings(note, node);
}
},
_configureTemplateContent: function (note, node) {
if (note.templateContent) {
node._content = note.templateContent;
}
},
_configureCompoundBindings: function (note, node) {
var bindings = note.bindings;
for (var i = 0; i < bindings.length; i++) {
var binding = bindings[i];
if (binding.isCompound) {
var storage = node.__compoundStorage__ || (node.__compoundStorage__ = {});
var parts = binding.parts;
var literals = new Array(parts.length);
for (var j = 0; j < parts.length; j++) {
literals[j] = parts[j].literal;
}
var name = binding.name;
storage[name] = literals;
if (binding.literal && binding.kind == 'property') {
if (node._configValue) {
node._configValue(name, binding.literal);
} else {
node[name] = binding.literal;
}
}
}
}
},
_marshalIdNodes: function () {
this.$ = {};
for (var i = 0, l = this._notes.length, a; i < l && (a = this._notes[i]); i++) {
if (a.id) {
this.$[a.id] = this._findAnnotatedNode(this.root, a);
}
}
},
_marshalAnnotatedNodes: function () {
if (this._notes && this._notes.length) {
var r = new Array(this._notes.length);
for (var i = 0; i < this._notes.length; i++) {
r[i] = this._findAnnotatedNode(this.root, this._notes[i]);
}
this._nodes = r;
}
},
_marshalAnnotatedListeners: function () {
for (var i = 0, l = this._notes.length, a; i < l && (a = this._notes[i]); i++) {
if (a.events && a.events.length) {
var node = this._findAnnotatedNode(this.root, a);
for (var j = 0, e$ = a.events, e; j < e$.length && (e = e$[j]); j++) {
this.listen(node, e.name, e.value);
}
}
}
}
});
Polymer.Base._addFeature({
listeners: {},
_listenListeners: function (listeners) {
var node, name, eventName;
for (eventName in listeners) {
if (eventName.indexOf('.') < 0) {
node = this;
name = eventName;
} else {
name = eventName.split('.');
node = this.$[name[0]];
name = name[1];
}
this.listen(node, name, listeners[eventName]);
}
},
listen: function (node, eventName, methodName) {
var handler = this._recallEventHandler(this, eventName, node, methodName);
if (!handler) {
handler = this._createEventHandler(node, eventName, methodName);
}
if (handler._listening) {
return;
}
this._listen(node, eventName, handler);
handler._listening = true;
},
_boundListenerKey: function (eventName, methodName) {
return eventName + ':' + methodName;
},
_recordEventHandler: function (host, eventName, target, methodName, handler) {
var hbl = host.__boundListeners;
if (!hbl) {
hbl = host.__boundListeners = new WeakMap();
}
var bl = hbl.get(target);
if (!bl) {
bl = {};
hbl.set(target, bl);
}
var key = this._boundListenerKey(eventName, methodName);
bl[key] = handler;
},
_recallEventHandler: function (host, eventName, target, methodName) {
var hbl = host.__boundListeners;
if (!hbl) {
return;
}
var bl = hbl.get(target);
if (!bl) {
return;
}
var key = this._boundListenerKey(eventName, methodName);
return bl[key];
},
_createEventHandler: function (node, eventName, methodName) {
var host = this;
var handler = function (e) {
if (host[methodName]) {
host[methodName](e, e.detail);
} else {
host._warn(host._logf('_createEventHandler', 'listener method `' + methodName + '` not defined'));
}
};
handler._listening = false;
this._recordEventHandler(host, eventName, node, methodName, handler);
return handler;
},
unlisten: function (node, eventName, methodName) {
var handler = this._recallEventHandler(this, eventName, node, methodName);
if (handler) {
this._unlisten(node, eventName, handler);
handler._listening = false;
}
},
_listen: function (node, eventName, handler) {
node.addEventListener(eventName, handler);
},
_unlisten: function (node, eventName, handler) {
node.removeEventListener(eventName, handler);
}
});
(function () {
'use strict';
var wrap = Polymer.DomApi.wrap;
var HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
var GESTURE_KEY = '__polymerGestures';
var HANDLED_OBJ = '__polymerGesturesHandled';
var TOUCH_ACTION = '__polymerGesturesTouchAction';
var TAP_DISTANCE = 25;
var TRACK_DISTANCE = 5;
var TRACK_LENGTH = 2;
var MOUSE_TIMEOUT = 2500;
var MOUSE_EVENTS = [
'mousedown',
'mousemove',
'mouseup',
'click'
];
var MOUSE_WHICH_TO_BUTTONS = [
0,
1,
4,
2
];
var MOUSE_HAS_BUTTONS = function () {
try {
return new MouseEvent('test', { buttons: 1 }).buttons === 1;
} catch (e) {
return false;
}
}();
var IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);
var mouseCanceller = function (mouseEvent) {
mouseEvent[HANDLED_OBJ] = { skip: true };
if (mouseEvent.type === 'click') {
var path = Polymer.dom(mouseEvent).path;
for (var i = 0; i < path.length; i++) {
if (path[i] === POINTERSTATE.mouse.target) {
return;
}
}
mouseEvent.preventDefault();
mouseEvent.stopPropagation();
}
};
function setupTeardownMouseCanceller(setup) {
for (var i = 0, en; i < MOUSE_EVENTS.length; i++) {
en = MOUSE_EVENTS[i];
if (setup) {
document.addEventListener(en, mouseCanceller, true);
} else {
document.removeEventListener(en, mouseCanceller, true);
}
}
}
function ignoreMouse() {
if (IS_TOUCH_ONLY) {
return;
}
if (!POINTERSTATE.mouse.mouseIgnoreJob) {
setupTeardownMouseCanceller(true);
}
var unset = function () {
setupTeardownMouseCanceller();
POINTERSTATE.mouse.target = null;
POINTERSTATE.mouse.mouseIgnoreJob = null;
};
POINTERSTATE.mouse.mouseIgnoreJob = Polymer.Debounce(POINTERSTATE.mouse.mouseIgnoreJob, unset, MOUSE_TIMEOUT);
}
function hasLeftMouseButton(ev) {
var type = ev.type;
if (MOUSE_EVENTS.indexOf(type) === -1) {
return false;
}
if (type === 'mousemove') {
var buttons = ev.buttons === undefined ? 1 : ev.buttons;
if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {
buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
}
return Boolean(buttons & 1);
} else {
var button = ev.button === undefined ? 0 : ev.button;
return button === 0;
}
}
function isSyntheticClick(ev) {
if (ev.type === 'click') {
if (ev.detail === 0) {
return true;
}
var t = Gestures.findOriginalTarget(ev);
var bcr = t.getBoundingClientRect();
var x = ev.pageX, y = ev.pageY;
return !(x >= bcr.left && x <= bcr.right && (y >= bcr.top && y <= bcr.bottom));
}
return false;
}
var POINTERSTATE = {
mouse: {
target: null,
mouseIgnoreJob: null
},
touch: {
x: 0,
y: 0,
id: -1,
scrollDecided: false
}
};
function firstTouchAction(ev) {
var path = Polymer.dom(ev).path;
var ta = 'auto';
for (var i = 0, n; i < path.length; i++) {
n = path[i];
if (n[TOUCH_ACTION]) {
ta = n[TOUCH_ACTION];
break;
}
}
return ta;
}
function trackDocument(stateObj, movefn, upfn) {
stateObj.movefn = movefn;
stateObj.upfn = upfn;
document.addEventListener('mousemove', movefn);
document.addEventListener('mouseup', upfn);
}
function untrackDocument(stateObj) {
document.removeEventListener('mousemove', stateObj.movefn);
document.removeEventListener('mouseup', stateObj.upfn);
stateObj.movefn = null;
stateObj.upfn = null;
}
var Gestures = {
gestures: {},
recognizers: [],
deepTargetFind: function (x, y) {
var node = document.elementFromPoint(x, y);
var next = node;
while (next && next.shadowRoot) {
next = next.shadowRoot.elementFromPoint(x, y);
if (next) {
node = next;
}
}
return node;
},
findOriginalTarget: function (ev) {
if (ev.path) {
return ev.path[0];
}
return ev.target;
},
handleNative: function (ev) {
var handled;
var type = ev.type;
var node = wrap(ev.currentTarget);
var gobj = node[GESTURE_KEY];
if (!gobj) {
return;
}
var gs = gobj[type];
if (!gs) {
return;
}
if (!ev[HANDLED_OBJ]) {
ev[HANDLED_OBJ] = {};
if (type.slice(0, 5) === 'touch') {
var t = ev.changedTouches[0];
if (type === 'touchstart') {
if (ev.touches.length === 1) {
POINTERSTATE.touch.id = t.identifier;
}
}
if (POINTERSTATE.touch.id !== t.identifier) {
return;
}
if (!HAS_NATIVE_TA) {
if (type === 'touchstart' || type === 'touchmove') {
Gestures.handleTouchAction(ev);
}
}
if (type === 'touchend' && !ev.__polymerSimulatedTouch) {
POINTERSTATE.mouse.target = Polymer.dom(ev).rootTarget;
ignoreMouse(true);
}
}
}
handled = ev[HANDLED_OBJ];
if (handled.skip) {
return;
}
var recognizers = Gestures.recognizers;
for (var i = 0, r; i < recognizers.length; i++) {
r = recognizers[i];
if (gs[r.name] && !handled[r.name]) {
if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
r.reset();
}
}
}
for (i = 0, r; i < recognizers.length; i++) {
r = recognizers[i];
if (gs[r.name] && !handled[r.name]) {
handled[r.name] = true;
r[type](ev);
}
}
},
handleTouchAction: function (ev) {
var t = ev.changedTouches[0];
var type = ev.type;
if (type === 'touchstart') {
POINTERSTATE.touch.x = t.clientX;
POINTERSTATE.touch.y = t.clientY;
POINTERSTATE.touch.scrollDecided = false;
} else if (type === 'touchmove') {
if (POINTERSTATE.touch.scrollDecided) {
return;
}
POINTERSTATE.touch.scrollDecided = true;
var ta = firstTouchAction(ev);
var prevent = false;
var dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
var dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
if (!ev.cancelable) {
} else if (ta === 'none') {
prevent = true;
} else if (ta === 'pan-x') {
prevent = dy > dx;
} else if (ta === 'pan-y') {
prevent = dx > dy;
}
if (prevent) {
ev.preventDefault();
} else {
Gestures.prevent('track');
}
}
},
add: function (node, evType, handler) {
node = wrap(node);
var recognizer = this.gestures[evType];
var deps = recognizer.deps;
var name = recognizer.name;
var gobj = node[GESTURE_KEY];
if (!gobj) {
node[GESTURE_KEY] = gobj = {};
}
for (var i = 0, dep, gd; i < deps.length; i++) {
dep = deps[i];
if (IS_TOUCH_ONLY && MOUSE_EVENTS.indexOf(dep) > -1) {
continue;
}
gd = gobj[dep];
if (!gd) {
gobj[dep] = gd = { _count: 0 };
}
if (gd._count === 0) {
node.addEventListener(dep, this.handleNative);
}
gd[name] = (gd[name] || 0) + 1;
gd._count = (gd._count || 0) + 1;
}
node.addEventListener(evType, handler);
if (recognizer.touchAction) {
this.setTouchAction(node, recognizer.touchAction);
}
},
remove: function (node, evType, handler) {
node = wrap(node);
var recognizer = this.gestures[evType];
var deps = recognizer.deps;
var name = recognizer.name;
var gobj = node[GESTURE_KEY];
if (gobj) {
for (var i = 0, dep, gd; i < deps.length; i++) {
dep = deps[i];
gd = gobj[dep];
if (gd && gd[name]) {
gd[name] = (gd[name] || 1) - 1;
gd._count = (gd._count || 1) - 1;
if (gd._count === 0) {
node.removeEventListener(dep, this.handleNative);
}
}
}
}
node.removeEventListener(evType, handler);
},
register: function (recog) {
this.recognizers.push(recog);
for (var i = 0; i < recog.emits.length; i++) {
this.gestures[recog.emits[i]] = recog;
}
},
findRecognizerByEvent: function (evName) {
for (var i = 0, r; i < this.recognizers.length; i++) {
r = this.recognizers[i];
for (var j = 0, n; j < r.emits.length; j++) {
n = r.emits[j];
if (n === evName) {
return r;
}
}
}
return null;
},
setTouchAction: function (node, value) {
if (HAS_NATIVE_TA) {
node.style.touchAction = value;
}
node[TOUCH_ACTION] = value;
},
fire: function (target, type, detail) {
var ev = Polymer.Base.fire(type, detail, {
node: target,
bubbles: true,
cancelable: true
});
if (ev.defaultPrevented) {
var se = detail.sourceEvent;
if (se && se.preventDefault) {
se.preventDefault();
}
}
},
prevent: function (evName) {
var recognizer = this.findRecognizerByEvent(evName);
if (recognizer.info) {
recognizer.info.prevent = true;
}
}
};
Gestures.register({
name: 'downup',
deps: [
'mousedown',
'touchstart',
'touchend'
],
flow: {
start: [
'mousedown',
'touchstart'
],
end: [
'mouseup',
'touchend'
]
},
emits: [
'down',
'up'
],
info: {
movefn: null,
upfn: null
},
reset: function () {
untrackDocument(this.info);
},
mousedown: function (e) {
if (!hasLeftMouseButton(e)) {
return;
}
var t = Gestures.findOriginalTarget(e);
var self = this;
var movefn = function movefn(e) {
if (!hasLeftMouseButton(e)) {
self.fire('up', t, e);
untrackDocument(self.info);
}
};
var upfn = function upfn(e) {
if (hasLeftMouseButton(e)) {
self.fire('up', t, e);
}
untrackDocument(self.info);
};
trackDocument(this.info, movefn, upfn);
this.fire('down', t, e);
},
touchstart: function (e) {
this.fire('down', Gestures.findOriginalTarget(e), e.changedTouches[0]);
},
touchend: function (e) {
this.fire('up', Gestures.findOriginalTarget(e), e.changedTouches[0]);
},
fire: function (type, target, event) {
Gestures.fire(target, type, {
x: event.clientX,
y: event.clientY,
sourceEvent: event,
prevent: function (e) {
return Gestures.prevent(e);
}
});
}
});
Gestures.register({
name: 'track',
touchAction: 'none',
deps: [
'mousedown',
'touchstart',
'touchmove',
'touchend'
],
flow: {
start: [
'mousedown',
'touchstart'
],
end: [
'mouseup',
'touchend'
]
},
emits: ['track'],
info: {
x: 0,
y: 0,
state: 'start',
started: false,
moves: [],
addMove: function (move) {
if (this.moves.length > TRACK_LENGTH) {
this.moves.shift();
}
this.moves.push(move);
},
movefn: null,
upfn: null,
prevent: false
},
reset: function () {
this.info.state = 'start';
this.info.started = false;
this.info.moves = [];
this.info.x = 0;
this.info.y = 0;
this.info.prevent = false;
untrackDocument(this.info);
},
hasMovedEnough: function (x, y) {
if (this.info.prevent) {
return false;
}
if (this.info.started) {
return true;
}
var dx = Math.abs(this.info.x - x);
var dy = Math.abs(this.info.y - y);
return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
},
mousedown: function (e) {
if (!hasLeftMouseButton(e)) {
return;
}
var t = Gestures.findOriginalTarget(e);
var self = this;
var movefn = function movefn(e) {
var x = e.clientX, y = e.clientY;
if (self.hasMovedEnough(x, y)) {
self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';
if (self.info.state === 'start') {
Gestures.prevent('tap');
}
self.info.addMove({
x: x,
y: y
});
if (!hasLeftMouseButton(e)) {
self.info.state = 'end';
untrackDocument(self.info);
}
self.fire(t, e);
self.info.started = true;
}
};
var upfn = function upfn(e) {
if (self.info.started) {
movefn(e);
}
untrackDocument(self.info);
};
trackDocument(this.info, movefn, upfn);
this.info.x = e.clientX;
this.info.y = e.clientY;
},
touchstart: function (e) {
var ct = e.changedTouches[0];
this.info.x = ct.clientX;
this.info.y = ct.clientY;
},
touchmove: function (e) {
var t = Gestures.findOriginalTarget(e);
var ct = e.changedTouches[0];
var x = ct.clientX, y = ct.clientY;
if (this.hasMovedEnough(x, y)) {
if (this.info.state === 'start') {
Gestures.prevent('tap');
}
this.info.addMove({
x: x,
y: y
});
this.fire(t, ct);
this.info.state = 'track';
this.info.started = true;
}
},
touchend: function (e) {
var t = Gestures.findOriginalTarget(e);
var ct = e.changedTouches[0];
if (this.info.started) {
this.info.state = 'end';
this.info.addMove({
x: ct.clientX,
y: ct.clientY
});
this.fire(t, ct);
}
},
fire: function (target, touch) {
var secondlast = this.info.moves[this.info.moves.length - 2];
var lastmove = this.info.moves[this.info.moves.length - 1];
var dx = lastmove.x - this.info.x;
var dy = lastmove.y - this.info.y;
var ddx, ddy = 0;
if (secondlast) {
ddx = lastmove.x - secondlast.x;
ddy = lastmove.y - secondlast.y;
}
return Gestures.fire(target, 'track', {
state: this.info.state,
x: touch.clientX,
y: touch.clientY,
dx: dx,
dy: dy,
ddx: ddx,
ddy: ddy,
sourceEvent: touch,
hover: function () {
return Gestures.deepTargetFind(touch.clientX, touch.clientY);
}
});
}
});
Gestures.register({
name: 'tap',
deps: [
'mousedown',
'click',
'touchstart',
'touchend'
],
flow: {
start: [
'mousedown',
'touchstart'
],
end: [
'click',
'touchend'
]
},
emits: ['tap'],
info: {
x: NaN,
y: NaN,
prevent: false
},
reset: function () {
this.info.x = NaN;
this.info.y = NaN;
this.info.prevent = false;
},
save: function (e) {
this.info.x = e.clientX;
this.info.y = e.clientY;
},
mousedown: function (e) {
if (hasLeftMouseButton(e)) {
this.save(e);
}
},
click: function (e) {
if (hasLeftMouseButton(e)) {
this.forward(e);
}
},
touchstart: function (e) {
this.save(e.changedTouches[0]);
},
touchend: function (e) {
this.forward(e.changedTouches[0]);
},
forward: function (e) {
var dx = Math.abs(e.clientX - this.info.x);
var dy = Math.abs(e.clientY - this.info.y);
var t = Gestures.findOriginalTarget(e);
if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {
if (!this.info.prevent) {
Gestures.fire(t, 'tap', {
x: e.clientX,
y: e.clientY,
sourceEvent: e
});
}
}
}
});
var DIRECTION_MAP = {
x: 'pan-x',
y: 'pan-y',
none: 'none',
all: 'auto'
};
Polymer.Base._addFeature({
_setupGestures: function () {
this.__polymerGestures = null;
},
_listen: function (node, eventName, handler) {
if (Gestures.gestures[eventName]) {
Gestures.add(node, eventName, handler);
} else {
node.addEventListener(eventName, handler);
}
},
_unlisten: function (node, eventName, handler) {
if (Gestures.gestures[eventName]) {
Gestures.remove(node, eventName, handler);
} else {
node.removeEventListener(eventName, handler);
}
},
setScrollDirection: function (direction, node) {
node = node || this;
Gestures.setTouchAction(node, DIRECTION_MAP[direction] || 'auto');
}
});
Polymer.Gestures = Gestures;
}());
Polymer.Base._addFeature({
$$: function (slctr) {
return Polymer.dom(this.root).querySelector(slctr);
},
toggleClass: function (name, bool, node) {
node = node || this;
if (arguments.length == 1) {
bool = !node.classList.contains(name);
}
if (bool) {
Polymer.dom(node).classList.add(name);
} else {
Polymer.dom(node).classList.remove(name);
}
},
toggleAttribute: function (name, bool, node) {
node = node || this;
if (arguments.length == 1) {
bool = !node.hasAttribute(name);
}
if (bool) {
Polymer.dom(node).setAttribute(name, '');
} else {
Polymer.dom(node).removeAttribute(name);
}
},
classFollows: function (name, toElement, fromElement) {
if (fromElement) {
Polymer.dom(fromElement).classList.remove(name);
}
if (toElement) {
Polymer.dom(toElement).classList.add(name);
}
},
attributeFollows: function (name, toElement, fromElement) {
if (fromElement) {
Polymer.dom(fromElement).removeAttribute(name);
}
if (toElement) {
Polymer.dom(toElement).setAttribute(name, '');
}
},
getEffectiveChildNodes: function () {
return Polymer.dom(this).getEffectiveChildNodes();
},
getEffectiveChildren: function () {
var list = Polymer.dom(this).getEffectiveChildNodes();
return list.filter(function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
},
getEffectiveTextContent: function () {
var cn = this.getEffectiveChildNodes();
var tc = [];
for (var i = 0, c; c = cn[i]; i++) {
if (c.nodeType !== Node.COMMENT_NODE) {
tc.push(Polymer.dom(c).textContent);
}
}
return tc.join('');
},
queryEffectiveChildren: function (slctr) {
var e$ = Polymer.dom(this).queryDistributedElements(slctr);
return e$ && e$[0];
},
queryAllEffectiveChildren: function (slctr) {
return Polymer.dom(this).queryDistributedElements(slctr);
},
getContentChildNodes: function (slctr) {
var content = Polymer.dom(this.root).querySelector(slctr || 'content');
return content ? Polymer.dom(content).getDistributedNodes() : [];
},
getContentChildren: function (slctr) {
return this.getContentChildNodes(slctr).filter(function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
},
fire: function (type, detail, options) {
options = options || Polymer.nob;
var node = options.node || this;
detail = detail === null || detail === undefined ? {} : detail;
var bubbles = options.bubbles === undefined ? true : options.bubbles;
var cancelable = Boolean(options.cancelable);
var useCache = options._useCache;
var event = this._getEvent(type, bubbles, cancelable, useCache);
event.detail = detail;
if (useCache) {
this.__eventCache[type] = null;
}
node.dispatchEvent(event);
if (useCache) {
this.__eventCache[type] = event;
}
return event;
},
__eventCache: {},
_getEvent: function (type, bubbles, cancelable, useCache) {
var event = useCache && this.__eventCache[type];
if (!event || (event.bubbles != bubbles || event.cancelable != cancelable)) {
event = new Event(type, {
bubbles: Boolean(bubbles),
cancelable: cancelable
});
}
return event;
},
async: function (callback, waitTime) {
var self = this;
return Polymer.Async.run(function () {
callback.call(self);
}, waitTime);
},
cancelAsync: function (handle) {
Polymer.Async.cancel(handle);
},
arrayDelete: function (path, item) {
var index;
if (Array.isArray(path)) {
index = path.indexOf(item);
if (index >= 0) {
return path.splice(index, 1);
}
} else {
var arr = this._get(path);
index = arr.indexOf(item);
if (index >= 0) {
return this.splice(path, index, 1);
}
}
},
transform: function (transform, node) {
node = node || this;
node.style.webkitTransform = transform;
node.style.transform = transform;
},
translate3d: function (x, y, z, node) {
node = node || this;
this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
},
importHref: function (href, onload, onerror, optAsync) {
var l = document.createElement('link');
l.rel = 'import';
l.href = href;
optAsync = Boolean(optAsync);
if (optAsync) {
l.setAttribute('async', '');
}
var self = this;
if (onload) {
l.onload = function (e) {
return onload.call(self, e);
};
}
if (onerror) {
l.onerror = function (e) {
return onerror.call(self, e);
};
}
document.head.appendChild(l);
return l;
},
create: function (tag, props) {
var elt = document.createElement(tag);
if (props) {
for (var n in props) {
elt[n] = props[n];
}
}
return elt;
},
isLightDescendant: function (node) {
return this !== node && this.contains(node) && Polymer.dom(this).getOwnerRoot() === Polymer.dom(node).getOwnerRoot();
},
isLocalDescendant: function (node) {
return this.root === Polymer.dom(node).getOwnerRoot();
}
});
Polymer.Bind = {
_dataEventCache: {},
prepareModel: function (model) {
Polymer.Base.mixin(model, this._modelApi);
},
_modelApi: {
_notifyChange: function (source, event, value) {
value = value === undefined ? this[source] : value;
event = event || Polymer.CaseMap.camelToDashCase(source) + '-changed';
this.fire(event, { value: value }, {
bubbles: false,
cancelable: false,
_useCache: true
});
},
_propertySetter: function (property, value, effects, fromAbove) {
var old = this.__data__[property];
if (old !== value && (old === old || value === value)) {
this.__data__[property] = value;
if (typeof value == 'object') {
this._clearPath(property);
}
if (this._propertyChanged) {
this._propertyChanged(property, value, old);
}
if (effects) {
this._effectEffects(property, value, effects, old, fromAbove);
}
}
return old;
},
__setProperty: function (property, value, quiet, node) {
node = node || this;
var effects = node._propertyEffects && node._propertyEffects[property];
if (effects) {
node._propertySetter(property, value, effects, quiet);
} else {
node[property] = value;
}
},
_effectEffects: function (property, value, effects, old, fromAbove) {
for (var i = 0, l = effects.length, fx; i < l && (fx = effects[i]); i++) {
fx.fn.call(this, property, value, fx.effect, old, fromAbove);
}
},
_clearPath: function (path) {
for (var prop in this.__data__) {
if (prop.indexOf(path + '.') === 0) {
this.__data__[prop] = undefined;
}
}
}
},
ensurePropertyEffects: function (model, property) {
if (!model._propertyEffects) {
model._propertyEffects = {};
}
var fx = model._propertyEffects[property];
if (!fx) {
fx = model._propertyEffects[property] = [];
}
return fx;
},
addPropertyEffect: function (model, property, kind, effect) {
var fx = this.ensurePropertyEffects(model, property);
var propEffect = {
kind: kind,
effect: effect,
fn: Polymer.Bind['_' + kind + 'Effect']
};
fx.push(propEffect);
return propEffect;
},
createBindings: function (model) {
var fx$ = model._propertyEffects;
if (fx$) {
for (var n in fx$) {
var fx = fx$[n];
fx.sort(this._sortPropertyEffects);
this._createAccessors(model, n, fx);
}
}
},
_sortPropertyEffects: function () {
var EFFECT_ORDER = {
'compute': 0,
'annotation': 1,
'annotatedComputation': 2,
'reflect': 3,
'notify': 4,
'observer': 5,
'complexObserver': 6,
'function': 7
};
return function (a, b) {
return EFFECT_ORDER[a.kind] - EFFECT_ORDER[b.kind];
};
}(),
_createAccessors: function (model, property, effects) {
var defun = {
get: function () {
return this.__data__[property];
}
};
var setter = function (value) {
this._propertySetter(property, value, effects);
};
var info = model.getPropertyInfo && model.getPropertyInfo(property);
if (info && info.readOnly) {
if (!info.computed) {
model['_set' + this.upper(property)] = setter;
}
} else {
defun.set = setter;
}
Object.defineProperty(model, property, defun);
},
upper: function (name) {
return name[0].toUpperCase() + name.substring(1);
},
_addAnnotatedListener: function (model, index, property, path, event, negated) {
if (!model._bindListeners) {
model._bindListeners = [];
}
var fn = this._notedListenerFactory(property, path, this._isStructured(path), negated);
var eventName = event || Polymer.CaseMap.camelToDashCase(property) + '-changed';
model._bindListeners.push({
index: index,
property: property,
path: path,
changedFn: fn,
event: eventName
});
},
_isStructured: function (path) {
return path.indexOf('.') > 0;
},
_isEventBogus: function (e, target) {
return e.path && e.path[0] !== target;
},
_notedListenerFactory: function (property, path, isStructured, negated) {
return function (target, value, targetPath) {
if (targetPath) {
this._notifyPath(this._fixPath(path, property, targetPath), value);
} else {
value = target[property];
if (negated) {
value = !value;
}
if (!isStructured) {
this[path] = value;
} else {
if (this.__data__[path] != value) {
this.set(path, value);
}
}
}
};
},
prepareInstance: function (inst) {
inst.__data__ = Object.create(null);
},
setupBindListeners: function (inst) {
var b$ = inst._bindListeners;
for (var i = 0, l = b$.length, info; i < l && (info = b$[i]); i++) {
var node = inst._nodes[info.index];
this._addNotifyListener(node, inst, info.event, info.changedFn);
}
},
_addNotifyListener: function (element, context, event, changedFn) {
element.addEventListener(event, function (e) {
return context._notifyListener(changedFn, e);
});
}
};
Polymer.Base.extend(Polymer.Bind, {
_shouldAddListener: function (effect) {
return effect.name && effect.kind != 'attribute' && effect.kind != 'text' && !effect.isCompound && effect.parts[0].mode === '{';
},
_annotationEffect: function (source, value, effect) {
if (source != effect.value) {
value = this._get(effect.value);
this.__data__[effect.value] = value;
}
var calc = effect.negate ? !value : value;
if (!effect.customEvent || this._nodes[effect.index][effect.name] !== calc) {
return this._applyEffectValue(effect, calc);
}
},
_reflectEffect: function (source, value, effect) {
this.reflectPropertyToAttribute(source, effect.attribute, value);
},
_notifyEffect: function (source, value, effect, old, fromAbove) {
if (!fromAbove) {
this._notifyChange(source, effect.event, value);
}
},
_functionEffect: function (source, value, fn, old, fromAbove) {
fn.call(this, source, value, old, fromAbove);
},
_observerEffect: function (source, value, effect, old) {
var fn = this[effect.method];
if (fn) {
fn.call(this, value, old);
} else {
this._warn(this._logf('_observerEffect', 'observer method `' + effect.method + '` not defined'));
}
},
_complexObserverEffect: function (source, value, effect) {
var fn = this[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
fn.apply(this, args);
}
} else if (effect.dynamicFn) {
} else {
this._warn(this._logf('_complexObserverEffect', 'observer method `' + effect.method + '` not defined'));
}
},
_computeEffect: function (source, value, effect) {
var fn = this[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
var computedvalue = fn.apply(this, args);
this.__setProperty(effect.name, computedvalue);
}
} else if (effect.dynamicFn) {
} else {
this._warn(this._logf('_computeEffect', 'compute method `' + effect.method + '` not defined'));
}
},
_annotatedComputationEffect: function (source, value, effect) {
var computedHost = this._rootDataHost || this;
var fn = computedHost[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
var computedvalue = fn.apply(computedHost, args);
if (effect.negate) {
computedvalue = !computedvalue;
}
this._applyEffectValue(effect, computedvalue);
}
} else if (effect.dynamicFn) {
} else {
computedHost._warn(computedHost._logf('_annotatedComputationEffect', 'compute method `' + effect.method + '` not defined'));
}
},
_marshalArgs: function (model, effect, path, value) {
var values = [];
var args = effect.args;
var bailoutEarly = args.length > 1 || effect.dynamicFn;
for (var i = 0, l = args.length; i < l; i++) {
var arg = args[i];
var name = arg.name;
var v;
if (arg.literal) {
v = arg.value;
} else if (arg.structured) {
v = Polymer.Base._get(name, model);
} else {
v = model[name];
}
if (bailoutEarly && v === undefined) {
return;
}
if (arg.wildcard) {
var baseChanged = name.indexOf(path + '.') === 0;
var matches = effect.trigger.name.indexOf(name) === 0 && !baseChanged;
values[i] = {
path: matches ? path : name,
value: matches ? value : v,
base: v
};
} else {
values[i] = v;
}
}
return values;
}
});
Polymer.Base._addFeature({
_addPropertyEffect: function (property, kind, effect) {
var prop = Polymer.Bind.addPropertyEffect(this, property, kind, effect);
prop.pathFn = this['_' + prop.kind + 'PathEffect'];
},
_prepEffects: function () {
Polymer.Bind.prepareModel(this);
this._addAnnotationEffects(this._notes);
},
_prepBindings: function () {
Polymer.Bind.createBindings(this);
},
_addPropertyEffects: function (properties) {
if (properties) {
for (var p in properties) {
var prop = properties[p];
if (prop.observer) {
this._addObserverEffect(p, prop.observer);
}
if (prop.computed) {
prop.readOnly = true;
this._addComputedEffect(p, prop.computed);
}
if (prop.notify) {
this._addPropertyEffect(p, 'notify', { event: Polymer.CaseMap.camelToDashCase(p) + '-changed' });
}
if (prop.reflectToAttribute) {
var attr = Polymer.CaseMap.camelToDashCase(p);
if (attr[0] === '-') {
this._warn(this._logf('_addPropertyEffects', 'Property ' + p + ' cannot be reflected to attribute ' + attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property instead.'));
} else {
this._addPropertyEffect(p, 'reflect', { attribute: attr });
}
}
if (prop.readOnly) {
Polymer.Bind.ensurePropertyEffects(this, p);
}
}
}
},
_addComputedEffect: function (name, expression) {
var sig = this._parseMethod(expression);
var dynamicFn = sig.dynamicFn;
for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
this._addPropertyEffect(arg.model, 'compute', {
method: sig.method,
args: sig.args,
trigger: arg,
name: name,
dynamicFn: dynamicFn
});
}
if (dynamicFn) {
this._addPropertyEffect(sig.method, 'compute', {
method: sig.method,
args: sig.args,
trigger: null,
name: name,
dynamicFn: dynamicFn
});
}
},
_addObserverEffect: function (property, observer) {
this._addPropertyEffect(property, 'observer', {
method: observer,
property: property
});
},
_addComplexObserverEffects: function (observers) {
if (observers) {
for (var i = 0, o; i < observers.length && (o = observers[i]); i++) {
this._addComplexObserverEffect(o);
}
}
},
_addComplexObserverEffect: function (observer) {
var sig = this._parseMethod(observer);
if (!sig) {
throw new Error('Malformed observer expression \'' + observer + '\'');
}
var dynamicFn = sig.dynamicFn;
for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
this._addPropertyEffect(arg.model, 'complexObserver', {
method: sig.method,
args: sig.args,
trigger: arg,
dynamicFn: dynamicFn
});
}
if (dynamicFn) {
this._addPropertyEffect(sig.method, 'complexObserver', {
method: sig.method,
args: sig.args,
trigger: null,
dynamicFn: dynamicFn
});
}
},
_addAnnotationEffects: function (notes) {
for (var i = 0, note; i < notes.length && (note = notes[i]); i++) {
var b$ = note.bindings;
for (var j = 0, binding; j < b$.length && (binding = b$[j]); j++) {
this._addAnnotationEffect(binding, i);
}
}
},
_addAnnotationEffect: function (note, index) {
if (Polymer.Bind._shouldAddListener(note)) {
Polymer.Bind._addAnnotatedListener(this, index, note.name, note.parts[0].value, note.parts[0].event, note.parts[0].negate);
}
for (var i = 0; i < note.parts.length; i++) {
var part = note.parts[i];
if (part.signature) {
this._addAnnotatedComputationEffect(note, part, index);
} else if (!part.literal) {
if (note.kind === 'attribute' && note.name[0] === '-') {
this._warn(this._logf('_addAnnotationEffect', 'Cannot set attribute ' + note.name + ' because "-" is not a valid attribute starting character'));
} else {
this._addPropertyEffect(part.model, 'annotation', {
kind: note.kind,
index: index,
name: note.name,
propertyName: note.propertyName,
value: part.value,
isCompound: note.isCompound,
compoundIndex: part.compoundIndex,
event: part.event,
customEvent: part.customEvent,
negate: part.negate
});
}
}
}
},
_addAnnotatedComputationEffect: function (note, part, index) {
var sig = part.signature;
if (sig.static) {
this.__addAnnotatedComputationEffect('__static__', index, note, part, null);
} else {
for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
if (!arg.literal) {
this.__addAnnotatedComputationEffect(arg.model, index, note, part, arg);
}
}
if (sig.dynamicFn) {
this.__addAnnotatedComputationEffect(sig.method, index, note, part, null);
}
}
},
__addAnnotatedComputationEffect: function (property, index, note, part, trigger) {
this._addPropertyEffect(property, 'annotatedComputation', {
index: index,
isCompound: note.isCompound,
compoundIndex: part.compoundIndex,
kind: note.kind,
name: note.name,
negate: part.negate,
method: part.signature.method,
args: part.signature.args,
trigger: trigger,
dynamicFn: part.signature.dynamicFn
});
},
_parseMethod: function (expression) {
var m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
if (m) {
var sig = {
method: m[1],
static: true
};
if (this.getPropertyInfo(sig.method) !== Polymer.nob) {
sig.static = false;
sig.dynamicFn = true;
}
if (m[2].trim()) {
var args = m[2].replace(/\\,/g, '&comma;').split(',');
return this._parseArgs(args, sig);
} else {
sig.args = Polymer.nar;
return sig;
}
}
},
_parseArgs: function (argList, sig) {
sig.args = argList.map(function (rawArg) {
var arg = this._parseArg(rawArg);
if (!arg.literal) {
sig.static = false;
}
return arg;
}, this);
return sig;
},
_parseArg: function (rawArg) {
var arg = rawArg.trim().replace(/&comma;/g, ',').replace(/\\(.)/g, '$1');
var a = { name: arg };
var fc = arg[0];
if (fc === '-') {
fc = arg[1];
}
if (fc >= '0' && fc <= '9') {
fc = '#';
}
switch (fc) {
case '\'':
case '"':
a.value = arg.slice(1, -1);
a.literal = true;
break;
case '#':
a.value = Number(arg);
a.literal = true;
break;
}
if (!a.literal) {
a.model = this._modelForPath(arg);
a.structured = arg.indexOf('.') > 0;
if (a.structured) {
a.wildcard = arg.slice(-2) == '.*';
if (a.wildcard) {
a.name = arg.slice(0, -2);
}
}
}
return a;
},
_marshalInstanceEffects: function () {
Polymer.Bind.prepareInstance(this);
if (this._bindListeners) {
Polymer.Bind.setupBindListeners(this);
}
},
_applyEffectValue: function (info, value) {
var node = this._nodes[info.index];
var property = info.name;
if (info.isCompound) {
var storage = node.__compoundStorage__[property];
storage[info.compoundIndex] = value;
value = storage.join('');
}
if (info.kind == 'attribute') {
this.serializeValueToAttribute(value, property, node);
} else {
if (property === 'className') {
value = this._scopeElementClass(node, value);
}
if (property === 'textContent' || node.localName == 'input' && property == 'value') {
value = value == undefined ? '' : value;
}
var pinfo;
if (!node._propertyInfo || !(pinfo = node._propertyInfo[property]) || !pinfo.readOnly) {
this.__setProperty(property, value, false, node);
}
}
},
_executeStaticEffects: function () {
if (this._propertyEffects && this._propertyEffects.__static__) {
this._effectEffects('__static__', null, this._propertyEffects.__static__);
}
}
});
(function () {
var usePolyfillProto = Polymer.Settings.usePolyfillProto;
Polymer.Base._addFeature({
_setupConfigure: function (initialConfig) {
this._config = {};
this._handlers = [];
this._aboveConfig = null;
if (initialConfig) {
for (var i in initialConfig) {
if (initialConfig[i] !== undefined) {
this._config[i] = initialConfig[i];
}
}
}
},
_marshalAttributes: function () {
this._takeAttributesToModel(this._config);
},
_attributeChangedImpl: function (name) {
var model = this._clientsReadied ? this : this._config;
this._setAttributeToProperty(model, name);
},
_configValue: function (name, value) {
var info = this._propertyInfo[name];
if (!info || !info.readOnly) {
this._config[name] = value;
}
},
_beforeClientsReady: function () {
this._configure();
},
_configure: function () {
this._configureAnnotationReferences();
this._aboveConfig = this.mixin({}, this._config);
var config = {};
for (var i = 0; i < this.behaviors.length; i++) {
this._configureProperties(this.behaviors[i].properties, config);
}
this._configureProperties(this.properties, config);
this.mixin(config, this._aboveConfig);
this._config = config;
if (this._clients && this._clients.length) {
this._distributeConfig(this._config);
}
},
_configureProperties: function (properties, config) {
for (var i in properties) {
var c = properties[i];
if (!usePolyfillProto && this.hasOwnProperty(i) && this._propertyEffects && this._propertyEffects[i]) {
config[i] = this[i];
delete this[i];
} else if (c.value !== undefined) {
var value = c.value;
if (typeof value == 'function') {
value = value.call(this, this._config);
}
config[i] = value;
}
}
},
_distributeConfig: function (config) {
var fx$ = this._propertyEffects;
if (fx$) {
for (var p in config) {
var fx = fx$[p];
if (fx) {
for (var i = 0, l = fx.length, x; i < l && (x = fx[i]); i++) {
if (x.kind === 'annotation' && !x.isCompound) {
var node = this._nodes[x.effect.index];
var name = x.effect.propertyName;
var isAttr = x.effect.kind == 'attribute';
var hasEffect = node._propertyEffects && node._propertyEffects[name];
if (node._configValue && (hasEffect || !isAttr)) {
var value = p === x.effect.value ? config[p] : this._get(x.effect.value, config);
if (isAttr) {
value = node.deserialize(this.serialize(value), node._propertyInfo[name].type);
}
node._configValue(name, value);
}
}
}
}
}
}
},
_afterClientsReady: function () {
this._executeStaticEffects();
this._applyConfig(this._config, this._aboveConfig);
this._flushHandlers();
},
_applyConfig: function (config, aboveConfig) {
for (var n in config) {
if (this[n] === undefined) {
this.__setProperty(n, config[n], n in aboveConfig);
}
}
},
_notifyListener: function (fn, e) {
if (!Polymer.Bind._isEventBogus(e, e.target)) {
var value, path;
if (e.detail) {
value = e.detail.value;
path = e.detail.path;
}
if (!this._clientsReadied) {
this._queueHandler([
fn,
e.target,
value,
path
]);
} else {
return fn.call(this, e.target, value, path);
}
}
},
_queueHandler: function (args) {
this._handlers.push(args);
},
_flushHandlers: function () {
var h$ = this._handlers;
for (var i = 0, l = h$.length, h; i < l && (h = h$[i]); i++) {
h[0].call(this, h[1], h[2], h[3]);
}
this._handlers = [];
}
});
}());
(function () {
'use strict';
Polymer.Base._addFeature({
notifyPath: function (path, value, fromAbove) {
var info = {};
this._get(path, this, info);
if (info.path) {
this._notifyPath(info.path, value, fromAbove);
}
},
_notifyPath: function (path, value, fromAbove) {
var old = this._propertySetter(path, value);
if (old !== value && (old === old || value === value)) {
this._pathEffector(path, value);
if (!fromAbove) {
this._notifyPathUp(path, value);
}
return true;
}
},
_getPathParts: function (path) {
if (Array.isArray(path)) {
var parts = [];
for (var i = 0; i < path.length; i++) {
var args = path[i].toString().split('.');
for (var j = 0; j < args.length; j++) {
parts.push(args[j]);
}
}
return parts;
} else {
return path.toString().split('.');
}
},
set: function (path, value, root) {
var prop = root || this;
var parts = this._getPathParts(path);
var array;
var last = parts[parts.length - 1];
if (parts.length > 1) {
for (var i = 0; i < parts.length - 1; i++) {
var part = parts[i];
if (array && part[0] == '#') {
prop = Polymer.Collection.get(array).getItem(part);
} else {
prop = prop[part];
if (array && parseInt(part, 10) == part) {
parts[i] = Polymer.Collection.get(array).getKey(prop);
}
}
if (!prop) {
return;
}
array = Array.isArray(prop) ? prop : null;
}
if (array) {
var coll = Polymer.Collection.get(array);
var old, key;
if (last[0] == '#') {
key = last;
old = coll.getItem(key);
last = array.indexOf(old);
coll.setItem(key, value);
} else if (parseInt(last, 10) == last) {
old = prop[last];
key = coll.getKey(old);
parts[i] = key;
coll.setItem(key, value);
}
}
prop[last] = value;
if (!root) {
this._notifyPath(parts.join('.'), value);
}
} else {
prop[path] = value;
}
},
get: function (path, root) {
return this._get(path, root);
},
_get: function (path, root, info) {
var prop = root || this;
var parts = this._getPathParts(path);
var array;
for (var i = 0; i < parts.length; i++) {
if (!prop) {
return;
}
var part = parts[i];
if (array && part[0] == '#') {
prop = Polymer.Collection.get(array).getItem(part);
} else {
prop = prop[part];
if (info && array && parseInt(part, 10) == part) {
parts[i] = Polymer.Collection.get(array).getKey(prop);
}
}
array = Array.isArray(prop) ? prop : null;
}
if (info) {
info.path = parts.join('.');
}
return prop;
},
_pathEffector: function (path, value) {
var model = this._modelForPath(path);
var fx$ = this._propertyEffects && this._propertyEffects[model];
if (fx$) {
for (var i = 0, fx; i < fx$.length && (fx = fx$[i]); i++) {
var fxFn = fx.pathFn;
if (fxFn) {
fxFn.call(this, path, value, fx.effect);
}
}
}
if (this._boundPaths) {
this._notifyBoundPaths(path, value);
}
},
_annotationPathEffect: function (path, value, effect) {
if (effect.value === path || effect.value.indexOf(path + '.') === 0) {
Polymer.Bind._annotationEffect.call(this, path, value, effect);
} else if (path.indexOf(effect.value + '.') === 0 && !effect.negate) {
var node = this._nodes[effect.index];
if (node && node._notifyPath) {
var p = this._fixPath(effect.name, effect.value, path);
node._notifyPath(p, value, true);
}
}
},
_complexObserverPathEffect: function (path, value, effect) {
if (this._pathMatchesEffect(path, effect)) {
Polymer.Bind._complexObserverEffect.call(this, path, value, effect);
}
},
_computePathEffect: function (path, value, effect) {
if (this._pathMatchesEffect(path, effect)) {
Polymer.Bind._computeEffect.call(this, path, value, effect);
}
},
_annotatedComputationPathEffect: function (path, value, effect) {
if (this._pathMatchesEffect(path, effect)) {
Polymer.Bind._annotatedComputationEffect.call(this, path, value, effect);
}
},
_pathMatchesEffect: function (path, effect) {
var effectArg = effect.trigger.name;
return effectArg == path || effectArg.indexOf(path + '.') === 0 || effect.trigger.wildcard && path.indexOf(effectArg) === 0;
},
linkPaths: function (to, from) {
this._boundPaths = this._boundPaths || {};
if (from) {
this._boundPaths[to] = from;
} else {
this.unlinkPaths(to);
}
},
unlinkPaths: function (path) {
if (this._boundPaths) {
delete this._boundPaths[path];
}
},
_notifyBoundPaths: function (path, value) {
for (var a in this._boundPaths) {
var b = this._boundPaths[a];
if (path.indexOf(a + '.') == 0) {
this._notifyPath(this._fixPath(b, a, path), value);
} else if (path.indexOf(b + '.') == 0) {
this._notifyPath(this._fixPath(a, b, path), value);
}
}
},
_fixPath: function (property, root, path) {
return property + path.slice(root.length);
},
_notifyPathUp: function (path, value) {
var rootName = this._modelForPath(path);
var dashCaseName = Polymer.CaseMap.camelToDashCase(rootName);
var eventName = dashCaseName + this._EVENT_CHANGED;
this.fire(eventName, {
path: path,
value: value
}, {
bubbles: false,
_useCache: true
});
},
_modelForPath: function (path) {
var dot = path.indexOf('.');
return dot < 0 ? path : path.slice(0, dot);
},
_EVENT_CHANGED: '-changed',
notifySplices: function (path, splices) {
var info = {};
var array = this._get(path, this, info);
this._notifySplices(array, info.path, splices);
},
_notifySplices: function (array, path, splices) {
var change = {
keySplices: Polymer.Collection.applySplices(array, splices),
indexSplices: splices
};
if (!array.hasOwnProperty('splices')) {
Object.defineProperty(array, 'splices', {
configurable: true,
writable: true
});
}
array.splices = change;
this._notifyPath(path + '.splices', change);
this._notifyPath(path + '.length', array.length);
change.keySplices = null;
change.indexSplices = null;
},
_notifySplice: function (array, path, index, added, removed) {
this._notifySplices(array, path, [{
index: index,
addedCount: added,
removed: removed,
object: array,
type: 'splice'
}]);
},
push: function (path) {
var info = {};
var array = this._get(path, this, info);
var args = Array.prototype.slice.call(arguments, 1);
var len = array.length;
var ret = array.push.apply(array, args);
if (args.length) {
this._notifySplice(array, info.path, len, args.length, []);
}
return ret;
},
pop: function (path) {
var info = {};
var array = this._get(path, this, info);
var hadLength = Boolean(array.length);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.pop.apply(array, args);
if (hadLength) {
this._notifySplice(array, info.path, array.length, 0, [ret]);
}
return ret;
},
splice: function (path, start) {
var info = {};
var array = this._get(path, this, info);
if (start < 0) {
start = array.length - Math.floor(-start);
} else {
start = Math.floor(start);
}
if (!start) {
start = 0;
}
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.splice.apply(array, args);
var addedCount = Math.max(args.length - 2, 0);
if (addedCount || ret.length) {
this._notifySplice(array, info.path, start, addedCount, ret);
}
return ret;
},
shift: function (path) {
var info = {};
var array = this._get(path, this, info);
var hadLength = Boolean(array.length);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.shift.apply(array, args);
if (hadLength) {
this._notifySplice(array, info.path, 0, 0, [ret]);
}
return ret;
},
unshift: function (path) {
var info = {};
var array = this._get(path, this, info);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.unshift.apply(array, args);
if (args.length) {
this._notifySplice(array, info.path, 0, args.length, []);
}
return ret;
},
prepareModelNotifyPath: function (model) {
this.mixin(model, {
fire: Polymer.Base.fire,
_getEvent: Polymer.Base._getEvent,
__eventCache: Polymer.Base.__eventCache,
notifyPath: Polymer.Base.notifyPath,
_get: Polymer.Base._get,
_EVENT_CHANGED: Polymer.Base._EVENT_CHANGED,
_notifyPath: Polymer.Base._notifyPath,
_notifyPathUp: Polymer.Base._notifyPathUp,
_pathEffector: Polymer.Base._pathEffector,
_annotationPathEffect: Polymer.Base._annotationPathEffect,
_complexObserverPathEffect: Polymer.Base._complexObserverPathEffect,
_annotatedComputationPathEffect: Polymer.Base._annotatedComputationPathEffect,
_computePathEffect: Polymer.Base._computePathEffect,
_modelForPath: Polymer.Base._modelForPath,
_pathMatchesEffect: Polymer.Base._pathMatchesEffect,
_notifyBoundPaths: Polymer.Base._notifyBoundPaths,
_getPathParts: Polymer.Base._getPathParts
});
}
});
}());
Polymer.Base._addFeature({
resolveUrl: function (url) {
var module = Polymer.DomModule.import(this.is);
var root = '';
if (module) {
var assetPath = module.getAttribute('assetpath') || '';
root = Polymer.ResolveUrl.resolveUrl(assetPath, module.ownerDocument.baseURI);
}
return Polymer.ResolveUrl.resolveUrl(url, root);
}
});
Polymer.CssParse = function () {
return {
parse: function (text) {
text = this._clean(text);
return this._parseCss(this._lex(text), text);
},
_clean: function (cssText) {
return cssText.replace(this._rx.comments, '').replace(this._rx.port, '');
},
_lex: function (text) {
var root = {
start: 0,
end: text.length
};
var n = root;
for (var i = 0, l = text.length; i < l; i++) {
switch (text[i]) {
case this.OPEN_BRACE:
if (!n.rules) {
n.rules = [];
}
var p = n;
var previous = p.rules[p.rules.length - 1];
n = {
start: i + 1,
parent: p,
previous: previous
};
p.rules.push(n);
break;
case this.CLOSE_BRACE:
n.end = i + 1;
n = n.parent || root;
break;
}
}
return root;
},
_parseCss: function (node, text) {
var t = text.substring(node.start, node.end - 1);
node.parsedCssText = node.cssText = t.trim();
if (node.parent) {
var ss = node.previous ? node.previous.end : node.parent.start;
t = text.substring(ss, node.start - 1);
t = this._expandUnicodeEscapes(t);
t = t.replace(this._rx.multipleSpaces, ' ');
t = t.substring(t.lastIndexOf(';') + 1);
var s = node.parsedSelector = node.selector = t.trim();
node.atRule = s.indexOf(this.AT_START) === 0;
if (node.atRule) {
if (s.indexOf(this.MEDIA_START) === 0) {
node.type = this.types.MEDIA_RULE;
} else if (s.match(this._rx.keyframesRule)) {
node.type = this.types.KEYFRAMES_RULE;
node.keyframesName = node.selector.split(this._rx.multipleSpaces).pop();
}
} else {
if (s.indexOf(this.VAR_START) === 0) {
node.type = this.types.MIXIN_RULE;
} else {
node.type = this.types.STYLE_RULE;
}
}
}
var r$ = node.rules;
if (r$) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
this._parseCss(r, text);
}
}
return node;
},
_expandUnicodeEscapes: function (s) {
return s.replace(/\\([0-9a-f]{1,6})\s/gi, function () {
var code = arguments[1], repeat = 6 - code.length;
while (repeat--) {
code = '0' + code;
}
return '\\' + code;
});
},
stringify: function (node, preserveProperties, text) {
text = text || '';
var cssText = '';
if (node.cssText || node.rules) {
var r$ = node.rules;
if (r$ && (preserveProperties || !this._hasMixinRules(r$))) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
cssText = this.stringify(r, preserveProperties, cssText);
}
} else {
cssText = preserveProperties ? node.cssText : this.removeCustomProps(node.cssText);
cssText = cssText.trim();
if (cssText) {
cssText = '  ' + cssText + '\n';
}
}
}
if (cssText) {
if (node.selector) {
text += node.selector + ' ' + this.OPEN_BRACE + '\n';
}
text += cssText;
if (node.selector) {
text += this.CLOSE_BRACE + '\n\n';
}
}
return text;
},
_hasMixinRules: function (rules) {
return rules[0].selector.indexOf(this.VAR_START) === 0;
},
removeCustomProps: function (cssText) {
cssText = this.removeCustomPropAssignment(cssText);
return this.removeCustomPropApply(cssText);
},
removeCustomPropAssignment: function (cssText) {
return cssText.replace(this._rx.customProp, '').replace(this._rx.mixinProp, '');
},
removeCustomPropApply: function (cssText) {
return cssText.replace(this._rx.mixinApply, '').replace(this._rx.varApply, '');
},
types: {
STYLE_RULE: 1,
KEYFRAMES_RULE: 7,
MEDIA_RULE: 4,
MIXIN_RULE: 1000
},
OPEN_BRACE: '{',
CLOSE_BRACE: '}',
_rx: {
comments: /\/\*[^*]*\*+([^\/*][^*]*\*+)*\//gim,
port: /@import[^;]*;/gim,
customProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
mixinProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
mixinApply: /@apply[\s]*\([^)]*?\)[\s]*(?:[;\n]|$)?/gim,
varApply: /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
keyframesRule: /^@[^\s]*keyframes/,
multipleSpaces: /\s+/g
},
VAR_START: '--',
MEDIA_START: '@media',
AT_START: '@'
};
}();
Polymer.StyleUtil = function () {
return {
MODULE_STYLES_SELECTOR: 'style, link[rel=import][type~=css], template',
INCLUDE_ATTR: 'include',
toCssText: function (rules, callback, preserveProperties) {
if (typeof rules === 'string') {
rules = this.parser.parse(rules);
}
if (callback) {
this.forEachRule(rules, callback);
}
return this.parser.stringify(rules, preserveProperties);
},
forRulesInStyles: function (styles, styleRuleCallback, keyframesRuleCallback) {
if (styles) {
for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
this.forEachRule(this.rulesForStyle(s), styleRuleCallback, keyframesRuleCallback);
}
}
},
rulesForStyle: function (style) {
if (!style.__cssRules && style.textContent) {
style.__cssRules = this.parser.parse(style.textContent);
}
return style.__cssRules;
},
isKeyframesSelector: function (rule) {
return rule.parent && rule.parent.type === this.ruleTypes.KEYFRAMES_RULE;
},
forEachRule: function (node, styleRuleCallback, keyframesRuleCallback) {
if (!node) {
return;
}
var skipRules = false;
if (node.type === this.ruleTypes.STYLE_RULE) {
styleRuleCallback(node);
} else if (keyframesRuleCallback && node.type === this.ruleTypes.KEYFRAMES_RULE) {
keyframesRuleCallback(node);
} else if (node.type === this.ruleTypes.MIXIN_RULE) {
skipRules = true;
}
var r$ = node.rules;
if (r$ && !skipRules) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
this.forEachRule(r, styleRuleCallback, keyframesRuleCallback);
}
}
},
applyCss: function (cssText, moniker, target, contextNode) {
var style = this.createScopeStyle(cssText, moniker);
target = target || document.head;
var after = contextNode && contextNode.nextSibling || target.firstChild;
this.__lastHeadApplyNode = style;
return target.insertBefore(style, after);
},
createScopeStyle: function (cssText, moniker) {
var style = document.createElement('style');
if (moniker) {
style.setAttribute('scope', moniker);
}
style.textContent = cssText;
return style;
},
__lastHeadApplyNode: null,
applyStylePlaceHolder: function (moniker) {
var placeHolder = document.createComment(' Shady DOM styles for ' + moniker + ' ');
var after = this.__lastHeadApplyNode ? this.__lastHeadApplyNode.nextSibling : null;
var scope = document.head;
scope.insertBefore(placeHolder, after || scope.firstChild);
this.__lastHeadApplyNode = placeHolder;
return placeHolder;
},
cssFromModules: function (moduleIds, warnIfNotFound) {
var modules = moduleIds.trim().split(' ');
var cssText = '';
for (var i = 0; i < modules.length; i++) {
cssText += this.cssFromModule(modules[i], warnIfNotFound);
}
return cssText;
},
cssFromModule: function (moduleId, warnIfNotFound) {
var m = Polymer.DomModule.import(moduleId);
if (m && !m._cssText) {
m._cssText = this.cssFromElement(m);
}
if (!m && warnIfNotFound) {
console.warn('Could not find style data in module named', moduleId);
}
return m && m._cssText || '';
},
cssFromElement: function (element) {
var cssText = '';
var content = element.content || element;
var e$ = Polymer.TreeApi.arrayCopy(content.querySelectorAll(this.MODULE_STYLES_SELECTOR));
for (var i = 0, e; i < e$.length; i++) {
e = e$[i];
if (e.localName === 'template') {
cssText += this.cssFromElement(e);
} else {
if (e.localName === 'style') {
var include = e.getAttribute(this.INCLUDE_ATTR);
if (include) {
cssText += this.cssFromModules(include, true);
}
e = e.__appliedElement || e;
e.parentNode.removeChild(e);
cssText += this.resolveCss(e.textContent, element.ownerDocument);
} else if (e.import && e.import.body) {
cssText += this.resolveCss(e.import.body.textContent, e.import);
}
}
}
return cssText;
},
resolveCss: Polymer.ResolveUrl.resolveCss,
parser: Polymer.CssParse,
ruleTypes: Polymer.CssParse.types
};
}();
Polymer.StyleTransformer = function () {
var nativeShadow = Polymer.Settings.useNativeShadow;
var styleUtil = Polymer.StyleUtil;
var api = {
dom: function (node, scope, useAttr, shouldRemoveScope) {
this._transformDom(node, scope || '', useAttr, shouldRemoveScope);
},
_transformDom: function (node, selector, useAttr, shouldRemoveScope) {
if (node.setAttribute) {
this.element(node, selector, useAttr, shouldRemoveScope);
}
var c$ = Polymer.dom(node).childNodes;
for (var i = 0; i < c$.length; i++) {
this._transformDom(c$[i], selector, useAttr, shouldRemoveScope);
}
},
element: function (element, scope, useAttr, shouldRemoveScope) {
if (useAttr) {
if (shouldRemoveScope) {
element.removeAttribute(SCOPE_NAME);
} else {
element.setAttribute(SCOPE_NAME, scope);
}
} else {
if (scope) {
if (element.classList) {
if (shouldRemoveScope) {
element.classList.remove(SCOPE_NAME);
element.classList.remove(scope);
} else {
element.classList.add(SCOPE_NAME);
element.classList.add(scope);
}
} else if (element.getAttribute) {
var c = element.getAttribute(CLASS);
if (shouldRemoveScope) {
if (c) {
element.setAttribute(CLASS, c.replace(SCOPE_NAME, '').replace(scope, ''));
}
} else {
element.setAttribute(CLASS, (c ? c + ' ' : '') + SCOPE_NAME + ' ' + scope);
}
}
}
}
},
elementStyles: function (element, callback) {
var styles = element._styles;
var cssText = '';
for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
var rules = styleUtil.rulesForStyle(s);
cssText += nativeShadow ? styleUtil.toCssText(rules, callback) : this.css(rules, element.is, element.extends, callback, element._scopeCssViaAttr) + '\n\n';
}
return cssText.trim();
},
css: function (rules, scope, ext, callback, useAttr) {
var hostScope = this._calcHostScope(scope, ext);
scope = this._calcElementScope(scope, useAttr);
var self = this;
return styleUtil.toCssText(rules, function (rule) {
if (!rule.isScoped) {
self.rule(rule, scope, hostScope);
rule.isScoped = true;
}
if (callback) {
callback(rule, scope, hostScope);
}
});
},
_calcElementScope: function (scope, useAttr) {
if (scope) {
return useAttr ? CSS_ATTR_PREFIX + scope + CSS_ATTR_SUFFIX : CSS_CLASS_PREFIX + scope;
} else {
return '';
}
},
_calcHostScope: function (scope, ext) {
return ext ? '[is=' + scope + ']' : scope;
},
rule: function (rule, scope, hostScope) {
this._transformRule(rule, this._transformComplexSelector, scope, hostScope);
},
_transformRule: function (rule, transformer, scope, hostScope) {
var p$ = rule.selector.split(COMPLEX_SELECTOR_SEP);
if (!styleUtil.isKeyframesSelector(rule)) {
for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
p$[i] = transformer.call(this, p, scope, hostScope);
}
}
rule.selector = rule.transformedSelector = p$.join(COMPLEX_SELECTOR_SEP);
},
_transformComplexSelector: function (selector, scope, hostScope) {
var stop = false;
var hostContext = false;
var self = this;
selector = selector.replace(CONTENT_START, HOST + ' $1');
selector = selector.replace(SIMPLE_SELECTOR_SEP, function (m, c, s) {
if (!stop) {
var info = self._transformCompoundSelector(s, c, scope, hostScope);
stop = stop || info.stop;
hostContext = hostContext || info.hostContext;
c = info.combinator;
s = info.value;
} else {
s = s.replace(SCOPE_JUMP, ' ');
}
return c + s;
});
if (hostContext) {
selector = selector.replace(HOST_CONTEXT_PAREN, function (m, pre, paren, post) {
return pre + paren + ' ' + hostScope + post + COMPLEX_SELECTOR_SEP + ' ' + pre + hostScope + paren + post;
});
}
return selector;
},
_transformCompoundSelector: function (selector, combinator, scope, hostScope) {
var jumpIndex = selector.search(SCOPE_JUMP);
var hostContext = false;
if (selector.indexOf(HOST_CONTEXT) >= 0) {
hostContext = true;
} else if (selector.indexOf(HOST) >= 0) {
selector = selector.replace(HOST_PAREN, function (m, host, paren) {
return hostScope + paren;
});
selector = selector.replace(HOST, hostScope);
} else if (jumpIndex !== 0) {
selector = scope ? this._transformSimpleSelector(selector, scope) : selector;
}
if (selector.indexOf(CONTENT) >= 0) {
combinator = '';
}
var stop;
if (jumpIndex >= 0) {
selector = selector.replace(SCOPE_JUMP, ' ');
stop = true;
}
return {
value: selector,
combinator: combinator,
stop: stop,
hostContext: hostContext
};
},
_transformSimpleSelector: function (selector, scope) {
var p$ = selector.split(PSEUDO_PREFIX);
p$[0] += scope;
return p$.join(PSEUDO_PREFIX);
},
documentRule: function (rule) {
rule.selector = rule.parsedSelector;
this.normalizeRootSelector(rule);
if (!nativeShadow) {
this._transformRule(rule, this._transformDocumentSelector);
}
},
normalizeRootSelector: function (rule) {
if (rule.selector === ROOT) {
rule.selector = 'body';
}
},
_transformDocumentSelector: function (selector) {
return selector.match(SCOPE_JUMP) ? this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR) : this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);
},
SCOPE_NAME: 'style-scope'
};
var SCOPE_NAME = api.SCOPE_NAME;
var SCOPE_DOC_SELECTOR = ':not([' + SCOPE_NAME + '])' + ':not(.' + SCOPE_NAME + ')';
var COMPLEX_SELECTOR_SEP = ',';
var SIMPLE_SELECTOR_SEP = /(^|[\s>+~]+)((?:\[.+?\]|[^\s>+~=\[])+)/g;
var HOST = ':host';
var ROOT = ':root';
var HOST_PAREN = /(:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/g;
var HOST_CONTEXT = ':host-context';
var HOST_CONTEXT_PAREN = /(.*)(?::host-context)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))(.*)/;
var CONTENT = '::content';
var SCOPE_JUMP = /::content|::shadow|\/deep\//;
var CSS_CLASS_PREFIX = '.';
var CSS_ATTR_PREFIX = '[' + SCOPE_NAME + '~=';
var CSS_ATTR_SUFFIX = ']';
var PSEUDO_PREFIX = ':';
var CLASS = 'class';
var CONTENT_START = new RegExp('^(' + CONTENT + ')');
return api;
}();
Polymer.StyleExtends = function () {
var styleUtil = Polymer.StyleUtil;
return {
hasExtends: function (cssText) {
return Boolean(cssText.match(this.rx.EXTEND));
},
transform: function (style) {
var rules = styleUtil.rulesForStyle(style);
var self = this;
styleUtil.forEachRule(rules, function (rule) {
self._mapRuleOntoParent(rule);
if (rule.parent) {
var m;
while (m = self.rx.EXTEND.exec(rule.cssText)) {
var extend = m[1];
var extendor = self._findExtendor(extend, rule);
if (extendor) {
self._extendRule(rule, extendor);
}
}
}
rule.cssText = rule.cssText.replace(self.rx.EXTEND, '');
});
return styleUtil.toCssText(rules, function (rule) {
if (rule.selector.match(self.rx.STRIP)) {
rule.cssText = '';
}
}, true);
},
_mapRuleOntoParent: function (rule) {
if (rule.parent) {
var map = rule.parent.map || (rule.parent.map = {});
var parts = rule.selector.split(',');
for (var i = 0, p; i < parts.length; i++) {
p = parts[i];
map[p.trim()] = rule;
}
return map;
}
},
_findExtendor: function (extend, rule) {
return rule.parent && rule.parent.map && rule.parent.map[extend] || this._findExtendor(extend, rule.parent);
},
_extendRule: function (target, source) {
if (target.parent !== source.parent) {
this._cloneAndAddRuleToParent(source, target.parent);
}
target.extends = target.extends || [];
target.extends.push(source);
source.selector = source.selector.replace(this.rx.STRIP, '');
source.selector = (source.selector && source.selector + ',\n') + target.selector;
if (source.extends) {
source.extends.forEach(function (e) {
this._extendRule(target, e);
}, this);
}
},
_cloneAndAddRuleToParent: function (rule, parent) {
rule = Object.create(rule);
rule.parent = parent;
if (rule.extends) {
rule.extends = rule.extends.slice();
}
parent.rules.push(rule);
},
rx: {
EXTEND: /@extends\(([^)]*)\)\s*?;/gim,
STRIP: /%[^,]*$/
}
};
}();
(function () {
var prepElement = Polymer.Base._prepElement;
var nativeShadow = Polymer.Settings.useNativeShadow;
var styleUtil = Polymer.StyleUtil;
var styleTransformer = Polymer.StyleTransformer;
var styleExtends = Polymer.StyleExtends;
Polymer.Base._addFeature({
_prepElement: function (element) {
if (this._encapsulateStyle) {
styleTransformer.element(element, this.is, this._scopeCssViaAttr);
}
prepElement.call(this, element);
},
_prepStyles: function () {
if (!nativeShadow) {
this._scopeStyle = styleUtil.applyStylePlaceHolder(this.is);
}
},
_prepShimStyles: function () {
if (this._template) {
if (this._encapsulateStyle === undefined) {
this._encapsulateStyle = !nativeShadow;
}
this._styles = this._collectStyles();
var cssText = styleTransformer.elementStyles(this);
this._prepStyleProperties();
if (!this._needsStyleProperties() && this._styles.length) {
styleUtil.applyCss(cssText, this.is, nativeShadow ? this._template.content : null, this._scopeStyle);
}
} else {
this._styles = [];
}
},
_collectStyles: function () {
var styles = [];
var cssText = '', m$ = this.styleModules;
if (m$) {
for (var i = 0, l = m$.length, m; i < l && (m = m$[i]); i++) {
cssText += styleUtil.cssFromModule(m);
}
}
cssText += styleUtil.cssFromModule(this.is);
var p = this._template && this._template.parentNode;
if (this._template && (!p || p.id.toLowerCase() !== this.is)) {
cssText += styleUtil.cssFromElement(this._template);
}
if (cssText) {
var style = document.createElement('style');
style.textContent = cssText;
if (styleExtends.hasExtends(style.textContent)) {
cssText = styleExtends.transform(style);
}
styles.push(style);
}
return styles;
},
_elementAdd: function (node) {
if (this._encapsulateStyle) {
if (node.__styleScoped) {
node.__styleScoped = false;
} else {
styleTransformer.dom(node, this.is, this._scopeCssViaAttr);
}
}
},
_elementRemove: function (node) {
if (this._encapsulateStyle) {
styleTransformer.dom(node, this.is, this._scopeCssViaAttr, true);
}
},
scopeSubtree: function (container, shouldObserve) {
if (nativeShadow) {
return;
}
var self = this;
var scopify = function (node) {
if (node.nodeType === Node.ELEMENT_NODE) {
var className = node.getAttribute('class');
node.setAttribute('class', self._scopeElementClass(node, className));
var n$ = node.querySelectorAll('*');
for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
className = n.getAttribute('class');
n.setAttribute('class', self._scopeElementClass(n, className));
}
}
};
scopify(container);
if (shouldObserve) {
var mo = new MutationObserver(function (mxns) {
for (var i = 0, m; i < mxns.length && (m = mxns[i]); i++) {
if (m.addedNodes) {
for (var j = 0; j < m.addedNodes.length; j++) {
scopify(m.addedNodes[j]);
}
}
}
});
mo.observe(container, {
childList: true,
subtree: true
});
return mo;
}
}
});
}());
Polymer.StyleProperties = function () {
'use strict';
var nativeShadow = Polymer.Settings.useNativeShadow;
var matchesSelector = Polymer.DomApi.matchesSelector;
var styleUtil = Polymer.StyleUtil;
var styleTransformer = Polymer.StyleTransformer;
return {
decorateStyles: function (styles) {
var self = this, props = {}, keyframes = [];
styleUtil.forRulesInStyles(styles, function (rule) {
self.decorateRule(rule);
self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);
}, function onKeyframesRule(rule) {
keyframes.push(rule);
});
styles._keyframes = keyframes;
var names = [];
for (var i in props) {
names.push(i);
}
return names;
},
decorateRule: function (rule) {
if (rule.propertyInfo) {
return rule.propertyInfo;
}
var info = {}, properties = {};
var hasProperties = this.collectProperties(rule, properties);
if (hasProperties) {
info.properties = properties;
rule.rules = null;
}
info.cssText = this.collectCssText(rule);
rule.propertyInfo = info;
return info;
},
collectProperties: function (rule, properties) {
var info = rule.propertyInfo;
if (info) {
if (info.properties) {
Polymer.Base.mixin(properties, info.properties);
return true;
}
} else {
var m, rx = this.rx.VAR_ASSIGN;
var cssText = rule.parsedCssText;
var any;
while (m = rx.exec(cssText)) {
properties[m[1]] = (m[2] || m[3]).trim();
any = true;
}
return any;
}
},
collectCssText: function (rule) {
return this.collectConsumingCssText(rule.parsedCssText);
},
collectConsumingCssText: function (cssText) {
return cssText.replace(this.rx.BRACKETED, '').replace(this.rx.VAR_ASSIGN, '');
},
collectPropertiesInCssText: function (cssText, props) {
var m;
while (m = this.rx.VAR_CAPTURE.exec(cssText)) {
props[m[1]] = true;
var def = m[2];
if (def && def.match(this.rx.IS_VAR)) {
props[def] = true;
}
}
},
reify: function (props) {
var names = Object.getOwnPropertyNames(props);
for (var i = 0, n; i < names.length; i++) {
n = names[i];
props[n] = this.valueForProperty(props[n], props);
}
},
valueForProperty: function (property, props) {
if (property) {
if (property.indexOf(';') >= 0) {
property = this.valueForProperties(property, props);
} else {
var self = this;
var fn = function (all, prefix, value, fallback) {
var propertyValue = self.valueForProperty(props[value], props) || (props[fallback] ? self.valueForProperty(props[fallback], props) : fallback);
return prefix + (propertyValue || '');
};
property = property.replace(this.rx.VAR_MATCH, fn);
}
}
return property && property.trim() || '';
},
valueForProperties: function (property, props) {
var parts = property.split(';');
for (var i = 0, p, m; i < parts.length; i++) {
if (p = parts[i]) {
m = p.match(this.rx.MIXIN_MATCH);
if (m) {
p = this.valueForProperty(props[m[1]], props);
} else {
var colon = p.indexOf(':');
if (colon !== -1) {
var pp = p.substring(colon);
pp = pp.trim();
pp = this.valueForProperty(pp, props) || pp;
p = p.substring(0, colon) + pp;
}
}
parts[i] = p && p.lastIndexOf(';') === p.length - 1 ? p.slice(0, -1) : p || '';
}
}
return parts.join(';');
},
applyProperties: function (rule, props) {
var output = '';
if (!rule.propertyInfo) {
this.decorateRule(rule);
}
if (rule.propertyInfo.cssText) {
output = this.valueForProperties(rule.propertyInfo.cssText, props);
}
rule.cssText = output;
},
applyKeyframeTransforms: function (rule, keyframeTransforms) {
var input = rule.cssText;
var output = rule.cssText;
if (rule.hasAnimations == null) {
rule.hasAnimations = this.rx.ANIMATION_MATCH.test(input);
}
if (rule.hasAnimations) {
var transform;
if (rule.keyframeNamesToTransform == null) {
rule.keyframeNamesToTransform = [];
for (var keyframe in keyframeTransforms) {
transform = keyframeTransforms[keyframe];
output = transform(input);
if (input !== output) {
input = output;
rule.keyframeNamesToTransform.push(keyframe);
}
}
} else {
for (var i = 0; i < rule.keyframeNamesToTransform.length; ++i) {
transform = keyframeTransforms[rule.keyframeNamesToTransform[i]];
input = transform(input);
}
output = input;
}
}
rule.cssText = output;
},
propertyDataFromStyles: function (styles, element) {
var props = {}, self = this;
var o = [], i = 0;
styleUtil.forRulesInStyles(styles, function (rule) {
if (!rule.propertyInfo) {
self.decorateRule(rule);
}
if (element && rule.propertyInfo.properties && matchesSelector.call(element, rule.transformedSelector || rule.parsedSelector)) {
self.collectProperties(rule, props);
addToBitMask(i, o);
}
i++;
});
return {
properties: props,
key: o
};
},
scopePropertiesFromStyles: function (styles) {
if (!styles._scopeStyleProperties) {
styles._scopeStyleProperties = this.selectedPropertiesFromStyles(styles, this.SCOPE_SELECTORS);
}
return styles._scopeStyleProperties;
},
hostPropertiesFromStyles: function (styles) {
if (!styles._hostStyleProperties) {
styles._hostStyleProperties = this.selectedPropertiesFromStyles(styles, this.HOST_SELECTORS);
}
return styles._hostStyleProperties;
},
selectedPropertiesFromStyles: function (styles, selectors) {
var props = {}, self = this;
styleUtil.forRulesInStyles(styles, function (rule) {
if (!rule.propertyInfo) {
self.decorateRule(rule);
}
for (var i = 0; i < selectors.length; i++) {
if (rule.parsedSelector === selectors[i]) {
self.collectProperties(rule, props);
return;
}
}
});
return props;
},
transformStyles: function (element, properties, scopeSelector) {
var self = this;
var hostSelector = styleTransformer._calcHostScope(element.is, element.extends);
var rxHostSelector = element.extends ? '\\' + hostSelector.slice(0, -1) + '\\]' : hostSelector;
var hostRx = new RegExp(this.rx.HOST_PREFIX + rxHostSelector + this.rx.HOST_SUFFIX);
var keyframeTransforms = this._elementKeyframeTransforms(element, scopeSelector);
return styleTransformer.elementStyles(element, function (rule) {
self.applyProperties(rule, properties);
if (!nativeShadow && !Polymer.StyleUtil.isKeyframesSelector(rule) && rule.cssText) {
self.applyKeyframeTransforms(rule, keyframeTransforms);
self._scopeSelector(rule, hostRx, hostSelector, element._scopeCssViaAttr, scopeSelector);
}
});
},
_elementKeyframeTransforms: function (element, scopeSelector) {
var keyframesRules = element._styles._keyframes;
var keyframeTransforms = {};
if (!nativeShadow && keyframesRules) {
for (var i = 0, keyframesRule = keyframesRules[i]; i < keyframesRules.length; keyframesRule = keyframesRules[++i]) {
this._scopeKeyframes(keyframesRule, scopeSelector);
keyframeTransforms[keyframesRule.keyframesName] = this._keyframesRuleTransformer(keyframesRule);
}
}
return keyframeTransforms;
},
_keyframesRuleTransformer: function (keyframesRule) {
return function (cssText) {
return cssText.replace(keyframesRule.keyframesNameRx, keyframesRule.transformedKeyframesName);
};
},
_scopeKeyframes: function (rule, scopeId) {
rule.keyframesNameRx = new RegExp(rule.keyframesName, 'g');
rule.transformedKeyframesName = rule.keyframesName + '-' + scopeId;
rule.transformedSelector = rule.transformedSelector || rule.selector;
rule.selector = rule.transformedSelector.replace(rule.keyframesName, rule.transformedKeyframesName);
},
_scopeSelector: function (rule, hostRx, hostSelector, viaAttr, scopeId) {
rule.transformedSelector = rule.transformedSelector || rule.selector;
var selector = rule.transformedSelector;
var scope = viaAttr ? '[' + styleTransformer.SCOPE_NAME + '~=' + scopeId + ']' : '.' + scopeId;
var parts = selector.split(',');
for (var i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {
parts[i] = p.match(hostRx) ? p.replace(hostSelector, scope) : scope + ' ' + p;
}
rule.selector = parts.join(',');
},
applyElementScopeSelector: function (element, selector, old, viaAttr) {
var c = viaAttr ? element.getAttribute(styleTransformer.SCOPE_NAME) : element.getAttribute('class') || '';
var v = old ? c.replace(old, selector) : (c ? c + ' ' : '') + this.XSCOPE_NAME + ' ' + selector;
if (c !== v) {
if (viaAttr) {
element.setAttribute(styleTransformer.SCOPE_NAME, v);
} else {
element.setAttribute('class', v);
}
}
},
applyElementStyle: function (element, properties, selector, style) {
var cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector);
var s = element._customStyle;
if (s && !nativeShadow && s !== style) {
s._useCount--;
if (s._useCount <= 0 && s.parentNode) {
s.parentNode.removeChild(s);
}
}
if (nativeShadow || (!style || !style.parentNode)) {
if (nativeShadow && element._customStyle) {
element._customStyle.textContent = cssText;
style = element._customStyle;
} else if (cssText) {
style = styleUtil.applyCss(cssText, selector, nativeShadow ? element.root : null, element._scopeStyle);
}
}
if (style) {
style._useCount = style._useCount || 0;
if (element._customStyle != style) {
style._useCount++;
}
element._customStyle = style;
}
return style;
},
mixinCustomStyle: function (props, customStyle) {
var v;
for (var i in customStyle) {
v = customStyle[i];
if (v || v === 0) {
props[i] = v;
}
}
},
rx: {
VAR_ASSIGN: /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\s}])|$)/gi,
MIXIN_MATCH: /(?:^|\W+)@apply[\s]*\(([^)]*)\)/i,
VAR_MATCH: /(^|\W+)var\([\s]*([^,)]*)[\s]*,?[\s]*((?:[^,()]*)|(?:[^;()]*\([^;)]*\)))[\s]*?\)/gi,
VAR_CAPTURE: /\([\s]*(--[^,\s)]*)(?:,[\s]*(--[^,\s)]*))?(?:\)|,)/gi,
ANIMATION_MATCH: /(animation\s*:)|(animation-name\s*:)/,
IS_VAR: /^--/,
BRACKETED: /\{[^}]*\}/g,
HOST_PREFIX: '(?:^|[^.#[:])',
HOST_SUFFIX: '($|[.:[\\s>+~])'
},
HOST_SELECTORS: [':host'],
SCOPE_SELECTORS: [':root'],
XSCOPE_NAME: 'x-scope'
};
function addToBitMask(n, bits) {
var o = parseInt(n / 32);
var v = 1 << n % 32;
bits[o] = (bits[o] || 0) | v;
}
}();
(function () {
Polymer.StyleCache = function () {
this.cache = {};
};
Polymer.StyleCache.prototype = {
MAX: 100,
store: function (is, data, keyValues, keyStyles) {
data.keyValues = keyValues;
data.styles = keyStyles;
var s$ = this.cache[is] = this.cache[is] || [];
s$.push(data);
if (s$.length > this.MAX) {
s$.shift();
}
},
retrieve: function (is, keyValues, keyStyles) {
var cache = this.cache[is];
if (cache) {
for (var i = cache.length - 1, data; i >= 0; i--) {
data = cache[i];
if (keyStyles === data.styles && this._objectsEqual(keyValues, data.keyValues)) {
return data;
}
}
}
},
clear: function () {
this.cache = {};
},
_objectsEqual: function (target, source) {
var t, s;
for (var i in target) {
t = target[i], s = source[i];
if (!(typeof t === 'object' && t ? this._objectsStrictlyEqual(t, s) : t === s)) {
return false;
}
}
if (Array.isArray(target)) {
return target.length === source.length;
}
return true;
},
_objectsStrictlyEqual: function (target, source) {
return this._objectsEqual(target, source) && this._objectsEqual(source, target);
}
};
}());
Polymer.StyleDefaults = function () {
var styleProperties = Polymer.StyleProperties;
var StyleCache = Polymer.StyleCache;
var api = {
_styles: [],
_properties: null,
customStyle: {},
_styleCache: new StyleCache(),
addStyle: function (style) {
this._styles.push(style);
this._properties = null;
},
get _styleProperties() {
if (!this._properties) {
styleProperties.decorateStyles(this._styles);
this._styles._scopeStyleProperties = null;
this._properties = styleProperties.scopePropertiesFromStyles(this._styles);
styleProperties.mixinCustomStyle(this._properties, this.customStyle);
styleProperties.reify(this._properties);
}
return this._properties;
},
_needsStyleProperties: function () {
},
_computeStyleProperties: function () {
return this._styleProperties;
},
updateStyles: function (properties) {
this._properties = null;
if (properties) {
Polymer.Base.mixin(this.customStyle, properties);
}
this._styleCache.clear();
for (var i = 0, s; i < this._styles.length; i++) {
s = this._styles[i];
s = s.__importElement || s;
s._apply();
}
}
};
return api;
}();
(function () {
'use strict';
var serializeValueToAttribute = Polymer.Base.serializeValueToAttribute;
var propertyUtils = Polymer.StyleProperties;
var styleTransformer = Polymer.StyleTransformer;
var styleDefaults = Polymer.StyleDefaults;
var nativeShadow = Polymer.Settings.useNativeShadow;
Polymer.Base._addFeature({
_prepStyleProperties: function () {
this._ownStylePropertyNames = this._styles && this._styles.length ? propertyUtils.decorateStyles(this._styles) : null;
},
customStyle: null,
getComputedStyleValue: function (property) {
return this._styleProperties && this._styleProperties[property] || getComputedStyle(this).getPropertyValue(property);
},
_setupStyleProperties: function () {
this.customStyle = {};
this._styleCache = null;
this._styleProperties = null;
this._scopeSelector = null;
this._ownStyleProperties = null;
this._customStyle = null;
},
_needsStyleProperties: function () {
return Boolean(this._ownStylePropertyNames && this._ownStylePropertyNames.length);
},
_beforeAttached: function () {
if (!this._scopeSelector && this._needsStyleProperties()) {
this._updateStyleProperties();
}
},
_findStyleHost: function () {
var e = this, root;
while (root = Polymer.dom(e).getOwnerRoot()) {
if (Polymer.isInstance(root.host)) {
return root.host;
}
e = root.host;
}
return styleDefaults;
},
_updateStyleProperties: function () {
var info, scope = this._findStyleHost();
if (!scope._styleCache) {
scope._styleCache = new Polymer.StyleCache();
}
var scopeData = propertyUtils.propertyDataFromStyles(scope._styles, this);
scopeData.key.customStyle = this.customStyle;
info = scope._styleCache.retrieve(this.is, scopeData.key, this._styles);
var scopeCached = Boolean(info);
if (scopeCached) {
this._styleProperties = info._styleProperties;
} else {
this._computeStyleProperties(scopeData.properties);
}
this._computeOwnStyleProperties();
if (!scopeCached) {
info = styleCache.retrieve(this.is, this._ownStyleProperties, this._styles);
}
var globalCached = Boolean(info) && !scopeCached;
var style = this._applyStyleProperties(info);
if (!scopeCached) {
style = style && nativeShadow ? style.cloneNode(true) : style;
info = {
style: style,
_scopeSelector: this._scopeSelector,
_styleProperties: this._styleProperties
};
scopeData.key.customStyle = {};
this.mixin(scopeData.key.customStyle, this.customStyle);
scope._styleCache.store(this.is, info, scopeData.key, this._styles);
if (!globalCached) {
styleCache.store(this.is, Object.create(info), this._ownStyleProperties, this._styles);
}
}
},
_computeStyleProperties: function (scopeProps) {
var scope = this._findStyleHost();
if (!scope._styleProperties) {
scope._computeStyleProperties();
}
var props = Object.create(scope._styleProperties);
this.mixin(props, propertyUtils.hostPropertiesFromStyles(this._styles));
scopeProps = scopeProps || propertyUtils.propertyDataFromStyles(scope._styles, this).properties;
this.mixin(props, scopeProps);
this.mixin(props, propertyUtils.scopePropertiesFromStyles(this._styles));
propertyUtils.mixinCustomStyle(props, this.customStyle);
propertyUtils.reify(props);
this._styleProperties = props;
},
_computeOwnStyleProperties: function () {
var props = {};
for (var i = 0, n; i < this._ownStylePropertyNames.length; i++) {
n = this._ownStylePropertyNames[i];
props[n] = this._styleProperties[n];
}
this._ownStyleProperties = props;
},
_scopeCount: 0,
_applyStyleProperties: function (info) {
var oldScopeSelector = this._scopeSelector;
this._scopeSelector = info ? info._scopeSelector : this.is + '-' + this.__proto__._scopeCount++;
var style = propertyUtils.applyElementStyle(this, this._styleProperties, this._scopeSelector, info && info.style);
if (!nativeShadow) {
propertyUtils.applyElementScopeSelector(this, this._scopeSelector, oldScopeSelector, this._scopeCssViaAttr);
}
return style;
},
serializeValueToAttribute: function (value, attribute, node) {
node = node || this;
if (attribute === 'class' && !nativeShadow) {
var host = node === this ? this.domHost || this.dataHost : this;
if (host) {
value = host._scopeElementClass(node, value);
}
}
node = this.shadyRoot && this.shadyRoot._hasDistributed ? Polymer.dom(node) : node;
serializeValueToAttribute.call(this, value, attribute, node);
},
_scopeElementClass: function (element, selector) {
if (!nativeShadow && !this._scopeCssViaAttr) {
selector = (selector ? selector + ' ' : '') + SCOPE_NAME + ' ' + this.is + (element._scopeSelector ? ' ' + XSCOPE_NAME + ' ' + element._scopeSelector : '');
}
return selector;
},
updateStyles: function (properties) {
if (this.isAttached) {
if (properties) {
this.mixin(this.customStyle, properties);
}
if (this._needsStyleProperties()) {
this._updateStyleProperties();
} else {
this._styleProperties = null;
}
if (this._styleCache) {
this._styleCache.clear();
}
this._updateRootStyles();
}
},
_updateRootStyles: function (root) {
root = root || this.root;
var c$ = Polymer.dom(root)._query(function (e) {
return e.shadyRoot || e.shadowRoot;
});
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.updateStyles) {
c.updateStyles();
}
}
}
});
Polymer.updateStyles = function (properties) {
styleDefaults.updateStyles(properties);
Polymer.Base._updateRootStyles(document);
};
var styleCache = new Polymer.StyleCache();
Polymer.customStyleCache = styleCache;
var SCOPE_NAME = styleTransformer.SCOPE_NAME;
var XSCOPE_NAME = propertyUtils.XSCOPE_NAME;
}());
Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepConstructor();
this._prepStyles();
},
_finishRegisterFeatures: function () {
this._prepTemplate();
this._prepShimStyles();
this._prepAnnotations();
this._prepEffects();
this._prepBehaviors();
this._prepPropertyInfo();
this._prepBindings();
this._prepShady();
},
_prepBehavior: function (b) {
this._addPropertyEffects(b.properties);
this._addComplexObserverEffects(b.observers);
this._addHostAttributes(b.hostAttributes);
},
_initFeatures: function () {
this._setupGestures();
this._setupConfigure();
this._setupStyleProperties();
this._setupDebouncers();
this._setupShady();
this._registerHost();
if (this._template) {
this._poolContent();
this._beginHosting();
this._stampTemplate();
this._endHosting();
this._marshalAnnotationReferences();
}
this._marshalInstanceEffects();
this._marshalBehaviors();
this._marshalHostAttributes();
this._marshalAttributes();
this._tryReady();
},
_marshalBehavior: function (b) {
if (b.listeners) {
this._listenListeners(b.listeners);
}
}
});
(function () {
var propertyUtils = Polymer.StyleProperties;
var styleUtil = Polymer.StyleUtil;
var cssParse = Polymer.CssParse;
var styleDefaults = Polymer.StyleDefaults;
var styleTransformer = Polymer.StyleTransformer;
Polymer({
is: 'custom-style',
extends: 'style',
_template: null,
properties: { include: String },
ready: function () {
this._tryApply();
},
attached: function () {
this._tryApply();
},
_tryApply: function () {
if (!this._appliesToDocument) {
if (this.parentNode && this.parentNode.localName !== 'dom-module') {
this._appliesToDocument = true;
var e = this.__appliedElement || this;
styleDefaults.addStyle(e);
if (e.textContent || this.include) {
this._apply(true);
} else {
var self = this;
var observer = new MutationObserver(function () {
observer.disconnect();
self._apply(true);
});
observer.observe(e, { childList: true });
}
}
}
},
_apply: function (deferProperties) {
var e = this.__appliedElement || this;
if (this.include) {
e.textContent = styleUtil.cssFromModules(this.include, true) + e.textContent;
}
if (e.textContent) {
styleUtil.forEachRule(styleUtil.rulesForStyle(e), function (rule) {
styleTransformer.documentRule(rule);
});
var self = this;
var fn = function fn() {
self._applyCustomProperties(e);
};
if (this._pendingApplyProperties) {
cancelAnimationFrame(this._pendingApplyProperties);
this._pendingApplyProperties = null;
}
if (deferProperties) {
this._pendingApplyProperties = requestAnimationFrame(fn);
} else {
fn();
}
}
},
_applyCustomProperties: function (element) {
this._computeStyleProperties();
var props = this._styleProperties;
var rules = styleUtil.rulesForStyle(element);
element.textContent = styleUtil.toCssText(rules, function (rule) {
var css = rule.cssText = rule.parsedCssText;
if (rule.propertyInfo && rule.propertyInfo.cssText) {
css = cssParse.removeCustomPropAssignment(css);
rule.cssText = propertyUtils.valueForProperties(css, props);
}
});
}
});
}());
Polymer.Templatizer = {
properties: { __hideTemplateChildren__: { observer: '_showHideChildren' } },
_instanceProps: Polymer.nob,
_parentPropPrefix: '_parent_',
templatize: function (template) {
this._templatized = template;
if (!template._content) {
template._content = template.content;
}
if (template._content._ctor) {
this.ctor = template._content._ctor;
this._prepParentProperties(this.ctor.prototype, template);
return;
}
var archetype = Object.create(Polymer.Base);
this._customPrepAnnotations(archetype, template);
this._prepParentProperties(archetype, template);
archetype._prepEffects();
this._customPrepEffects(archetype);
archetype._prepBehaviors();
archetype._prepPropertyInfo();
archetype._prepBindings();
archetype._notifyPathUp = this._notifyPathUpImpl;
archetype._scopeElementClass = this._scopeElementClassImpl;
archetype.listen = this._listenImpl;
archetype._showHideChildren = this._showHideChildrenImpl;
archetype.__setPropertyOrig = this.__setProperty;
archetype.__setProperty = this.__setPropertyImpl;
var _constructor = this._constructorImpl;
var ctor = function TemplateInstance(model, host) {
_constructor.call(this, model, host);
};
ctor.prototype = archetype;
archetype.constructor = ctor;
template._content._ctor = ctor;
this.ctor = ctor;
},
_getRootDataHost: function () {
return this.dataHost && this.dataHost._rootDataHost || this.dataHost;
},
_showHideChildrenImpl: function (hide) {
var c = this._children;
for (var i = 0; i < c.length; i++) {
var n = c[i];
if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
if (n.nodeType === Node.TEXT_NODE) {
if (hide) {
n.__polymerTextContent__ = n.textContent;
n.textContent = '';
} else {
n.textContent = n.__polymerTextContent__;
}
} else if (n.style) {
if (hide) {
n.__polymerDisplay__ = n.style.display;
n.style.display = 'none';
} else {
n.style.display = n.__polymerDisplay__;
}
}
}
n.__hideTemplateChildren__ = hide;
}
},
__setPropertyImpl: function (property, value, fromAbove, node) {
if (node && node.__hideTemplateChildren__ && property == 'textContent') {
property = '__polymerTextContent__';
}
this.__setPropertyOrig(property, value, fromAbove, node);
},
_debounceTemplate: function (fn) {
Polymer.dom.addDebouncer(this.debounce('_debounceTemplate', fn));
},
_flushTemplates: function () {
Polymer.dom.flush();
},
_customPrepEffects: function (archetype) {
var parentProps = archetype._parentProps;
for (var prop in parentProps) {
archetype._addPropertyEffect(prop, 'function', this._createHostPropEffector(prop));
}
for (prop in this._instanceProps) {
archetype._addPropertyEffect(prop, 'function', this._createInstancePropEffector(prop));
}
},
_customPrepAnnotations: function (archetype, template) {
archetype._template = template;
var c = template._content;
if (!c._notes) {
var rootDataHost = archetype._rootDataHost;
if (rootDataHost) {
Polymer.Annotations.prepElement = function () {
rootDataHost._prepElement();
};
}
c._notes = Polymer.Annotations.parseAnnotations(template);
Polymer.Annotations.prepElement = null;
this._processAnnotations(c._notes);
}
archetype._notes = c._notes;
archetype._parentProps = c._parentProps;
},
_prepParentProperties: function (archetype, template) {
var parentProps = this._parentProps = archetype._parentProps;
if (this._forwardParentProp && parentProps) {
var proto = archetype._parentPropProto;
var prop;
if (!proto) {
for (prop in this._instanceProps) {
delete parentProps[prop];
}
proto = archetype._parentPropProto = Object.create(null);
if (template != this) {
Polymer.Bind.prepareModel(proto);
Polymer.Base.prepareModelNotifyPath(proto);
}
for (prop in parentProps) {
var parentProp = this._parentPropPrefix + prop;
var effects = [
{
kind: 'function',
effect: this._createForwardPropEffector(prop),
fn: Polymer.Bind._functionEffect
},
{
kind: 'notify',
fn: Polymer.Bind._notifyEffect,
effect: { event: Polymer.CaseMap.camelToDashCase(parentProp) + '-changed' }
}
];
Polymer.Bind._createAccessors(proto, parentProp, effects);
}
}
var self = this;
if (template != this) {
Polymer.Bind.prepareInstance(template);
template._forwardParentProp = function (source, value) {
self._forwardParentProp(source, value);
};
}
this._extendTemplate(template, proto);
template._pathEffector = function (path, value, fromAbove) {
return self._pathEffectorImpl(path, value, fromAbove);
};
}
},
_createForwardPropEffector: function (prop) {
return function (source, value) {
this._forwardParentProp(prop, value);
};
},
_createHostPropEffector: function (prop) {
var prefix = this._parentPropPrefix;
return function (source, value) {
this.dataHost._templatized[prefix + prop] = value;
};
},
_createInstancePropEffector: function (prop) {
return function (source, value, old, fromAbove) {
if (!fromAbove) {
this.dataHost._forwardInstanceProp(this, prop, value);
}
};
},
_extendTemplate: function (template, proto) {
var n$ = Object.getOwnPropertyNames(proto);
if (proto._propertySetter) {
template._propertySetter = proto._propertySetter;
}
for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
var val = template[n];
var pd = Object.getOwnPropertyDescriptor(proto, n);
Object.defineProperty(template, n, pd);
if (val !== undefined) {
template._propertySetter(n, val);
}
}
},
_showHideChildren: function (hidden) {
},
_forwardInstancePath: function (inst, path, value) {
},
_forwardInstanceProp: function (inst, prop, value) {
},
_notifyPathUpImpl: function (path, value) {
var dataHost = this.dataHost;
var dot = path.indexOf('.');
var root = dot < 0 ? path : path.slice(0, dot);
dataHost._forwardInstancePath.call(dataHost, this, path, value);
if (root in dataHost._parentProps) {
dataHost._templatized.notifyPath(dataHost._parentPropPrefix + path, value);
}
},
_pathEffectorImpl: function (path, value, fromAbove) {
if (this._forwardParentPath) {
if (path.indexOf(this._parentPropPrefix) === 0) {
var subPath = path.substring(this._parentPropPrefix.length);
var model = this._modelForPath(subPath);
if (model in this._parentProps) {
this._forwardParentPath(subPath, value);
}
}
}
Polymer.Base._pathEffector.call(this._templatized, path, value, fromAbove);
},
_constructorImpl: function (model, host) {
this._rootDataHost = host._getRootDataHost();
this._setupConfigure(model);
this._registerHost(host);
this._beginHosting();
this.root = this.instanceTemplate(this._template);
this.root.__noContent = !this._notes._hasContent;
this.root.__styleScoped = true;
this._endHosting();
this._marshalAnnotatedNodes();
this._marshalInstanceEffects();
this._marshalAnnotatedListeners();
var children = [];
for (var n = this.root.firstChild; n; n = n.nextSibling) {
children.push(n);
n._templateInstance = this;
}
this._children = children;
if (host.__hideTemplateChildren__) {
this._showHideChildren(true);
}
this._tryReady();
},
_listenImpl: function (node, eventName, methodName) {
var model = this;
var host = this._rootDataHost;
var handler = host._createEventHandler(node, eventName, methodName);
var decorated = function (e) {
e.model = model;
handler(e);
};
host._listen(node, eventName, decorated);
},
_scopeElementClassImpl: function (node, value) {
var host = this._rootDataHost;
if (host) {
return host._scopeElementClass(node, value);
}
},
stamp: function (model) {
model = model || {};
if (this._parentProps) {
var templatized = this._templatized;
for (var prop in this._parentProps) {
if (model[prop] === undefined) {
model[prop] = templatized[this._parentPropPrefix + prop];
}
}
}
return new this.ctor(model, this);
},
modelForElement: function (el) {
var model;
while (el) {
if (model = el._templateInstance) {
if (model.dataHost != this) {
el = model.dataHost;
} else {
return model;
}
} else {
el = el.parentNode;
}
}
}
};
Polymer({
is: 'dom-template',
extends: 'template',
_template: null,
behaviors: [Polymer.Templatizer],
ready: function () {
this.templatize(this);
}
});
Polymer._collections = new WeakMap();
Polymer.Collection = function (userArray) {
Polymer._collections.set(userArray, this);
this.userArray = userArray;
this.store = userArray.slice();
this.initMap();
};
Polymer.Collection.prototype = {
constructor: Polymer.Collection,
initMap: function () {
var omap = this.omap = new WeakMap();
var pmap = this.pmap = {};
var s = this.store;
for (var i = 0; i < s.length; i++) {
var item = s[i];
if (item && typeof item == 'object') {
omap.set(item, i);
} else {
pmap[item] = i;
}
}
},
add: function (item) {
var key = this.store.push(item) - 1;
if (item && typeof item == 'object') {
this.omap.set(item, key);
} else {
this.pmap[item] = key;
}
return '#' + key;
},
removeKey: function (key) {
if (key = this._parseKey(key)) {
this._removeFromMap(this.store[key]);
delete this.store[key];
}
},
_removeFromMap: function (item) {
if (item && typeof item == 'object') {
this.omap.delete(item);
} else {
delete this.pmap[item];
}
},
remove: function (item) {
var key = this.getKey(item);
this.removeKey(key);
return key;
},
getKey: function (item) {
var key;
if (item && typeof item == 'object') {
key = this.omap.get(item);
} else {
key = this.pmap[item];
}
if (key != undefined) {
return '#' + key;
}
},
getKeys: function () {
return Object.keys(this.store).map(function (key) {
return '#' + key;
});
},
_parseKey: function (key) {
if (key && key[0] == '#') {
return key.slice(1);
}
},
setItem: function (key, item) {
if (key = this._parseKey(key)) {
var old = this.store[key];
if (old) {
this._removeFromMap(old);
}
if (item && typeof item == 'object') {
this.omap.set(item, key);
} else {
this.pmap[item] = key;
}
this.store[key] = item;
}
},
getItem: function (key) {
if (key = this._parseKey(key)) {
return this.store[key];
}
},
getItems: function () {
var items = [], store = this.store;
for (var key in store) {
items.push(store[key]);
}
return items;
},
_applySplices: function (splices) {
var keyMap = {}, key;
for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
s.addedKeys = [];
for (var j = 0; j < s.removed.length; j++) {
key = this.getKey(s.removed[j]);
keyMap[key] = keyMap[key] ? null : -1;
}
for (j = 0; j < s.addedCount; j++) {
var item = this.userArray[s.index + j];
key = this.getKey(item);
key = key === undefined ? this.add(item) : key;
keyMap[key] = keyMap[key] ? null : 1;
s.addedKeys.push(key);
}
}
var removed = [];
var added = [];
for (key in keyMap) {
if (keyMap[key] < 0) {
this.removeKey(key);
removed.push(key);
}
if (keyMap[key] > 0) {
added.push(key);
}
}
return [{
removed: removed,
added: added
}];
}
};
Polymer.Collection.get = function (userArray) {
return Polymer._collections.get(userArray) || new Polymer.Collection(userArray);
};
Polymer.Collection.applySplices = function (userArray, splices) {
var coll = Polymer._collections.get(userArray);
return coll ? coll._applySplices(splices) : null;
};
Polymer({
is: 'dom-repeat',
extends: 'template',
_template: null,
properties: {
items: { type: Array },
as: {
type: String,
value: 'item'
},
indexAs: {
type: String,
value: 'index'
},
sort: {
type: Function,
observer: '_sortChanged'
},
filter: {
type: Function,
observer: '_filterChanged'
},
observe: {
type: String,
observer: '_observeChanged'
},
delay: Number,
renderedItemCount: {
type: Number,
notify: true,
readOnly: true
},
initialCount: {
type: Number,
observer: '_initializeChunking'
},
targetFramerate: {
type: Number,
value: 20
},
_targetFrameTime: {
type: Number,
computed: '_computeFrameTime(targetFramerate)'
}
},
behaviors: [Polymer.Templatizer],
observers: ['_itemsChanged(items.*)'],
created: function () {
this._instances = [];
this._pool = [];
this._limit = Infinity;
var self = this;
this._boundRenderChunk = function () {
self._renderChunk();
};
},
detached: function () {
this.__isDetached = true;
for (var i = 0; i < this._instances.length; i++) {
this._detachInstance(i);
}
},
attached: function () {
if (this.__isDetached) {
this.__isDetached = false;
var parent = Polymer.dom(Polymer.dom(this).parentNode);
for (var i = 0; i < this._instances.length; i++) {
this._attachInstance(i, parent);
}
}
},
ready: function () {
this._instanceProps = { __key__: true };
this._instanceProps[this.as] = true;
this._instanceProps[this.indexAs] = true;
if (!this.ctor) {
this.templatize(this);
}
},
_sortChanged: function (sort) {
var dataHost = this._getRootDataHost();
this._sortFn = sort && (typeof sort == 'function' ? sort : function () {
return dataHost[sort].apply(dataHost, arguments);
});
this._needFullRefresh = true;
if (this.items) {
this._debounceTemplate(this._render);
}
},
_filterChanged: function (filter) {
var dataHost = this._getRootDataHost();
this._filterFn = filter && (typeof filter == 'function' ? filter : function () {
return dataHost[filter].apply(dataHost, arguments);
});
this._needFullRefresh = true;
if (this.items) {
this._debounceTemplate(this._render);
}
},
_computeFrameTime: function (rate) {
return Math.ceil(1000 / rate);
},
_initializeChunking: function () {
if (this.initialCount) {
this._limit = this.initialCount;
this._chunkCount = this.initialCount;
this._lastChunkTime = performance.now();
}
},
_tryRenderChunk: function () {
if (this.items && this._limit < this.items.length) {
this.debounce('renderChunk', this._requestRenderChunk);
}
},
_requestRenderChunk: function () {
requestAnimationFrame(this._boundRenderChunk);
},
_renderChunk: function () {
var currChunkTime = performance.now();
var ratio = this._targetFrameTime / (currChunkTime - this._lastChunkTime);
this._chunkCount = Math.round(this._chunkCount * ratio) || 1;
this._limit += this._chunkCount;
this._lastChunkTime = currChunkTime;
this._debounceTemplate(this._render);
},
_observeChanged: function () {
this._observePaths = this.observe && this.observe.replace('.*', '.').split(' ');
},
_itemsChanged: function (change) {
if (change.path == 'items') {
if (Array.isArray(this.items)) {
this.collection = Polymer.Collection.get(this.items);
} else if (!this.items) {
this.collection = null;
} else {
this._error(this._logf('dom-repeat', 'expected array for `items`,' + ' found', this.items));
}
this._keySplices = [];
this._indexSplices = [];
this._needFullRefresh = true;
this._initializeChunking();
this._debounceTemplate(this._render);
} else if (change.path == 'items.splices') {
this._keySplices = this._keySplices.concat(change.value.keySplices);
this._indexSplices = this._indexSplices.concat(change.value.indexSplices);
this._debounceTemplate(this._render);
} else {
var subpath = change.path.slice(6);
this._forwardItemPath(subpath, change.value);
this._checkObservedPaths(subpath);
}
},
_checkObservedPaths: function (path) {
if (this._observePaths) {
path = path.substring(path.indexOf('.') + 1);
var paths = this._observePaths;
for (var i = 0; i < paths.length; i++) {
if (path.indexOf(paths[i]) === 0) {
this._needFullRefresh = true;
if (this.delay) {
this.debounce('render', this._render, this.delay);
} else {
this._debounceTemplate(this._render);
}
return;
}
}
}
},
render: function () {
this._needFullRefresh = true;
this._debounceTemplate(this._render);
this._flushTemplates();
},
_render: function () {
if (this._needFullRefresh) {
this._applyFullRefresh();
this._needFullRefresh = false;
} else if (this._keySplices.length) {
if (this._sortFn) {
this._applySplicesUserSort(this._keySplices);
} else {
if (this._filterFn) {
this._applyFullRefresh();
} else {
this._applySplicesArrayOrder(this._indexSplices);
}
}
} else {
}
this._keySplices = [];
this._indexSplices = [];
var keyToIdx = this._keyToInstIdx = {};
for (var i = this._instances.length - 1; i >= 0; i--) {
var inst = this._instances[i];
if (inst.isPlaceholder && i < this._limit) {
inst = this._insertInstance(i, inst.__key__);
} else if (!inst.isPlaceholder && i >= this._limit) {
inst = this._downgradeInstance(i, inst.__key__);
}
keyToIdx[inst.__key__] = i;
if (!inst.isPlaceholder) {
inst.__setProperty(this.indexAs, i, true);
}
}
this._pool.length = 0;
this._setRenderedItemCount(this._instances.length);
this.fire('dom-change');
this._tryRenderChunk();
},
_applyFullRefresh: function () {
var c = this.collection;
var keys;
if (this._sortFn) {
keys = c ? c.getKeys() : [];
} else {
keys = [];
var items = this.items;
if (items) {
for (var i = 0; i < items.length; i++) {
keys.push(c.getKey(items[i]));
}
}
}
var self = this;
if (this._filterFn) {
keys = keys.filter(function (a) {
return self._filterFn(c.getItem(a));
});
}
if (this._sortFn) {
keys.sort(function (a, b) {
return self._sortFn(c.getItem(a), c.getItem(b));
});
}
for (i = 0; i < keys.length; i++) {
var key = keys[i];
var inst = this._instances[i];
if (inst) {
inst.__key__ = key;
if (!inst.isPlaceholder && i < this._limit) {
inst.__setProperty(this.as, c.getItem(key), true);
}
} else if (i < this._limit) {
this._insertInstance(i, key);
} else {
this._insertPlaceholder(i, key);
}
}
for (var j = this._instances.length - 1; j >= i; j--) {
this._detachAndRemoveInstance(j);
}
},
_numericSort: function (a, b) {
return a - b;
},
_applySplicesUserSort: function (splices) {
var c = this.collection;
var keyMap = {};
var key;
for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0; j < s.removed.length; j++) {
key = s.removed[j];
keyMap[key] = keyMap[key] ? null : -1;
}
for (j = 0; j < s.added.length; j++) {
key = s.added[j];
keyMap[key] = keyMap[key] ? null : 1;
}
}
var removedIdxs = [];
var addedKeys = [];
for (key in keyMap) {
if (keyMap[key] === -1) {
removedIdxs.push(this._keyToInstIdx[key]);
}
if (keyMap[key] === 1) {
addedKeys.push(key);
}
}
if (removedIdxs.length) {
removedIdxs.sort(this._numericSort);
for (i = removedIdxs.length - 1; i >= 0; i--) {
var idx = removedIdxs[i];
if (idx !== undefined) {
this._detachAndRemoveInstance(idx);
}
}
}
var self = this;
if (addedKeys.length) {
if (this._filterFn) {
addedKeys = addedKeys.filter(function (a) {
return self._filterFn(c.getItem(a));
});
}
addedKeys.sort(function (a, b) {
return self._sortFn(c.getItem(a), c.getItem(b));
});
var start = 0;
for (i = 0; i < addedKeys.length; i++) {
start = this._insertRowUserSort(start, addedKeys[i]);
}
}
},
_insertRowUserSort: function (start, key) {
var c = this.collection;
var item = c.getItem(key);
var end = this._instances.length - 1;
var idx = -1;
while (start <= end) {
var mid = start + end >> 1;
var midKey = this._instances[mid].__key__;
var cmp = this._sortFn(c.getItem(midKey), item);
if (cmp < 0) {
start = mid + 1;
} else if (cmp > 0) {
end = mid - 1;
} else {
idx = mid;
break;
}
}
if (idx < 0) {
idx = end + 1;
}
this._insertPlaceholder(idx, key);
return idx;
},
_applySplicesArrayOrder: function (splices) {
for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0; j < s.removed.length; j++) {
this._detachAndRemoveInstance(s.index);
}
for (j = 0; j < s.addedKeys.length; j++) {
this._insertPlaceholder(s.index + j, s.addedKeys[j]);
}
}
},
_detachInstance: function (idx) {
var inst = this._instances[idx];
if (!inst.isPlaceholder) {
for (var i = 0; i < inst._children.length; i++) {
var el = inst._children[i];
Polymer.dom(inst.root).appendChild(el);
}
return inst;
}
},
_attachInstance: function (idx, parent) {
var inst = this._instances[idx];
if (!inst.isPlaceholder) {
parent.insertBefore(inst.root, this);
}
},
_detachAndRemoveInstance: function (idx) {
var inst = this._detachInstance(idx);
if (inst) {
this._pool.push(inst);
}
this._instances.splice(idx, 1);
},
_insertPlaceholder: function (idx, key) {
this._instances.splice(idx, 0, {
isPlaceholder: true,
__key__: key
});
},
_stampInstance: function (idx, key) {
var model = { __key__: key };
model[this.as] = this.collection.getItem(key);
model[this.indexAs] = idx;
return this.stamp(model);
},
_insertInstance: function (idx, key) {
var inst = this._pool.pop();
if (inst) {
inst.__setProperty(this.as, this.collection.getItem(key), true);
inst.__setProperty('__key__', key, true);
} else {
inst = this._stampInstance(idx, key);
}
var beforeRow = this._instances[idx + 1];
var beforeNode = beforeRow && !beforeRow.isPlaceholder ? beforeRow._children[0] : this;
var parentNode = Polymer.dom(this).parentNode;
Polymer.dom(parentNode).insertBefore(inst.root, beforeNode);
this._instances[idx] = inst;
return inst;
},
_downgradeInstance: function (idx, key) {
var inst = this._detachInstance(idx);
if (inst) {
this._pool.push(inst);
}
inst = {
isPlaceholder: true,
__key__: key
};
this._instances[idx] = inst;
return inst;
},
_showHideChildren: function (hidden) {
for (var i = 0; i < this._instances.length; i++) {
this._instances[i]._showHideChildren(hidden);
}
},
_forwardInstanceProp: function (inst, prop, value) {
if (prop == this.as) {
var idx;
if (this._sortFn || this._filterFn) {
idx = this.items.indexOf(this.collection.getItem(inst.__key__));
} else {
idx = inst[this.indexAs];
}
this.set('items.' + idx, value);
}
},
_forwardInstancePath: function (inst, path, value) {
if (path.indexOf(this.as + '.') === 0) {
this._notifyPath('items.' + inst.__key__ + '.' + path.slice(this.as.length + 1), value);
}
},
_forwardParentProp: function (prop, value) {
var i$ = this._instances;
for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
if (!inst.isPlaceholder) {
inst.__setProperty(prop, value, true);
}
}
},
_forwardParentPath: function (path, value) {
var i$ = this._instances;
for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
if (!inst.isPlaceholder) {
inst._notifyPath(path, value, true);
}
}
},
_forwardItemPath: function (path, value) {
if (this._keyToInstIdx) {
var dot = path.indexOf('.');
var key = path.substring(0, dot < 0 ? path.length : dot);
var idx = this._keyToInstIdx[key];
var inst = this._instances[idx];
if (inst && !inst.isPlaceholder) {
if (dot >= 0) {
path = this.as + '.' + path.substring(dot + 1);
inst._notifyPath(path, value, true);
} else {
inst.__setProperty(this.as, value, true);
}
}
}
},
itemForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance[this.as];
},
keyForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance.__key__;
},
indexForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance[this.indexAs];
}
});
Polymer({
is: 'array-selector',
_template: null,
properties: {
items: {
type: Array,
observer: 'clearSelection'
},
multi: {
type: Boolean,
value: false,
observer: 'clearSelection'
},
selected: {
type: Object,
notify: true
},
selectedItem: {
type: Object,
notify: true
},
toggle: {
type: Boolean,
value: false
}
},
clearSelection: function () {
if (Array.isArray(this.selected)) {
for (var i = 0; i < this.selected.length; i++) {
this.unlinkPaths('selected.' + i);
}
} else {
this.unlinkPaths('selected');
this.unlinkPaths('selectedItem');
}
if (this.multi) {
if (!this.selected || this.selected.length) {
this.selected = [];
this._selectedColl = Polymer.Collection.get(this.selected);
}
} else {
this.selected = null;
this._selectedColl = null;
}
this.selectedItem = null;
},
isSelected: function (item) {
if (this.multi) {
return this._selectedColl.getKey(item) !== undefined;
} else {
return this.selected == item;
}
},
deselect: function (item) {
if (this.multi) {
if (this.isSelected(item)) {
var skey = this._selectedColl.getKey(item);
this.arrayDelete('selected', item);
this.unlinkPaths('selected.' + skey);
}
} else {
this.selected = null;
this.selectedItem = null;
this.unlinkPaths('selected');
this.unlinkPaths('selectedItem');
}
},
select: function (item) {
var icol = Polymer.Collection.get(this.items);
var key = icol.getKey(item);
if (this.multi) {
if (this.isSelected(item)) {
if (this.toggle) {
this.deselect(item);
}
} else {
this.push('selected', item);
var skey = this._selectedColl.getKey(item);
this.linkPaths('selected.' + skey, 'items.' + key);
}
} else {
if (this.toggle && item == this.selected) {
this.deselect();
} else {
this.selected = item;
this.selectedItem = item;
this.linkPaths('selected', 'items.' + key);
this.linkPaths('selectedItem', 'items.' + key);
}
}
}
});
Polymer({
is: 'dom-if',
extends: 'template',
_template: null,
properties: {
'if': {
type: Boolean,
value: false,
observer: '_queueRender'
},
restamp: {
type: Boolean,
value: false,
observer: '_queueRender'
}
},
behaviors: [Polymer.Templatizer],
_queueRender: function () {
this._debounceTemplate(this._render);
},
detached: function () {
if (!this.parentNode || this.parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE && (!Polymer.Settings.hasShadow || !(this.parentNode instanceof ShadowRoot))) {
this._teardownInstance();
}
},
attached: function () {
if (this.if && this.ctor) {
this.async(this._ensureInstance);
}
},
render: function () {
this._flushTemplates();
},
_render: function () {
if (this.if) {
if (!this.ctor) {
this.templatize(this);
}
this._ensureInstance();
this._showHideChildren();
} else if (this.restamp) {
this._teardownInstance();
}
if (!this.restamp && this._instance) {
this._showHideChildren();
}
if (this.if != this._lastIf) {
this.fire('dom-change');
this._lastIf = this.if;
}
},
_ensureInstance: function () {
var parentNode = Polymer.dom(this).parentNode;
if (parentNode) {
var parent = Polymer.dom(parentNode);
if (!this._instance) {
this._instance = this.stamp();
var root = this._instance.root;
parent.insertBefore(root, this);
} else {
var c$ = this._instance._children;
if (c$ && c$.length) {
var lastChild = Polymer.dom(this).previousSibling;
if (lastChild !== c$[c$.length - 1]) {
for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
parent.insertBefore(n, this);
}
}
}
}
}
},
_teardownInstance: function () {
if (this._instance) {
var c$ = this._instance._children;
if (c$ && c$.length) {
var parent = Polymer.dom(Polymer.dom(c$[0]).parentNode);
for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
parent.removeChild(n);
}
}
this._instance = null;
}
},
_showHideChildren: function () {
var hidden = this.__hideTemplateChildren__ || !this.if;
if (this._instance) {
this._instance._showHideChildren(hidden);
}
},
_forwardParentProp: function (prop, value) {
if (this._instance) {
this._instance[prop] = value;
}
},
_forwardParentPath: function (path, value) {
if (this._instance) {
this._instance._notifyPath(path, value, true);
}
}
});
Polymer({
is: 'dom-bind',
extends: 'template',
_template: null,
created: function () {
var self = this;
Polymer.RenderStatus.whenReady(function () {
if (document.readyState == 'loading') {
document.addEventListener('DOMContentLoaded', function () {
self._markImportsReady();
});
} else {
self._markImportsReady();
}
});
},
_ensureReady: function () {
if (!this._readied) {
this._readySelf();
}
},
_markImportsReady: function () {
this._importsReady = true;
this._ensureReady();
},
_registerFeatures: function () {
this._prepConstructor();
},
_insertChildren: function () {
var parentDom = Polymer.dom(Polymer.dom(this).parentNode);
parentDom.insertBefore(this.root, this);
},
_removeChildren: function () {
if (this._children) {
for (var i = 0; i < this._children.length; i++) {
this.root.appendChild(this._children[i]);
}
}
},
_initFeatures: function () {
},
_scopeElementClass: function (element, selector) {
if (this.dataHost) {
return this.dataHost._scopeElementClass(element, selector);
} else {
return selector;
}
},
_prepConfigure: function () {
var config = {};
for (var prop in this._propertyEffects) {
config[prop] = this[prop];
}
var setupConfigure = this._setupConfigure;
this._setupConfigure = function () {
setupConfigure.call(this, config);
};
},
attached: function () {
if (this._importsReady) {
this.render();
}
},
detached: function () {
this._removeChildren();
},
render: function () {
this._ensureReady();
if (!this._children) {
this._template = this;
this._prepAnnotations();
this._prepEffects();
this._prepBehaviors();
this._prepConfigure();
this._prepBindings();
this._prepPropertyInfo();
Polymer.Base._initFeatures.call(this);
this._children = Polymer.TreeApi.arrayCopyChildNodes(this.root);
}
this._insertChildren();
this.fire('dom-change');
}
});</script>
<script>
"use strict";

/*
 Overwrite the Collection.add and .initMap methods.

 Here we provide the option of using "intrusive" keys
 for objects..although it's not fully intrusive, because
 the non-intrusive version still exists and is used by 
 the Collection class itself.
 
 Objects with a ._pkey=null property will have it set to the
 key when inserted into the collection, and when the 
 collection is initialized.

 Note that if the object is in multiple collections only the
 first insertion will set the pkey, because after that the
 value will no longer be null.  It is up to the user to be
 aware of this and use it appropriately.

*/
Polymer.Collection.prototype.add = function(item) {
  var key = this.store.push(item) - 1;
  if (item && typeof item == 'object') {
    this.omap.set(item, key);
    item._pkey === null && (item._pkey = '#' + key); // << this is extra
  } else {
    this.pmap[item] = key;
  }
  return '#' + key;
};

Polymer.Collection.prototype.initMap = function() {
  var omap = this.omap = new WeakMap();
  var pmap = this.pmap = {};
  var s = this.store;
  for (var i=0; i<s.length; i++) {
    var item = s[i];
    if (item && typeof item == 'object') {
      omap.set(item, i);
      item._pkey === null && (item._pkey = '#' + i); // << this is extra
    } else {
      pmap[item] = i;
    }
  }
};


/*
  The following is an important hack which allows you to avoid doing expensive
  notifications if you really have to.

  It is to be used when an object has various properties that are known to only 
  be of interest to a very specific set of elements. 

  The "target" elements should use the Polymer.ShortcutNotifyTargetBehavior(), 
  behavior factory function, passing in an array of path strings.

  For example:

    <dom-module id="lovely-view">
      <template>
        some_property is: [[my_model.some_property]]
      </template>
      <script>
        Polymer({
          is: 'lovely-view',
          behaviors: [
            Polymer.ShortcutNotifyTargetBehavior(['my_model'])
          ],
          properties: {
             my_model: {
                // whatever
             }
          }
        });
      < /script>
    </dom-module>

  The "notifiyer" element should use the Polymer.ShortcutNotifyerBehavior,
  and then replace calls like this:

    this.notifyPath('some_array.#42.some_property', mutated_object.some_property)      

  with this:

     this.shortcutNotify('some_property', mutated_object.some_property, mutated_object);

  Note how here we only use the final suffix for the path, and we provide the actual
  object as the final argument.

  I think this mechanism supports multi-part paths, but I haven't tested it.

  Using this approach very much goes against the Polymeric way of doing things, 
  but it's far easier to implement than something less hacky (I did try something
  much fancier, but ran in to all kinds of complciations and decided to abandon the effort.)
*/

(function(){

  let targetsForModel = new WeakMap();
  let OLD_MODEL_PREFIX = '_oldModelFor_';

  Polymer.ShortcutNotifyTargetBehavior = function(paths) {
    return {

      observers: (function(){
        let observers = [];
        for(let [ii, path] of paths.entries()){
          observers.push('_updateShorcutMapping("' + path + '", ' + path + ')');
        }
        return observers;
      })(),

      _updateShorcutMapping: function(path, newModel){
          this._removeAsTargetForModel(path);
          this._addAsTargetForModel(path, newModel);
      },

      attached: function(){
        this._isAttached = true;
        for(let path of paths){
          this._addAsTargetForModel(path, this.get(path));
        }
      },

      detached: function(){
        this._isAttached = false;
        for(let path of paths){
          this._removeAsTargetForModel(path);
        }
      },

      _removeAsTargetForModel: function(path){
        let oldModel = this[OLD_MODEL_PREFIX + path];
        let oldTargets;
        if(oldModel && (typeof oldModel === "object") && (oldTargets=targetsForModel.get(oldModel))){
          let oldIdx = -1;
          for(let [ii, target] of oldTargets.entries()){
            if(target.el === this){
              oldIdx = ii;
              break;
            }
          }
          if(oldIdx !== -1){
            if(oldTargets.length === 1){
              targetsForModel.delete(oldModel); // this was the only remaining target for the given model
            } else {
              oldTargets.splice(oldIdx, 1); // there are still other targets observing this model
            }
          }
        }
      },

      _addAsTargetForModel: function(path, newModel){
        if(this._isAttached && newModel && (typeof newModel === "object")){
          let newTargets = targetsForModel.get(newModel);
          if(!newTargets){
            newTargets = [];
            targetsForModel.set(newModel, newTargets);
          }
          newTargets.push({
            el: this,
            prefix: path
          });
          this[OLD_MODEL_PREFIX + path] = newModel;
        }
      }

    }
  };

  Polymer.ShortcutNotifyerBehavior = {
      shortcutNotify: function(path, value, model){
        let targets = targetsForModel.get(model) || [];
        for(let target of targets){
          target.el.notifyPath(target.prefix + "." + path, value, true);
        }
      }
  };

})();


</script>
<dom-module id="iron-localstorage" assetpath="bower_components/iron-localstorage/"></dom-module>
<script>

  Polymer({
    is: 'iron-localstorage',

    properties: {
      /**
       * localStorage item key
       */
      name: {
        type: String,
        value: ''
      },
      /**
       * The data associated with this storage.
       * If set to null item will be deleted.
       * @type {*}
       */
      value: {
        type: Object,
        notify: true
      },

      /**
       * If true: do not convert value to JSON on save/load
       */
      useRaw: {
        type: Boolean,
        value: false
      },

      /**
       * Value will not be saved automatically if true. You'll have to do it manually with `save()`
       */
      autoSaveDisabled: {
        type: Boolean,
        value: false
      },
      /**
       * Last error encountered while saving/loading items
       */
      errorMessage: {
        type: String,
        notify: true
      },

      /** True if value has been loaded */
      _loaded: {
        type: Boolean,
        value: false
      }
    },

    observers: [
      '_debounceReload(name,useRaw)',
      '_trySaveValue(autoSaveDisabled)',
      '_trySaveValue(value.*)'
    ],

    ready: function() {
      this._boundHandleStorage = this._handleStorage.bind(this);
    },

    attached: function() {
      window.addEventListener('storage', this._boundHandleStorage);
    },

    detached: function() {
      window.removeEventListener('storage', this._boundHandleStorage);
    },

    _handleStorage: function(ev) {
      if (ev.key == this.name) {
        this._load(true);
      }
    },

    _trySaveValue: function() {
      if (this._doNotSave) {
        return;
      }
      if (this._loaded && !this.autoSaveDisabled) {
        this.debounce('save', this.save);
      }
    },

    _debounceReload: function() {
      this.debounce('reload', this.reload);
    },

    /**
     * Loads the value again. Use if you modify
     * localStorage using DOM calls, and want to
     * keep this element in sync.
     */
    reload: function() {
      this._loaded = false;
      this._load();
    },

    /**
     * loads value from local storage
     * @param {boolean=} externalChange true if loading changes from a different window
     */
    _load: function(externalChange) {
      var v = window.localStorage.getItem(this.name);

      if (v === null) {
        this._loaded = true;
        this._doNotSave = true;  // guard for save watchers
        this.value = null;
        this._doNotSave = false;
        this.fire('iron-localstorage-load-empty', { externalChange: externalChange});
      } else {
        if (!this.useRaw) {
          try { // parse value as JSON
            v = JSON.parse(v);
          } catch(x) {
            this.errorMessage = "Could not parse local storage value";
            console.error("could not parse local storage value", v);
            v = null;
          }
        }
        this._loaded = true;
        this._doNotSave = true;
        this.value = v;
        this._doNotSave = false;
        this.fire('iron-localstorage-load', { externalChange: externalChange});
      }
    },

    /**
     * Saves the value to localStorage. Call to save if autoSaveDisabled is set.
     * If `value` is null or undefined, deletes localStorage.
     */
    save: function() {
      var v = this.useRaw ? this.value : JSON.stringify(this.value);
      try {
        if (this.value === null || this.value === undefined) {
          window.localStorage.removeItem(this.name);
        } else {
          window.localStorage.setItem(this.name, /** @type {string} */ (v));
        }
      }
      catch(ex) {
        // Happens in Safari incognito mode,
        this.errorMessage = ex.message;
        console.error("localStorage could not be saved. Safari incoginito mode?", ex);
      }
    }

    /**
     * Fired when value loads from localStorage.
     *
     * @event iron-localstorage-load
     * @param {{externalChange:boolean}} detail -
     *     externalChange: true if change occured in different window.
     */

    /**
     * Fired when loaded value does not exist.
     * Event handler can be used to initialize default value.
     *
     * @event iron-localstorage-load-empty
     * @param {{externalChange:boolean}} detail -
     *     externalChange: true if change occured in different window.
     */
  });

</script>


<script>

  (function() {

    // monostate data
    var metaDatas = {};
    var metaArrays = {};
    var singleton = null;

    Polymer.IronMeta = Polymer({

      is: 'iron-meta',

      properties: {

        /**
         * The type of meta-data.  All meta-data of the same type is stored
         * together.
         */
        type: {
          type: String,
          value: 'default',
          observer: '_typeChanged'
        },

        /**
         * The key used to store `value` under the `type` namespace.
         */
        key: {
          type: String,
          observer: '_keyChanged'
        },

        /**
         * The meta-data to store or retrieve.
         */
        value: {
          type: Object,
          notify: true,
          observer: '_valueChanged'
        },

        /**
         * If true, `value` is set to the iron-meta instance itself.
         */
         self: {
          type: Boolean,
          observer: '_selfChanged'
        },

        /**
         * Array of all meta-data values for the given type.
         */
        list: {
          type: Array,
          notify: true
        }

      },

      hostAttributes: {
        hidden: true
      },

      /**
       * Only runs if someone invokes the factory/constructor directly
       * e.g. `new Polymer.IronMeta()`
       *
       * @param {{type: (string|undefined), key: (string|undefined), value}=} config
       */
      factoryImpl: function(config) {
        if (config) {
          for (var n in config) {
            switch(n) {
              case 'type':
              case 'key':
              case 'value':
                this[n] = config[n];
                break;
            }
          }
        }
      },

      created: function() {
        // TODO(sjmiles): good for debugging?
        this._metaDatas = metaDatas;
        this._metaArrays = metaArrays;
      },

      _keyChanged: function(key, old) {
        this._resetRegistration(old);
      },

      _valueChanged: function(value) {
        this._resetRegistration(this.key);
      },

      _selfChanged: function(self) {
        if (self) {
          this.value = this;
        }
      },

      _typeChanged: function(type) {
        this._unregisterKey(this.key);
        if (!metaDatas[type]) {
          metaDatas[type] = {};
        }
        this._metaData = metaDatas[type];
        if (!metaArrays[type]) {
          metaArrays[type] = [];
        }
        this.list = metaArrays[type];
        this._registerKeyValue(this.key, this.value);
      },

      /**
       * Retrieves meta data value by key.
       *
       * @method byKey
       * @param {string} key The key of the meta-data to be returned.
       * @return {*}
       */
      byKey: function(key) {
        return this._metaData && this._metaData[key];
      },

      _resetRegistration: function(oldKey) {
        this._unregisterKey(oldKey);
        this._registerKeyValue(this.key, this.value);
      },

      _unregisterKey: function(key) {
        this._unregister(key, this._metaData, this.list);
      },

      _registerKeyValue: function(key, value) {
        this._register(key, value, this._metaData, this.list);
      },

      _register: function(key, value, data, list) {
        if (key && data && value !== undefined) {
          data[key] = value;
          list.push(value);
        }
      },

      _unregister: function(key, data, list) {
        if (key && data) {
          if (key in data) {
            var value = data[key];
            delete data[key];
            this.arrayDelete(list, value);
          }
        }
      }

    });

    Polymer.IronMeta.getIronMeta = function getIronMeta() {
       if (singleton === null) {
         singleton = new Polymer.IronMeta();
       }
       return singleton;
     };

    /**
    `iron-meta-query` can be used to access infomation stored in `iron-meta`.

    Examples:

    If I create an instance like this:

        <iron-meta key="info" value="foo/bar"></iron-meta>

    Note that value="foo/bar" is the metadata I've defined. I could define more
    attributes or use child nodes to define additional metadata.

    Now I can access that element (and it's metadata) from any `iron-meta-query` instance:

         var value = new Polymer.IronMetaQuery({key: 'info'}).value;

    @group Polymer Iron Elements
    @element iron-meta-query
    */
    Polymer.IronMetaQuery = Polymer({

      is: 'iron-meta-query',

      properties: {

        /**
         * The type of meta-data.  All meta-data of the same type is stored
         * together.
         */
        type: {
          type: String,
          value: 'default',
          observer: '_typeChanged'
        },

        /**
         * Specifies a key to use for retrieving `value` from the `type`
         * namespace.
         */
        key: {
          type: String,
          observer: '_keyChanged'
        },

        /**
         * The meta-data to store or retrieve.
         */
        value: {
          type: Object,
          notify: true,
          readOnly: true
        },

        /**
         * Array of all meta-data values for the given type.
         */
        list: {
          type: Array,
          notify: true
        }

      },

      /**
       * Actually a factory method, not a true constructor. Only runs if
       * someone invokes it directly (via `new Polymer.IronMeta()`);
       *
       * @param {{type: (string|undefined), key: (string|undefined)}=} config
       */
      factoryImpl: function(config) {
        if (config) {
          for (var n in config) {
            switch(n) {
              case 'type':
              case 'key':
                this[n] = config[n];
                break;
            }
          }
        }
      },

      created: function() {
        // TODO(sjmiles): good for debugging?
        this._metaDatas = metaDatas;
        this._metaArrays = metaArrays;
      },

      _keyChanged: function(key) {
        this._setValue(this._metaData && this._metaData[key]);
      },

      _typeChanged: function(type) {
        this._metaData = metaDatas[type];
        this.list = metaArrays[type];
        if (this.key) {
          this._keyChanged(this.key);
        }
      },

      /**
       * Retrieves meta data value by key.
       * @param {string} key The key of the meta-data to be returned.
       * @return {*}
       */
      byKey: function(key) {
        return this._metaData && this._metaData[key];
      }

    });

  })();
</script>
<script>

  /**
   * Use `Polymer.NeonAnimationBehavior` to implement an animation.
   * @polymerBehavior
   */
  Polymer.NeonAnimationBehavior = {

    properties: {

      /**
       * Defines the animation timing.
       */
      animationTiming: {
        type: Object,
        value: function() {
          return {
            duration: 500,
            easing: 'cubic-bezier(0.4, 0, 0.2, 1)',
            fill: 'both'
          }
        }
      }

    },

    /**
     * Can be used to determine that elements implement this behavior.
     */
    isNeonAnimation: true,

    /**
     * Do any animation configuration here.
     */
    // configure: function(config) {
    // },

    /**
     * Returns the animation timing by mixing in properties from `config` to the defaults defined
     * by the animation.
     */
    timingFromConfig: function(config) {
      if (config.timing) {
        for (var property in config.timing) {
          this.animationTiming[property] = config.timing[property];
        }
      }
      return this.animationTiming;
    },

    /**
     * Sets `transform` and `transformOrigin` properties along with the prefixed versions.
     */
    setPrefixedProperty: function(node, property, value) {
      var map = {
        'transform': ['webkitTransform'],
        'transformOrigin': ['mozTransformOrigin', 'webkitTransformOrigin']
      };
      var prefixes = map[property];
      for (var prefix, index = 0; prefix = prefixes[index]; index++) {
        node.style[prefix] = value;
      }
      node.style[property] = value;
    },

    /**
     * Called when the animation finishes.
     */
    complete: function() {}

  };

</script>
<script>// Copyright 2014 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
//     You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//     See the License for the specific language governing permissions and
// limitations under the License.

!function(a,b){b["true"]=a;var c={},d={},e={},f=null;!function(a){function b(a){if("number"==typeof a)return a;var b={};for(var c in a)b[c]=a[c];return b}function c(){this._delay=0,this._endDelay=0,this._fill="none",this._iterationStart=0,this._iterations=1,this._duration=0,this._playbackRate=1,this._direction="normal",this._easing="linear"}function d(b,d){var e=new c;return d&&(e.fill="both",e.duration="auto"),"number"!=typeof b||isNaN(b)?void 0!==b&&Object.getOwnPropertyNames(b).forEach(function(c){if("auto"!=b[c]){if(("number"==typeof e[c]||"duration"==c)&&("number"!=typeof b[c]||isNaN(b[c])))return;if("fill"==c&&-1==s.indexOf(b[c]))return;if("direction"==c&&-1==t.indexOf(b[c]))return;if("playbackRate"==c&&1!==b[c]&&a.isDeprecated("AnimationEffectTiming.playbackRate","2014-11-28","Use Animation.playbackRate instead."))return;e[c]=b[c]}}):e.duration=b,e}function e(a){return"number"==typeof a&&(a=isNaN(a)?{duration:0}:{duration:a}),a}function f(b,c){b=a.numericTimingToObject(b);var e=d(b,c);return e._easing=i(e.easing),e}function g(a,b,c,d){return 0>a||a>1||0>c||c>1?B:function(e){function f(a,b,c){return 3*a*(1-c)*(1-c)*c+3*b*(1-c)*c*c+c*c*c}if(0==e||1==e)return e;for(var g=0,h=1;;){var i=(g+h)/2,j=f(a,c,i);if(Math.abs(e-j)<.001)return f(b,d,i);e>j?g=i:h=i}}}function h(a,b){return function(c){if(c>=1)return 1;var d=1/a;return c+=b*d,c-c%d}}function i(a){var b=z.exec(a);if(b)return g.apply(this,b.slice(1).map(Number));var c=A.exec(a);if(c)return h(Number(c[1]),{start:u,middle:v,end:w}[c[2]]);var d=x[a];return d?d:B}function j(a){return Math.abs(k(a)/a.playbackRate)}function k(a){return a.duration*a.iterations}function l(a,b,c){return null==b?C:b<c.delay?D:b>=c.delay+a?E:F}function m(a,b,c,d,e){switch(d){case D:return"backwards"==b||"both"==b?0:null;case F:return c-e;case E:return"forwards"==b||"both"==b?a:null;case C:return null}}function n(a,b,c,d){return(d.playbackRate<0?b-a:b)*d.playbackRate+c}function o(a,b,c,d,e){return 1/0===c||c===-1/0||c-d==b&&e.iterations&&(e.iterations+e.iterationStart)%1==0?a:c%a}function p(a,b,c,d){return 0===c?0:b==a?d.iterationStart+d.iterations-1:Math.floor(c/a)}function q(a,b,c,d){var e=a%2>=1,f="normal"==d.direction||d.direction==(e?"alternate-reverse":"alternate"),g=f?c:b-c,h=g/b;return b*d.easing(h)}function r(a,b,c){var d=l(a,b,c),e=m(a,c.fill,b,d,c.delay);if(null===e)return null;if(0===a)return d===D?0:1;var f=c.iterationStart*c.duration,g=n(a,e,f,c),h=o(c.duration,k(c),g,f,c),i=p(c.duration,h,g,c);return q(i,c.duration,h,c)/c.duration}var s="backwards|forwards|both|none".split("|"),t="reverse|alternate|alternate-reverse".split("|");c.prototype={_setMember:function(b,c){this["_"+b]=c,this._effect&&(this._effect._timingInput[b]=c,this._effect._timing=a.normalizeTimingInput(a.normalizeTimingInput(this._effect._timingInput)),this._effect.activeDuration=a.calculateActiveDuration(this._effect._timing),this._effect._animation&&this._effect._animation._rebuildUnderlyingAnimation())},get playbackRate(){return this._playbackRate},set delay(a){this._setMember("delay",a)},get delay(){return this._delay},set endDelay(a){this._setMember("endDelay",a)},get endDelay(){return this._endDelay},set fill(a){this._setMember("fill",a)},get fill(){return this._fill},set iterationStart(a){this._setMember("iterationStart",a)},get iterationStart(){return this._iterationStart},set duration(a){this._setMember("duration",a)},get duration(){return this._duration},set direction(a){this._setMember("direction",a)},get direction(){return this._direction},set easing(a){this._setMember("easing",a)},get easing(){return this._easing},set iterations(a){this._setMember("iterations",a)},get iterations(){return this._iterations}};var u=1,v=.5,w=0,x={ease:g(.25,.1,.25,1),"ease-in":g(.42,0,1,1),"ease-out":g(0,0,.58,1),"ease-in-out":g(.42,0,.58,1),"step-start":h(1,u),"step-middle":h(1,v),"step-end":h(1,w)},y="\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*",z=new RegExp("cubic-bezier\\("+y+","+y+","+y+","+y+"\\)"),A=/steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/,B=function(a){return a},C=0,D=1,E=2,F=3;a.cloneTimingInput=b,a.makeTiming=d,a.numericTimingToObject=e,a.normalizeTimingInput=f,a.calculateActiveDuration=j,a.calculateTimeFraction=r,a.calculatePhase=l,a.toTimingFunction=i}(c,f),function(a){function b(a,b){return a in h?h[a][b]||b:b}function c(a,c,d){var g=e[a];if(g){f.style[a]=c;for(var h in g){var i=g[h],j=f.style[i];d[i]=b(i,j)}}else d[a]=b(a,c)}function d(b){function d(){var a=e.length;null==e[a-1].offset&&(e[a-1].offset=1),a>1&&null==e[0].offset&&(e[0].offset=0);for(var b=0,c=e[0].offset,d=1;a>d;d++){var f=e[d].offset;if(null!=f){for(var g=1;d-b>g;g++)e[b+g].offset=c+(f-c)*g/(d-b);b=d,c=f}}}if(!Array.isArray(b)&&null!==b)throw new TypeError("Keyframes must be null or an array of keyframes");if(null==b)return[];for(var e=b.map(function(b){var d={};for(var e in b){var f=b[e];if("offset"==e){if(null!=f&&(f=Number(f),!isFinite(f)))throw new TypeError("keyframe offsets must be numbers.")}else{if("composite"==e)throw{type:DOMException.NOT_SUPPORTED_ERR,name:"NotSupportedError",message:"add compositing is not supported"};f="easing"==e?a.toTimingFunction(f):""+f}c(e,f,d)}return void 0==d.offset&&(d.offset=null),void 0==d.easing&&(d.easing=a.toTimingFunction("linear")),d}),f=!0,g=-1/0,h=0;h<e.length;h++){var i=e[h].offset;if(null!=i){if(g>i)throw{code:DOMException.INVALID_MODIFICATION_ERR,name:"InvalidModificationError",message:"Keyframes are not loosely sorted by offset. Sort or specify offsets."};g=i}else f=!1}return e=e.filter(function(a){return a.offset>=0&&a.offset<=1}),f||d(),e}var e={background:["backgroundImage","backgroundPosition","backgroundSize","backgroundRepeat","backgroundAttachment","backgroundOrigin","backgroundClip","backgroundColor"],border:["borderTopColor","borderTopStyle","borderTopWidth","borderRightColor","borderRightStyle","borderRightWidth","borderBottomColor","borderBottomStyle","borderBottomWidth","borderLeftColor","borderLeftStyle","borderLeftWidth"],borderBottom:["borderBottomWidth","borderBottomStyle","borderBottomColor"],borderColor:["borderTopColor","borderRightColor","borderBottomColor","borderLeftColor"],borderLeft:["borderLeftWidth","borderLeftStyle","borderLeftColor"],borderRadius:["borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius"],borderRight:["borderRightWidth","borderRightStyle","borderRightColor"],borderTop:["borderTopWidth","borderTopStyle","borderTopColor"],borderWidth:["borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth"],flex:["flexGrow","flexShrink","flexBasis"],font:["fontFamily","fontSize","fontStyle","fontVariant","fontWeight","lineHeight"],margin:["marginTop","marginRight","marginBottom","marginLeft"],outline:["outlineColor","outlineStyle","outlineWidth"],padding:["paddingTop","paddingRight","paddingBottom","paddingLeft"]},f=document.createElementNS("http://www.w3.org/1999/xhtml","div"),g={thin:"1px",medium:"3px",thick:"5px"},h={borderBottomWidth:g,borderLeftWidth:g,borderRightWidth:g,borderTopWidth:g,fontSize:{"xx-small":"60%","x-small":"75%",small:"89%",medium:"100%",large:"120%","x-large":"150%","xx-large":"200%"},fontWeight:{normal:"400",bold:"700"},outlineWidth:g,textShadow:{none:"0px 0px 0px transparent"},boxShadow:{none:"0px 0px 0px 0px transparent"}};a.normalizeKeyframes=d}(c,f),function(a){var b={};a.isDeprecated=function(a,c,d,e){var f=e?"are":"is",g=new Date,h=new Date(c);return h.setMonth(h.getMonth()+3),h>g?(a in b||console.warn("Web Animations: "+a+" "+f+" deprecated and will stop working on "+h.toDateString()+". "+d),b[a]=!0,!1):!0},a.deprecated=function(b,c,d,e){var f=e?"are":"is";if(a.isDeprecated(b,c,d,e))throw new Error(b+" "+f+" no longer supported. "+d)}}(c),function(){if(document.documentElement.animate){var a=document.documentElement.animate([],0),b=!0;if(a&&(b=!1,"play|currentTime|pause|reverse|playbackRate|cancel|finish|startTime|playState".split("|").forEach(function(c){void 0===a[c]&&(b=!0)})),!b)return}!function(a,b){function c(a){for(var b={},c=0;c<a.length;c++)for(var d in a[c])if("offset"!=d&&"easing"!=d&&"composite"!=d){var e={offset:a[c].offset,easing:a[c].easing,value:a[c][d]};b[d]=b[d]||[],b[d].push(e)}for(var f in b){var g=b[f];if(0!=g[0].offset||1!=g[g.length-1].offset)throw{type:DOMException.NOT_SUPPORTED_ERR,name:"NotSupportedError",message:"Partial keyframes are not supported"}}return b}function d(a){var c=[];for(var d in a)for(var e=a[d],f=0;f<e.length-1;f++){var g=e[f].offset,h=e[f+1].offset,i=e[f].value,j=e[f+1].value;g==h&&(1==h?i=j:j=i),c.push({startTime:g,endTime:h,easing:e[f].easing,property:d,interpolation:b.propertyInterpolation(d,i,j)})}return c.sort(function(a,b){return a.startTime-b.startTime}),c}b.convertEffectInput=function(e){var f=a.normalizeKeyframes(e),g=c(f),h=d(g);return function(a,c){if(null!=c)h.filter(function(a){return 0>=c&&0==a.startTime||c>=1&&1==a.endTime||c>=a.startTime&&c<=a.endTime}).forEach(function(d){var e=c-d.startTime,f=d.endTime-d.startTime,g=0==f?0:d.easing(e/f);b.apply(a,d.property,d.interpolation(g))});else for(var d in g)"offset"!=d&&"easing"!=d&&"composite"!=d&&b.clear(a,d)}}}(c,d,f),function(a){function b(a,b,c){e[c]=e[c]||[],e[c].push([a,b])}function c(a,c,d){for(var e=0;e<d.length;e++){var f=d[e];b(a,c,f),/-/.test(f)&&b(a,c,f.replace(/-(.)/g,function(a,b){return b.toUpperCase()}))}}function d(b,c,d){if("initial"==c||"initial"==d){var g=b.replace(/-(.)/g,function(a,b){return b.toUpperCase()});"initial"==c&&(c=f[g]),"initial"==d&&(d=f[g])}for(var h=c==d?[]:e[b],i=0;h&&i<h.length;i++){var j=h[i][0](c),k=h[i][0](d);if(void 0!==j&&void 0!==k){var l=h[i][1](j,k);if(l){var m=a.Interpolation.apply(null,l);return function(a){return 0==a?c:1==a?d:m(a)}}}}return a.Interpolation(!1,!0,function(a){return a?d:c})}var e={};a.addPropertiesHandler=c;var f={backgroundColor:"transparent",backgroundPosition:"0% 0%",borderBottomColor:"currentColor",borderBottomLeftRadius:"0px",borderBottomRightRadius:"0px",borderBottomWidth:"3px",borderLeftColor:"currentColor",borderLeftWidth:"3px",borderRightColor:"currentColor",borderRightWidth:"3px",borderSpacing:"2px",borderTopColor:"currentColor",borderTopLeftRadius:"0px",borderTopRightRadius:"0px",borderTopWidth:"3px",bottom:"auto",clip:"rect(0px, 0px, 0px, 0px)",color:"black",fontSize:"100%",fontWeight:"400",height:"auto",left:"auto",letterSpacing:"normal",lineHeight:"120%",marginBottom:"0px",marginLeft:"0px",marginRight:"0px",marginTop:"0px",maxHeight:"none",maxWidth:"none",minHeight:"0px",minWidth:"0px",opacity:"1.0",outlineColor:"invert",outlineOffset:"0px",outlineWidth:"3px",paddingBottom:"0px",paddingLeft:"0px",paddingRight:"0px",paddingTop:"0px",right:"auto",textIndent:"0px",textShadow:"0px 0px 0px transparent",top:"auto",transform:"",verticalAlign:"0px",visibility:"visible",width:"auto",wordSpacing:"normal",zIndex:"auto"};a.propertyInterpolation=d}(d,f),function(a,b){function c(b){var c=a.calculateActiveDuration(b),d=function(d){return a.calculateTimeFraction(c,d,b)};return d._totalDuration=b.delay+c+b.endDelay,d._isCurrent=function(d){var e=a.calculatePhase(c,d,b);return e===PhaseActive||e===PhaseBefore},d}b.KeyframeEffect=function(d,e,f){var g,h=c(a.normalizeTimingInput(f)),i=b.convertEffectInput(e),j=function(){i(d,g)};return j._update=function(a){return g=h(a),null!==g},j._clear=function(){i(d,null)},j._hasSameTarget=function(a){return d===a},j._isCurrent=h._isCurrent,j._totalDuration=h._totalDuration,j},b.NullEffect=function(a){var b=function(){a&&(a(),a=null)};return b._update=function(){return null},b._totalDuration=0,b._isCurrent=function(){return!1},b._hasSameTarget=function(){return!1},b}}(c,d,f),function(a){a.apply=function(b,c,d){b.style[a.propertyName(c)]=d},a.clear=function(b,c){b.style[a.propertyName(c)]=""}}(d,f),function(a){window.Element.prototype.animate=function(b,c){return a.timeline._play(a.KeyframeEffect(this,b,c))}}(d),function(a){function b(a,c,d){if("number"==typeof a&&"number"==typeof c)return a*(1-d)+c*d;if("boolean"==typeof a&&"boolean"==typeof c)return.5>d?a:c;if(a.length==c.length){for(var e=[],f=0;f<a.length;f++)e.push(b(a[f],c[f],d));return e}throw"Mismatched interpolation arguments "+a+":"+c}a.Interpolation=function(a,c,d){return function(e){return d(b(a,c,e))}}}(d,f),function(a,b){a.sequenceNumber=0;var c=function(a,b,c){this.target=a,this.currentTime=b,this.timelineTime=c,this.type="finish",this.bubbles=!1,this.cancelable=!1,this.currentTarget=a,this.defaultPrevented=!1,this.eventPhase=Event.AT_TARGET,this.timeStamp=Date.now()};b.Animation=function(b){this._sequenceNumber=a.sequenceNumber++,this._currentTime=0,this._startTime=null,this._paused=!1,this._playbackRate=1,this._inTimeline=!0,this._finishedFlag=!1,this.onfinish=null,this._finishHandlers=[],this._effect=b,this._inEffect=this._effect._update(0),this._idle=!0,this._currentTimePending=!1},b.Animation.prototype={_ensureAlive:function(){this._inEffect=this._effect._update(this.playbackRate<0&&0===this.currentTime?-1:this.currentTime),this._inTimeline||!this._inEffect&&this._finishedFlag||(this._inTimeline=!0,b.timeline._animations.push(this))},_tickCurrentTime:function(a,b){a!=this._currentTime&&(this._currentTime=a,this._isFinished&&!b&&(this._currentTime=this._playbackRate>0?this._totalDuration:0),this._ensureAlive())},get currentTime(){return this._idle||this._currentTimePending?null:this._currentTime},set currentTime(a){a=+a,isNaN(a)||(b.restart(),this._paused||null==this._startTime||(this._startTime=this._timeline.currentTime-a/this._playbackRate),this._currentTimePending=!1,this._currentTime!=a&&(this._tickCurrentTime(a,!0),b.invalidateEffects()))},get startTime(){return this._startTime},set startTime(a){a=+a,isNaN(a)||this._paused||this._idle||(this._startTime=a,this._tickCurrentTime((this._timeline.currentTime-this._startTime)*this.playbackRate),b.invalidateEffects())},get playbackRate(){return this._playbackRate},set playbackRate(a){if(a!=this._playbackRate){var b=this.currentTime;this._playbackRate=a,this._startTime=null,"paused"!=this.playState&&"idle"!=this.playState&&this.play(),null!=b&&(this.currentTime=b)}},get _isFinished(){return!this._idle&&(this._playbackRate>0&&this._currentTime>=this._totalDuration||this._playbackRate<0&&this._currentTime<=0)},get _totalDuration(){return this._effect._totalDuration},get playState(){return this._idle?"idle":null==this._startTime&&!this._paused&&0!=this.playbackRate||this._currentTimePending?"pending":this._paused?"paused":this._isFinished?"finished":"running"},play:function(){this._paused=!1,(this._isFinished||this._idle)&&(this._currentTime=this._playbackRate>0?0:this._totalDuration,this._startTime=null,b.invalidateEffects()),this._finishedFlag=!1,b.restart(),this._idle=!1,this._ensureAlive()},pause:function(){this._isFinished||this._paused||this._idle||(this._currentTimePending=!0),this._startTime=null,this._paused=!0},finish:function(){this._idle||(this.currentTime=this._playbackRate>0?this._totalDuration:0,this._startTime=this._totalDuration-this.currentTime,this._currentTimePending=!1)},cancel:function(){this._inEffect&&(this._inEffect=!1,this._idle=!0,this.currentTime=0,this._startTime=null,this._effect._update(null),b.invalidateEffects(),b.restart())},reverse:function(){this.playbackRate*=-1,this.play()},addEventListener:function(a,b){"function"==typeof b&&"finish"==a&&this._finishHandlers.push(b)},removeEventListener:function(a,b){if("finish"==a){var c=this._finishHandlers.indexOf(b);c>=0&&this._finishHandlers.splice(c,1)}},_fireEvents:function(a){var b=this._isFinished;if((b||this._idle)&&!this._finishedFlag){var d=new c(this,this._currentTime,a),e=this._finishHandlers.concat(this.onfinish?[this.onfinish]:[]);setTimeout(function(){e.forEach(function(a){a.call(d.target,d)})},0)}this._finishedFlag=b},_tick:function(a){return this._idle||this._paused||(null==this._startTime?this.startTime=a-this._currentTime/this.playbackRate:this._isFinished||this._tickCurrentTime((a-this._startTime)*this.playbackRate)),this._currentTimePending=!1,this._fireEvents(a),!this._idle&&(this._inEffect||!this._finishedFlag)}}}(c,d,f),function(a,b){function c(a){var b=i;i=[],a<s.currentTime&&(a=s.currentTime),g(a),b.forEach(function(b){b[1](a)}),o&&g(a),f(),l=void 0}function d(a,b){return a._sequenceNumber-b._sequenceNumber}function e(){this._animations=[],this.currentTime=window.performance&&performance.now?performance.now():0}function f(){p.forEach(function(a){a()}),p.length=0}function g(a){n=!1;var c=b.timeline;c.currentTime=a,c._animations.sort(d),m=!1;var e=c._animations;c._animations=[];var f=[],g=[];e=e.filter(function(b){return b._inTimeline=b._tick(a),b._inEffect?g.push(b._effect):f.push(b._effect),b._isFinished||b._paused||b._idle||(m=!0),b._inTimeline}),p.push.apply(p,f),p.push.apply(p,g),c._animations.push.apply(c._animations,e),o=!1,m&&requestAnimationFrame(function(){})}var h=window.requestAnimationFrame,i=[],j=0;window.requestAnimationFrame=function(a){var b=j++;return 0==i.length&&h(c),i.push([b,a]),b},window.cancelAnimationFrame=function(a){i.forEach(function(b){b[0]==a&&(b[1]=function(){})})},e.prototype={_play:function(c){c._timing=a.normalizeTimingInput(c.timing);var d=new b.Animation(c);return d._idle=!1,d._timeline=this,this._animations.push(d),b.restart(),b.invalidateEffects(),d}};var k,l=void 0,k=function(){return void 0==l&&(l=window.performance&&performance.now?performance.now():Date.now()),l},m=!1,n=!1;b.restart=function(){return m||(m=!0,requestAnimationFrame(function(){}),n=!0),n};var o=!1;b.invalidateEffects=function(){o=!0};var p=[],q=1e3/60,r=window.getComputedStyle;Object.defineProperty(window,"getComputedStyle",{configurable:!0,enumerable:!0,value:function(){if(o){var a=k();a-s.currentTime>0&&(s.currentTime+=q*(Math.floor((a-s.currentTime)/q)+1)),g(s.currentTime)}return f(),r.apply(this,arguments)}});var s=new e;b.timeline=s}(c,d,f),function(a){function b(a,b){var c=a.exec(b);return c?(c=a.ignoreCase?c[0].toLowerCase():c[0],[c,b.substr(c.length)]):void 0}function c(a,b){b=b.replace(/^\s*/,"");var c=a(b);return c?[c[0],c[1].replace(/^\s*/,"")]:void 0}function d(a,d,e){a=c.bind(null,a);for(var f=[];;){var g=a(e);if(!g)return[f,e];if(f.push(g[0]),e=g[1],g=b(d,e),!g||""==g[1])return[f,e];e=g[1]}}function e(a,b){for(var c=0,d=0;d<b.length&&(!/\s|,/.test(b[d])||0!=c);d++)if("("==b[d])c++;else if(")"==b[d]&&(c--,0==c&&d++,0>=c))break;var e=a(b.substr(0,d));return void 0==e?void 0:[e,b.substr(d)]}function f(a,b){for(var c=a,d=b;c&&d;)c>d?c%=d:d%=c;return c=a*b/(c+d)}function g(a){return function(b){var c=a(b);return c&&(c[0]=void 0),c}}function h(a,b){return function(c){var d=a(c);return d?d:[b,c]}}function i(b,c){for(var d=[],e=0;e<b.length;e++){var f=a.consumeTrimmed(b[e],c);if(!f||""==f[0])return;void 0!==f[0]&&d.push(f[0]),c=f[1]}return""==c?d:void 0}function j(a,b,c,d,e){for(var g=[],h=[],i=[],j=f(d.length,e.length),k=0;j>k;k++){var l=b(d[k%d.length],e[k%e.length]);if(!l)return;g.push(l[0]),h.push(l[1]),i.push(l[2])}return[g,h,function(b){var d=b.map(function(a,b){return i[b](a)}).join(c);return a?a(d):d}]}function k(a,b,c){for(var d=[],e=[],f=[],g=0,h=0;h<c.length;h++)if("function"==typeof c[h]){var i=c[h](a[g],b[g++]);d.push(i[0]),e.push(i[1]),f.push(i[2])}else!function(a){d.push(!1),e.push(!1),f.push(function(){return c[a]})}(h);return[d,e,function(a){for(var b="",c=0;c<a.length;c++)b+=f[c](a[c]);return b}]}a.consumeToken=b,a.consumeTrimmed=c,a.consumeRepeated=d,a.consumeParenthesised=e,a.ignore=g,a.optional=h,a.consumeList=i,a.mergeNestedRepeated=j.bind(null,null),a.mergeWrappedNestedRepeated=j,a.mergeList=k}(d),function(a){function b(b){function c(b){var c=a.consumeToken(/^inset/i,b);if(c)return d.inset=!0,c;var c=a.consumeLengthOrPercent(b);if(c)return d.lengths.push(c[0]),c;var c=a.consumeColor(b);return c?(d.color=c[0],c):void 0}var d={inset:!1,lengths:[],color:null},e=a.consumeRepeated(c,/^/,b);return e&&e[0].length?[d,e[1]]:void 0}function c(c){var d=a.consumeRepeated(b,/^,/,c);return d&&""==d[1]?d[0]:void 0}function d(b,c){for(;b.lengths.length<Math.max(b.lengths.length,c.lengths.length);)b.lengths.push({px:0});for(;c.lengths.length<Math.max(b.lengths.length,c.lengths.length);)c.lengths.push({px:0});if(b.inset==c.inset&&!!b.color==!!c.color){for(var d,e=[],f=[[],0],g=[[],0],h=0;h<b.lengths.length;h++){var i=a.mergeDimensions(b.lengths[h],c.lengths[h],2==h);f[0].push(i[0]),g[0].push(i[1]),e.push(i[2])}if(b.color&&c.color){var j=a.mergeColors(b.color,c.color);f[1]=j[0],g[1]=j[1],d=j[2]}return[f,g,function(a){for(var c=b.inset?"inset ":" ",f=0;f<e.length;f++)c+=e[f](a[0][f])+" ";return d&&(c+=d(a[1])),c}]}}function e(b,c,d,e){function f(a){return{inset:a,color:[0,0,0,0],lengths:[{px:0},{px:0},{px:0},{px:0}]}}for(var g=[],h=[],i=0;i<d.length||i<e.length;i++){var j=d[i]||f(e[i].inset),k=e[i]||f(d[i].inset);g.push(j),h.push(k)}return a.mergeNestedRepeated(b,c,g,h)}var f=e.bind(null,d,", ");a.addPropertiesHandler(c,f,["box-shadow","text-shadow"])}(d),function(a){function b(a){return a.toFixed(3).replace(".000","")}function c(a,b,c){return Math.min(b,Math.max(a,c))}function d(a){return/^\s*[-+]?(\d*\.)?\d+\s*$/.test(a)?Number(a):void 0}function e(a,c){return[a,c,b]}function f(a,b){return 0!=a?h(0,1/0)(a,b):void 0}function g(a,b){return[a,b,function(a){return Math.round(c(1,1/0,a))}]}function h(a,d){return function(e,f){return[e,f,function(e){return b(c(a,d,e))}]}}function i(a,b){return[a,b,Math.round]}a.clamp=c,a.addPropertiesHandler(d,h(0,1/0),["border-image-width","line-height"]),a.addPropertiesHandler(d,h(0,1),["opacity","shape-image-threshold"]),a.addPropertiesHandler(d,f,["flex-grow","flex-shrink"]),a.addPropertiesHandler(d,g,["orphans","widows"]),a.addPropertiesHandler(d,i,["z-index"]),a.parseNumber=d,a.mergeNumbers=e,a.numberToString=b}(d,f),function(a){function b(a,b){return"visible"==a||"visible"==b?[0,1,function(c){return 0>=c?a:c>=1?b:"visible"}]:void 0}a.addPropertiesHandler(String,b,["visibility"])}(d),function(a){function b(a){a=a.trim(),e.fillStyle="#000",e.fillStyle=a;var b=e.fillStyle;if(e.fillStyle="#fff",e.fillStyle=a,b==e.fillStyle){e.fillRect(0,0,1,1);var c=e.getImageData(0,0,1,1).data;e.clearRect(0,0,1,1);var d=c[3]/255;return[c[0]*d,c[1]*d,c[2]*d,d]}}function c(b,c){return[b,c,function(b){function c(a){return Math.max(0,Math.min(255,a))}if(b[3])for(var d=0;3>d;d++)b[d]=Math.round(c(b[d]/b[3]));return b[3]=a.numberToString(a.clamp(0,1,b[3])),"rgba("+b.join(",")+")"}]}var d=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");d.width=d.height=1;var e=d.getContext("2d");a.addPropertiesHandler(b,c,["background-color","border-bottom-color","border-left-color","border-right-color","border-top-color","color","outline-color","text-decoration-color"]),a.consumeColor=a.consumeParenthesised.bind(null,b),a.mergeColors=c}(d,f),function(a,b){function c(a,b){if(b=b.trim().toLowerCase(),"0"==b&&"px".search(a)>=0)return{px:0};if(/^[^(]*$|^calc/.test(b)){b=b.replace(/calc\(/g,"(");var c={};b=b.replace(a,function(a){return c[a]=null,"U"+a});for(var d="U("+a.source+")",e=b.replace(/[-+]?(\d*\.)?\d+/g,"N").replace(new RegExp("N"+d,"g"),"D").replace(/\s[+-]\s/g,"O").replace(/\s/g,""),f=[/N\*(D)/g,/(N|D)[*\/]N/g,/(N|D)O\1/g,/\((N|D)\)/g],g=0;g<f.length;)f[g].test(e)?(e=e.replace(f[g],"$1"),g=0):g++;if("D"==e){for(var h in c){var i=eval(b.replace(new RegExp("U"+h,"g"),"").replace(new RegExp(d,"g"),"*0"));if(!isFinite(i))return;c[h]=i}return c}}}function d(a,b){return e(a,b,!0)}function e(b,c,d){var e,f=[];for(e in b)f.push(e);for(e in c)f.indexOf(e)<0&&f.push(e);return b=f.map(function(a){return b[a]||0}),c=f.map(function(a){return c[a]||0}),[b,c,function(b){var c=b.map(function(c,e){return 1==b.length&&d&&(c=Math.max(c,0)),a.numberToString(c)+f[e]}).join(" + ");return b.length>1?"calc("+c+")":c}]}var f="px|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc",g=c.bind(null,new RegExp(f,"g")),h=c.bind(null,new RegExp(f+"|%","g")),i=c.bind(null,/deg|rad|grad|turn/g);a.parseLength=g,a.parseLengthOrPercent=h,a.consumeLengthOrPercent=a.consumeParenthesised.bind(null,h),a.parseAngle=i,a.mergeDimensions=e;var j=a.consumeParenthesised.bind(null,g),k=a.consumeRepeated.bind(void 0,j,/^/),l=a.consumeRepeated.bind(void 0,k,/^,/);a.consumeSizePairList=l;var m=function(a){var b=l(a);return b&&""==b[1]?b[0]:void 0},n=a.mergeNestedRepeated.bind(void 0,d," "),o=a.mergeNestedRepeated.bind(void 0,n,",");a.mergeNonNegativeSizePair=n,a.addPropertiesHandler(m,o,["background-size"]),a.addPropertiesHandler(h,d,["border-bottom-width","border-image-width","border-left-width","border-right-width","border-top-width","flex-basis","font-size","height","line-height","max-height","max-width","outline-width","width"]),a.addPropertiesHandler(h,e,["border-bottom-left-radius","border-bottom-right-radius","border-top-left-radius","border-top-right-radius","bottom","left","letter-spacing","margin-bottom","margin-left","margin-right","margin-top","min-height","min-width","outline-offset","padding-bottom","padding-left","padding-right","padding-top","perspective","right","shape-margin","text-indent","top","vertical-align","word-spacing"])}(d,f),function(a){function b(b){return a.consumeLengthOrPercent(b)||a.consumeToken(/^auto/,b)}function c(c){var d=a.consumeList([a.ignore(a.consumeToken.bind(null,/^rect/)),a.ignore(a.consumeToken.bind(null,/^\(/)),a.consumeRepeated.bind(null,b,/^,/),a.ignore(a.consumeToken.bind(null,/^\)/))],c);return d&&4==d[0].length?d[0]:void 0}function d(b,c){return"auto"==b||"auto"==c?[!0,!1,function(d){var e=d?b:c;if("auto"==e)return"auto";var f=a.mergeDimensions(e,e);return f[2](f[0])}]:a.mergeDimensions(b,c)}function e(a){return"rect("+a+")"}var f=a.mergeWrappedNestedRepeated.bind(null,e,d,", ");a.parseBox=c,a.mergeBoxes=f,a.addPropertiesHandler(c,f,["clip"])}(d,f),function(a){function b(a){return function(b){var c=0;return a.map(function(a){return a===j?b[c++]:a})}}function c(a){return a}function d(b){if(b=b.toLowerCase().trim(),"none"==b)return[];for(var c,d=/\s*(\w+)\(([^)]*)\)/g,e=[],f=0;c=d.exec(b);){if(c.index!=f)return;f=c.index+c[0].length;var g=c[1],h=m[g];if(!h)return;var i=c[2].split(","),j=h[0];if(j.length<i.length)return;for(var n=[],o=0;o<j.length;o++){var p,q=i[o],r=j[o];if(p=q?{A:function(b){return"0"==b.trim()?l:a.parseAngle(b)},N:a.parseNumber,T:a.parseLengthOrPercent,L:a.parseLength}[r.toUpperCase()](q):{a:l,n:n[0],t:k}[r],void 0===p)return;n.push(p)}if(e.push({t:g,d:n}),d.lastIndex==b.length)return e}}function e(a){return a.toFixed(6).replace(".000000","")}function f(b,c){if(b.decompositionPair!==c){b.decompositionPair=c;var d=a.makeMatrixDecomposition(b)}if(c.decompositionPair!==b){c.decompositionPair=b;var f=a.makeMatrixDecomposition(c)}return null==d[0]||null==f[0]?[[!1],[!0],function(a){return a?c[0].d:b[0].d}]:(d[0].push(0),f[0].push(1),[d,f,function(b){var c=a.quat(d[0][3],f[0][3],b[5]),g=a.composeMatrix(b[0],b[1],b[2],c,b[4]),h=g.map(e).join(",");return h}])}function g(a){return a.replace(/[xy]/,"")}function h(a){return a.replace(/(x|y|z|3d)?$/,"3d")}function i(b,c){var d=a.makeMatrixDecomposition&&!0,e=!1;if(!b.length||!c.length){b.length||(e=!0,b=c,c=[]);for(var i=0;i<b.length;i++){var j=b[i].t,k=b[i].d,l="scale"==j.substr(0,5)?1:0;c.push({t:j,d:k.map(function(a){if("number"==typeof a)return l;var b={};for(var c in a)b[c]=l;return b})})}}var n=function(a,b){return"perspective"==a&&"perspective"==b||("matrix"==a||"matrix3d"==a)&&("matrix"==b||"matrix3d"==b)},o=[],p=[],q=[];if(b.length!=c.length){if(!d)return;var r=f(b,c);o=[r[0]],p=[r[1]],q=[["matrix",[r[2]]]]}else for(var i=0;i<b.length;i++){var j,s=b[i].t,t=c[i].t,u=b[i].d,v=c[i].d,w=m[s],x=m[t];if(n(s,t)){if(!d)return;var r=f([b[i]],[c[i]]);o.push(r[0]),p.push(r[1]),q.push(["matrix",[r[2]]])}else{if(s==t)j=s;else if(w[2]&&x[2]&&g(s)==g(t))j=g(s),u=w[2](u),v=x[2](v);else{if(!w[1]||!x[1]||h(s)!=h(t)){if(!d)return;var r=f(b,c);o=[r[0]],p=[r[1]],q=[["matrix",[r[2]]]];break}j=h(s),u=w[1](u),v=x[1](v)}for(var y=[],z=[],A=[],B=0;B<u.length;B++){var C="number"==typeof u[B]?a.mergeNumbers:a.mergeDimensions,r=C(u[B],v[B]);y[B]=r[0],z[B]=r[1],A.push(r[2])}o.push(y),p.push(z),q.push([j,A])}}if(e){var D=o;o=p,p=D}return[o,p,function(a){return a.map(function(a,b){var c=a.map(function(a,c){return q[b][1][c](a)}).join(",");return"matrix"==q[b][0]&&16==c.split(",").length&&(q[b][0]="matrix3d"),q[b][0]+"("+c+")"}).join(" ")}]}var j=null,k={px:0},l={deg:0},m={matrix:["NNNNNN",[j,j,0,0,j,j,0,0,0,0,1,0,j,j,0,1],c],matrix3d:["NNNNNNNNNNNNNNNN",c],rotate:["A"],rotatex:["A"],rotatey:["A"],rotatez:["A"],rotate3d:["NNNA"],perspective:["L"],scale:["Nn",b([j,j,1]),c],scalex:["N",b([j,1,1]),b([j,1])],scaley:["N",b([1,j,1]),b([1,j])],scalez:["N",b([1,1,j])],scale3d:["NNN",c],skew:["Aa",null,c],skewx:["A",null,b([j,l])],skewy:["A",null,b([l,j])],translate:["Tt",b([j,j,k]),c],translatex:["T",b([j,k,k]),b([j,k])],translatey:["T",b([k,j,k]),b([k,j])],translatez:["L",b([k,k,j])],translate3d:["TTL",c]};a.addPropertiesHandler(d,i,["transform"])}(d,f),function(a){function b(a,b){b.concat([a]).forEach(function(b){b in document.documentElement.style&&(c[a]=b)})}var c={};b("transform",["webkitTransform","msTransform"]),b("transformOrigin",["webkitTransformOrigin"]),b("perspective",["webkitPerspective"]),b("perspectiveOrigin",["webkitPerspectiveOrigin"]),a.propertyName=function(a){return c[a]||a}}(d,f)}(),!function(a,b){function c(a){var b=window.document.timeline;b.currentTime=a,b._discardAnimations(),0==b._animations.length?e=!1:requestAnimationFrame(c)}var d=window.requestAnimationFrame;window.requestAnimationFrame=function(a){return d(function(b){window.document.timeline._updateAnimationsPromises(),a(b),window.document.timeline._updateAnimationsPromises()})},b.AnimationTimeline=function(){this._animations=[],this.currentTime=void 0},b.AnimationTimeline.prototype={getAnimations:function(){return this._discardAnimations(),this._animations.slice()},_updateAnimationsPromises:function(){b.animationsWithPromises=b.animationsWithPromises.filter(function(a){return a._updatePromises()})},_discardAnimations:function(){this._updateAnimationsPromises(),this._animations=this._animations.filter(function(a){return"finished"!=a.playState&&"idle"!=a.playState})},_play:function(a){var c=new b.Animation(a,this);return this._animations.push(c),b.restartWebAnimationsNextTick(),c._updatePromises(),c._animation.play(),c._updatePromises(),c},play:function(a){return a&&a.remove(),this._play(a)}};var e=!1;b.restartWebAnimationsNextTick=function(){e||(e=!0,requestAnimationFrame(c))};var f=new b.AnimationTimeline;b.timeline=f;try{Object.defineProperty(window.document,"timeline",{configurable:!0,get:function(){return f}})}catch(g){}try{window.document.timeline=f}catch(g){}}(c,e,f),function(a,b){b.animationsWithPromises=[],b.Animation=function(b,c){if(this.effect=b,b&&(b._animation=this),!c)throw new Error("Animation with null timeline is not supported");this._timeline=c,this._sequenceNumber=a.sequenceNumber++,this._holdTime=0,this._paused=!1,this._isGroup=!1,this._animation=null,this._childAnimations=[],this._callback=null,this._oldPlayState="idle",this._rebuildUnderlyingAnimation(),this._animation.cancel(),this._updatePromises()},b.Animation.prototype={_updatePromises:function(){var a=this._oldPlayState,b=this.playState;return this._readyPromise&&b!==a&&("idle"==b?(this._rejectReadyPromise(),this._readyPromise=void 0):"pending"==a?this._resolveReadyPromise():"pending"==b&&(this._readyPromise=void 0)),this._finishedPromise&&b!==a&&("idle"==b?(this._rejectFinishedPromise(),this._finishedPromise=void 0):"finished"==b?this._resolveFinishedPromise():"finished"==a&&(this._finishedPromise=void 0)),this._oldPlayState=this.playState,this._readyPromise||this._finishedPromise},_rebuildUnderlyingAnimation:function(){this._updatePromises();var a,c,d,e,f=this._animation?!0:!1;f&&(a=this.playbackRate,c=this._paused,d=this.startTime,e=this.currentTime,this._animation.cancel(),this._animation._wrapper=null,this._animation=null),(!this.effect||this.effect instanceof window.KeyframeEffect)&&(this._animation=b.newUnderlyingAnimationForKeyframeEffect(this.effect),b.bindAnimationForKeyframeEffect(this)),(this.effect instanceof window.SequenceEffect||this.effect instanceof window.GroupEffect)&&(this._animation=b.newUnderlyingAnimationForGroup(this.effect),b.bindAnimationForGroup(this)),this.effect&&this.effect._onsample&&b.bindAnimationForCustomEffect(this),f&&(1!=a&&(this.playbackRate=a),null!==d?this.startTime=d:null!==e?this.currentTime=e:null!==this._holdTime&&(this.currentTime=this._holdTime),c&&this.pause()),this._updatePromises()
},_updateChildren:function(){if(this.effect&&"idle"!=this.playState){var a=this.effect._timing.delay;this._childAnimations.forEach(function(c){this._arrangeChildren(c,a),this.effect instanceof window.SequenceEffect&&(a+=b.groupChildDuration(c.effect))}.bind(this))}},_setExternalAnimation:function(a){if(this.effect&&this._isGroup)for(var b=0;b<this.effect.children.length;b++)this.effect.children[b]._animation=a,this._childAnimations[b]._setExternalAnimation(a)},_constructChildAnimations:function(){if(this.effect&&this._isGroup){var a=this.effect._timing.delay;this._removeChildAnimations(),this.effect.children.forEach(function(c){var d=window.document.timeline._play(c);this._childAnimations.push(d),d.playbackRate=this.playbackRate,this._paused&&d.pause(),c._animation=this.effect._animation,this._arrangeChildren(d,a),this.effect instanceof window.SequenceEffect&&(a+=b.groupChildDuration(c))}.bind(this))}},_arrangeChildren:function(a,b){null===this.startTime?a.currentTime=this.currentTime-b/this.playbackRate:a.startTime!==this.startTime+b/this.playbackRate&&(a.startTime=this.startTime+b/this.playbackRate)},get timeline(){return this._timeline},get playState(){return this._animation?this._animation.playState:"idle"},get finished(){return window.Promise?(this._finishedPromise||(-1==b.animationsWithPromises.indexOf(this)&&b.animationsWithPromises.push(this),this._finishedPromise=new Promise(function(a,b){this._resolveFinishedPromise=function(){a(this)},this._rejectFinishedPromise=function(){b({type:DOMException.ABORT_ERR,name:"AbortError"})}}.bind(this)),"finished"==this.playState&&this._resolveFinishedPromise()),this._finishedPromise):(console.warn("Animation Promises require JavaScript Promise constructor"),null)},get ready(){return window.Promise?(this._readyPromise||(-1==b.animationsWithPromises.indexOf(this)&&b.animationsWithPromises.push(this),this._readyPromise=new Promise(function(a,b){this._resolveReadyPromise=function(){a(this)},this._rejectReadyPromise=function(){b({type:DOMException.ABORT_ERR,name:"AbortError"})}}.bind(this)),"pending"!==this.playState&&this._resolveReadyPromise()),this._readyPromise):(console.warn("Animation Promises require JavaScript Promise constructor"),null)},get onfinish(){return this._onfinish},set onfinish(a){"function"==typeof a?(this._onfinish=a,this._animation.onfinish=function(b){b.target=this,a.call(this,b)}.bind(this)):(this._animation.onfinish=a,this.onfinish=this._animation.onfinish)},get currentTime(){this._updatePromises();var a=this._animation.currentTime;return this._updatePromises(),a},set currentTime(a){this._updatePromises(),this._animation.currentTime=isFinite(a)?a:Math.sign(a)*Number.MAX_VALUE,this._register(),this._forEachChild(function(b,c){b.currentTime=a-c}),this._updatePromises()},get startTime(){return this._animation.startTime},set startTime(a){this._updatePromises(),this._animation.startTime=isFinite(a)?a:Math.sign(a)*Number.MAX_VALUE,this._register(),this._forEachChild(function(b,c){b.startTime=a+c}),this._updatePromises()},get playbackRate(){return this._animation.playbackRate},set playbackRate(a){this._updatePromises();var b=this.currentTime;this._animation.playbackRate=a,this._forEachChild(function(b){b.playbackRate=a}),"paused"!=this.playState&&"idle"!=this.playState&&this.play(),null!==b&&(this.currentTime=b),this._updatePromises()},play:function(){this._updatePromises(),this._paused=!1,this._animation.play(),-1==this._timeline._animations.indexOf(this)&&this._timeline._animations.push(this),this._register(),b.awaitStartTime(this),this._forEachChild(function(a){var b=a.currentTime;a.play(),a.currentTime=b}),this._updatePromises()},pause:function(){this._updatePromises(),this.currentTime&&(this._holdTime=this.currentTime),this._animation.pause(),this._register(),this._forEachChild(function(a){a.pause()}),this._paused=!0,this._updatePromises()},finish:function(){this._updatePromises(),this._animation.finish(),this._register(),this._updatePromises()},cancel:function(){this._updatePromises(),this._animation.cancel(),this._register(),this._removeChildAnimations(),this._updatePromises()},reverse:function(){this._updatePromises();var a=this.currentTime;this._animation.reverse(),this._forEachChild(function(a){a.reverse()}),null!==a&&(this.currentTime=a),this._updatePromises()},addEventListener:function(a,b){var c=b;"function"==typeof b&&(c=function(a){a.target=this,b.call(this,a)}.bind(this),b._wrapper=c),this._animation.addEventListener(a,c)},removeEventListener:function(a,b){this._animation.removeEventListener(a,b&&b._wrapper||b)},_removeChildAnimations:function(){for(;this._childAnimations.length;)this._childAnimations.pop().cancel()},_forEachChild:function(b){var c=0;if(this.effect.children&&this._childAnimations.length<this.effect.children.length&&this._constructChildAnimations(),this._childAnimations.forEach(function(a){b.call(this,a,c),this.effect instanceof window.SequenceEffect&&(c+=a.effect.activeDuration)}.bind(this)),"pending"!=this.playState){var d=this.effect._timing,e=this.currentTime;null!==e&&(e=a.calculateTimeFraction(a.calculateActiveDuration(d),e,d)),(null==e||isNaN(e))&&this._removeChildAnimations()}}},window.Animation=b.Animation}(c,e,f),function(a,b){function c(b){this._frames=a.normalizeKeyframes(b)}function d(){for(var a=!1;h.length;){var b=h.shift();b._updateChildren(),a=!0}return a}var e=function(a){if(a._animation=void 0,a instanceof window.SequenceEffect||a instanceof window.GroupEffect)for(var b=0;b<a.children.length;b++)e(a.children[b])};b.removeMulti=function(a){for(var b=[],c=0;c<a.length;c++){var d=a[c];d._parent?(-1==b.indexOf(d._parent)&&b.push(d._parent),d._parent.children.splice(d._parent.children.indexOf(d),1),d._parent=null,e(d)):d._animation&&d._animation.effect==d&&(d._animation.cancel(),d._animation.effect=new KeyframeEffect(null,[]),d._animation._callback&&(d._animation._callback._animation=null),d._animation._rebuildUnderlyingAnimation(),e(d))}for(c=0;c<b.length;c++)b[c]._rebuild()},b.KeyframeEffect=function(b,d,e){return this.target=b,this._parent=null,e=a.numericTimingToObject(e),this._timingInput=a.cloneTimingInput(e),this._timing=a.normalizeTimingInput(e),this.timing=a.makeTiming(e,!1,this),this.timing._effect=this,"function"==typeof d?(a.deprecated("Custom KeyframeEffect","2015-06-22","Use KeyframeEffect.onsample instead."),this._normalizedKeyframes=d):this._normalizedKeyframes=new c(d),this._keyframes=d,this.activeDuration=a.calculateActiveDuration(this._timing),this},b.KeyframeEffect.prototype={getFrames:function(){return"function"==typeof this._normalizedKeyframes?this._normalizedKeyframes:this._normalizedKeyframes._frames},set onsample(a){if("function"==typeof this.getFrames())throw new Error("Setting onsample on custom effect KeyframeEffect is not supported.");this._onsample=a,this._animation&&this._animation._rebuildUnderlyingAnimation()},get parent(){return this._parent},clone:function(){if("function"==typeof this.getFrames())throw new Error("Cloning custom effects is not supported.");var b=new KeyframeEffect(this.target,[],a.cloneTimingInput(this._timingInput));return b._normalizedKeyframes=this._normalizedKeyframes,b._keyframes=this._keyframes,b},remove:function(){b.removeMulti([this])}};var f=Element.prototype.animate;Element.prototype.animate=function(a,c){return b.timeline._play(new b.KeyframeEffect(this,a,c))};var g=document.createElementNS("http://www.w3.org/1999/xhtml","div");b.newUnderlyingAnimationForKeyframeEffect=function(a){if(a){var b=a.target||g,c=a._keyframes;"function"==typeof c&&(c=[]);var d=a._timingInput}else var b=g,c=[],d=0;return f.apply(b,[c,d])},b.bindAnimationForKeyframeEffect=function(a){a.effect&&"function"==typeof a.effect._normalizedKeyframes&&b.bindAnimationForCustomEffect(a)};var h=[];b.awaitStartTime=function(a){null===a.startTime&&a._isGroup&&(0==h.length&&requestAnimationFrame(d),h.push(a))};var i=window.getComputedStyle;Object.defineProperty(window,"getComputedStyle",{configurable:!0,enumerable:!0,value:function(){window.document.timeline._updateAnimationsPromises();var a=i.apply(this,arguments);return d()&&(a=i.apply(this,arguments)),window.document.timeline._updateAnimationsPromises(),a}}),window.KeyframeEffect=b.KeyframeEffect,window.Element.prototype.getAnimations=function(){return document.timeline.getAnimations().filter(function(a){return null!==a.effect&&a.effect.target==this}.bind(this))}}(c,e,f),function(a,b){function c(a){a._registered||(a._registered=!0,f.push(a),g||(g=!0,requestAnimationFrame(d)))}function d(){var a=f;f=[],a.sort(function(a,b){return a._sequenceNumber-b._sequenceNumber}),a=a.filter(function(a){a();var b=a._animation?a._animation.playState:"idle";return"running"!=b&&"pending"!=b&&(a._registered=!1),a._registered}),f.push.apply(f,a),f.length?(g=!0,requestAnimationFrame(d)):g=!1}var e=(document.createElementNS("http://www.w3.org/1999/xhtml","div"),0);b.bindAnimationForCustomEffect=function(b){var d,f=b.effect.target,g="function"==typeof b.effect.getFrames();d=g?b.effect.getFrames():b.effect._onsample;var h=b.effect.timing,i=null;h=a.normalizeTimingInput(h);var j=function(){var c=j._animation?j._animation.currentTime:null;null!==c&&(c=a.calculateTimeFraction(a.calculateActiveDuration(h),c,h),isNaN(c)&&(c=null)),c!==i&&(g?d(c,f,b.effect):d(c,b.effect,b.effect._animation)),i=c};j._animation=b,j._registered=!1,j._sequenceNumber=e++,b._callback=j,c(j)};var f=[],g=!1;b.Animation.prototype._register=function(){this._callback&&c(this._callback)}}(c,e,f),function(a,b){function c(a){return a._timing.delay+a.activeDuration+a._timing.endDelay}function d(b,c){this._parent=null,this.children=b||[],this._reparent(this.children),c=a.numericTimingToObject(c),this._timingInput=a.cloneTimingInput(c),this._timing=a.normalizeTimingInput(c,!0),this.timing=a.makeTiming(c,!0,this),this.timing._effect=this,"auto"===this._timing.duration&&(this._timing.duration=this.activeDuration)}window.SequenceEffect=function(){d.apply(this,arguments)},window.GroupEffect=function(){d.apply(this,arguments)},d.prototype={_isAncestor:function(a){for(var b=this;null!==b;){if(b==a)return!0;b=b._parent}return!1},_rebuild:function(){for(var a=this;a;)"auto"===a.timing.duration&&(a._timing.duration=a.activeDuration),a=a._parent;this._animation&&this._animation._rebuildUnderlyingAnimation()},_reparent:function(a){b.removeMulti(a);for(var c=0;c<a.length;c++)a[c]._parent=this},_putChild:function(a,b){for(var c=b?"Cannot append an ancestor or self":"Cannot prepend an ancestor or self",d=0;d<a.length;d++)if(this._isAncestor(a[d]))throw{type:DOMException.HIERARCHY_REQUEST_ERR,name:"HierarchyRequestError",message:c};for(var d=0;d<a.length;d++)b?this.children.push(a[d]):this.children.unshift(a[d]);this._reparent(a),this._rebuild()},append:function(){this._putChild(arguments,!0)},prepend:function(){this._putChild(arguments,!1)},get parent(){return this._parent},get firstChild(){return this.children.length?this.children[0]:null},get lastChild(){return this.children.length?this.children[this.children.length-1]:null},clone:function(){for(var b=a.cloneTimingInput(this._timingInput),c=[],d=0;d<this.children.length;d++)c.push(this.children[d].clone());return this instanceof GroupEffect?new GroupEffect(c,b):new SequenceEffect(c,b)},remove:function(){b.removeMulti([this])}},window.SequenceEffect.prototype=Object.create(d.prototype),Object.defineProperty(window.SequenceEffect.prototype,"activeDuration",{get:function(){var a=0;return this.children.forEach(function(b){a+=c(b)}),Math.max(a,0)}}),window.GroupEffect.prototype=Object.create(d.prototype),Object.defineProperty(window.GroupEffect.prototype,"activeDuration",{get:function(){var a=0;return this.children.forEach(function(b){a=Math.max(a,c(b))}),a}}),b.newUnderlyingAnimationForGroup=function(c){var d,e=null,f=function(b){var c=d._wrapper;return c&&"pending"!=c.playState&&c.effect?null==b?void c._removeChildAnimations():0==b&&c.playbackRate<0&&(e||(e=a.normalizeTimingInput(c.effect.timing)),b=a.calculateTimeFraction(a.calculateActiveDuration(e),-1,e),isNaN(b)||null==b)?(c._forEachChild(function(a){a.currentTime=-1}),void c._removeChildAnimations()):void 0:void 0},g=new KeyframeEffect(null,[],c._timing);return g.onsample=f,d=b.timeline._play(g)},b.bindAnimationForGroup=function(a){a._animation._wrapper=a,a._isGroup=!0,b.awaitStartTime(a),a._constructChildAnimations(),a._setExternalAnimation(a)},b.groupChildDuration=c}(c,e,f)}({},function(){return this}());
//# sourceMappingURL=web-animations-next-lite.min.js.map</script>
<script>

  Polymer({

    is: 'opaque-animation',

    behaviors: [
      Polymer.NeonAnimationBehavior
    ],

    configure: function(config) {
      var node = config.node;
      node.style.opacity = '0';
      this._effect = new KeyframeEffect(node, [
        {'opacity': '1'},
        {'opacity': '1'}
      ], this.timingFromConfig(config));
      return this._effect;
    },

    complete: function(config) {
      config.node.style.opacity = '';
    }

  });

</script>


<script>

  /**
   * `Polymer.NeonAnimatableBehavior` is implemented by elements containing animations for use with
   * elements implementing `Polymer.NeonAnimationRunnerBehavior`.
   * @polymerBehavior
   */
  Polymer.NeonAnimatableBehavior = {

    properties: {

      /**
       * Animation configuration. See README for more info.
       */
      animationConfig: {
        type: Object
      },

      /**
       * Convenience property for setting an 'entry' animation. Do not set `animationConfig.entry`
       * manually if using this. The animated node is set to `this` if using this property.
       */
      entryAnimation: {
        observer: '_entryAnimationChanged',
        type: String
      },

      /**
       * Convenience property for setting an 'exit' animation. Do not set `animationConfig.exit`
       * manually if using this. The animated node is set to `this` if using this property.
       */
      exitAnimation: {
        observer: '_exitAnimationChanged',
        type: String
      }

    },

    _entryAnimationChanged: function() {
      this.animationConfig = this.animationConfig || {};
      if (this.entryAnimation !== 'fade-in-animation') {
        // insert polyfill hack
        this.animationConfig['entry'] = [{
          name: 'opaque-animation',
          node: this
        }, {
          name: this.entryAnimation,
          node: this
        }];
      } else {
        this.animationConfig['entry'] = [{
          name: this.entryAnimation,
          node: this
        }];
      }
    },

    _exitAnimationChanged: function() {
      this.animationConfig = this.animationConfig || {};
      this.animationConfig['exit'] = [{
        name: this.exitAnimation,
        node: this
      }];
    },

    _copyProperties: function(config1, config2) {
      // shallowly copy properties from config2 to config1
      for (var property in config2) {
        config1[property] = config2[property];
      }
    },

    _cloneConfig: function(config) {
      var clone = {
        isClone: true
      };
      this._copyProperties(clone, config);
      return clone;
    },

    _getAnimationConfigRecursive: function(type, map, allConfigs) {
      if (!this.animationConfig) {
        return;
      }

      if(this.animationConfig.value && typeof this.animationConfig.value === 'function') {
      	this._warn(this._logf('playAnimation', "Please put 'animationConfig' inside of your components 'properties' object instead of outside of it."));
      	return;
      }

      // type is optional
      var thisConfig;
      if (type) {
        thisConfig = this.animationConfig[type];
      } else {
        thisConfig = this.animationConfig;
      }

      if (!Array.isArray(thisConfig)) {
        thisConfig = [thisConfig];
      }

      // iterate animations and recurse to process configurations from child nodes
      if (thisConfig) {
        for (var config, index = 0; config = thisConfig[index]; index++) {
          if (config.animatable) {
            config.animatable._getAnimationConfigRecursive(config.type || type, map, allConfigs);
          } else {
            if (config.id) {
              var cachedConfig = map[config.id];
              if (cachedConfig) {
                // merge configurations with the same id, making a clone lazily
                if (!cachedConfig.isClone) {
                  map[config.id] = this._cloneConfig(cachedConfig)
                  cachedConfig = map[config.id];
                }
                this._copyProperties(cachedConfig, config);
              } else {
                // put any configs with an id into a map
                map[config.id] = config;
              }
            } else {
              allConfigs.push(config);
            }
          }
        }
      }
    },

    /**
     * An element implementing `Polymer.NeonAnimationRunnerBehavior` calls this method to configure
     * an animation with an optional type. Elements implementing `Polymer.NeonAnimatableBehavior`
     * should define the property `animationConfig`, which is either a configuration object
     * or a map of animation type to array of configuration objects.
     */
    getAnimationConfig: function(type) {
      var map = {};
      var allConfigs = [];
      this._getAnimationConfigRecursive(type, map, allConfigs);
      // append the configurations saved in the map to the array
      for (var key in map) {
        allConfigs.push(map[key]);
      }
      return allConfigs;
    }

  };

</script>
<script>

  /**
   * `Polymer.NeonAnimationRunnerBehavior` adds a method to run animations.
   *
   * @polymerBehavior Polymer.NeonAnimationRunnerBehavior
   */
  Polymer.NeonAnimationRunnerBehaviorImpl = {

    properties: {

      /** @type {?Object} */
      _player: {
        type: Object
      }

    },

    _configureAnimationEffects: function(allConfigs) {
      var allAnimations = [];
      if (allConfigs.length > 0) {
        for (var config, index = 0; config = allConfigs[index]; index++) {
          var animation = document.createElement(config.name);
          // is this element actually a neon animation?
          if (animation.isNeonAnimation) {
            var effect = animation.configure(config);
            if (effect) {
              allAnimations.push({
                animation: animation,
                config: config,
                effect: effect
              });
            }
          } else {
            console.warn(this.is + ':', config.name, 'not found!');
          }
        }
      }
      return allAnimations;
    },

    _runAnimationEffects: function(allEffects) {
      return document.timeline.play(new GroupEffect(allEffects));
    },

    _completeAnimations: function(allAnimations) {
      for (var animation, index = 0; animation = allAnimations[index]; index++) {
        animation.animation.complete(animation.config);
      }
    },

    /**
     * Plays an animation with an optional `type`.
     * @param {string=} type
     * @param {!Object=} cookie
     */
    playAnimation: function(type, cookie) {
      var allConfigs = this.getAnimationConfig(type);
      if (!allConfigs) {
        return;
      }
      var allAnimations = this._configureAnimationEffects(allConfigs);
      var allEffects = allAnimations.map(function(animation) {
        return animation.effect;
      });

      if (allEffects.length > 0) {
        this._player = this._runAnimationEffects(allEffects);
        this._player.onfinish = function() {
          this._completeAnimations(allAnimations);

          if (this._player) {
            this._player.cancel();
            this._player = null;
          }

          this.fire('neon-animation-finish', cookie, {bubbles: false});
        }.bind(this);

      } else {
        this.fire('neon-animation-finish', cookie, {bubbles: false});
      }
    },

    /**
     * Cancels the currently running animation.
     */
    cancelAnimation: function() {
      if (this._player) {
        this._player.cancel();
      }
    }
  };

  /** @polymerBehavior Polymer.NeonAnimationRunnerBehavior */
  Polymer.NeonAnimationRunnerBehavior = [
    Polymer.NeonAnimatableBehavior,
    Polymer.NeonAnimationRunnerBehaviorImpl
  ];
</script>


<script>

  Polymer({

    is: 'fade-in-animation',

    behaviors: [
      Polymer.NeonAnimationBehavior
    ],

    configure: function(config) {
      var node = config.node;
      this._effect = new KeyframeEffect(node, [
        {'opacity': '0'},
        {'opacity': '1'}
      ], this.timingFromConfig(config));
      return this._effect;
    }

  });

</script>


<script>

  Polymer({

    is: 'fade-out-animation',

    behaviors: [
      Polymer.NeonAnimationBehavior
    ],

    configure: function(config) {
      var node = config.node;
      this._effect = new KeyframeEffect(node, [
        {'opacity': '1'},
        {'opacity': '0'}
      ], this.timingFromConfig(config));
      return this._effect;
    }

  });

</script>


<dom-module id="paper-tooltip" assetpath="bower_components/paper-tooltip/">
  <template>
    <style>
      :host {
        display: block;
        position: absolute;
        outline: none;
        z-index: 1002;
        -moz-user-select: none;
        -ms-user-select: none;
        -webkit-user-select: none;
        user-select: none;
        cursor: default;
      }

      #tooltip {
        display: block;
        outline: none;
        @apply(--paper-font-common-base);
        font-size: 10px;
        line-height: 1;

        background-color: var(--paper-tooltip-background, #616161);
        opacity: var(--paper-tooltip-opacity, 0.9);
        color: var(--paper-tooltip-text-color, white);

        padding: 8px;
        border-radius: 2px;

        @apply(--paper-tooltip);
      }

      /* Thanks IE 10. */
      .hidden {
        display: none !important;
      }
    </style>

    <div id="tooltip" class="hidden">
      <content></content>
    </div>
  </template>

  <script>
    Polymer({
      is: 'paper-tooltip',

      hostAttributes: {
        role: 'tooltip',
        tabindex: -1
      },

      behaviors: [
        Polymer.NeonAnimationRunnerBehavior
      ],

      properties: {
        /**
         * The id of the element that the tooltip is anchored to. This element
         * must be a sibling of the tooltip.
         */
        for: {
          type: String,
          observer: '_forChanged'
        },

        /**
         * Set this to true if you want to manually control when the tooltip
         * is shown or hidden.
         */
        manualMode: {
          type: Boolean,
          value: false
        },

        /**
         * Positions the tooltip to the top, right, bottom, left of its content.
         */
        position: {
          type: String,
          value: 'bottom'
        },

        /**
         * If true, no parts of the tooltip will ever be shown offscreen.
         */
        fitToVisibleBounds: {
          type: Boolean,
          value: false
        },

        /**
         * The spacing between the top of the tooltip and the element it is
         * anchored to.
         */
        offset: {
          type: Number,
          value: 14
        },

        /**
         * This property is deprecated, but left over so that it doesn't
         * break exiting code. Please use `offset` instead. If both `offset` and
         * `marginTop` are provided, `marginTop` will be ignored.
         * @deprecated since version 1.0.3
         */
        marginTop: {
          type: Number,
          value: 14
        },

        /**
         * The delay that will be applied before the `entry` animation is
         * played when showing the tooltip.
         */
        animationDelay: {
          type: Number,
          value: 500
        },

        /**
         * The entry and exit animations that will be played when showing and
         * hiding the tooltip. If you want to override this, you must ensure
         * that your animationConfig has the exact format below.
         */
        animationConfig: {
          type: Object,
          value: function() {
            return {
              'entry': [{
                name: 'fade-in-animation',
                node: this,
                timing: {delay: 0}
              }],
              'exit': [{
                name: 'fade-out-animation',
                node: this
              }]
            }
          }
        },

        _showing: {
          type: Boolean,
          value: false
        }
      },

      listeners: {
        'neon-animation-finish': '_onAnimationFinish',
        'mouseenter': 'hide'
      },

      /**
       * Returns the target element that this tooltip is anchored to. It is
       * either the element given by the `for` attribute, or the immediate parent
       * of the tooltip.
       */
      get target () {
        var parentNode = Polymer.dom(this).parentNode;
        // If the parentNode is a document fragment, then we need to use the host.
        var ownerRoot = Polymer.dom(this).getOwnerRoot();

        var target;
        if (this.for) {
          target = Polymer.dom(ownerRoot).querySelector('#' + this.for);
        } else {
          target = parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE ?
              ownerRoot.host : parentNode;
        }

        return target;
      },

      attached: function() {
        this._target = this.target;

        if (this.manualMode)
          return;

        this.listen(this._target, 'mouseenter', 'show');
        this.listen(this._target, 'focus', 'show');
        this.listen(this._target, 'mouseleave', 'hide');
        this.listen(this._target, 'blur', 'hide');
        this.listen(this._target, 'tap', 'hide');
      },

      detached: function() {
        if (this._target && !this.manualMode) {
          this.unlisten(this._target, 'mouseenter', 'show');
          this.unlisten(this._target, 'focus', 'show');
          this.unlisten(this._target, 'mouseleave', 'hide');
          this.unlisten(this._target, 'blur', 'hide');
          this.unlisten(this._target, 'tap', 'hide');
        }
      },

      show: function() {
        // If the tooltip is already showing, there's nothing to do.
        if (this._showing)
          return;

        if (Polymer.dom(this).textContent.trim() === '')
          return;


        this.cancelAnimation();
        this._showing = true;
        this.toggleClass('hidden', false, this.$.tooltip);
        this.updatePosition();

        this.animationConfig.entry[0].timing.delay = this.animationDelay;
        this._animationPlaying = true;
        this.playAnimation('entry');
      },

      hide: function() {
        // If the tooltip is already hidden, there's nothing to do.
        if (!this._showing) {
          return;
        }

        // If the entry animation is still playing, don't try to play the exit
        // animation since this will reset the opacity to 1. Just end the animation.
        if (this._animationPlaying) {
          this.cancelAnimation();
          this._showing = false;
          this._onAnimationFinish();
          return;
        }

        this._showing = false;
        this._animationPlaying = true;
        this.playAnimation('exit');
      },

      _forChanged: function() {
        this._target = this.target;
      },

      updatePosition: function() {
        if (!this._target || !this.offsetParent)
          return;

        var offset = this.offset;
        // If a marginTop has been provided by the user (pre 1.0.3), use it.
        if (this.marginTop != 14 && this.offset == 14)
          offset = this.marginTop;

        var parentRect = this.offsetParent.getBoundingClientRect();
        var targetRect = this._target.getBoundingClientRect();
        var thisRect = this.getBoundingClientRect();

        var horizontalCenterOffset = (targetRect.width - thisRect.width) / 2;
        var verticalCenterOffset = (targetRect.height - thisRect.height) / 2;

        var targetLeft = targetRect.left - parentRect.left;
        var targetTop = targetRect.top - parentRect.top;

        var tooltipLeft, tooltipTop;

        switch (this.position) {
          case 'top':
            tooltipLeft = targetLeft + horizontalCenterOffset;
            tooltipTop = targetTop - thisRect.height - offset;
            break;
          case 'bottom':
            tooltipLeft = targetLeft + horizontalCenterOffset;
            tooltipTop = targetTop + targetRect.height + offset;
            break;
          case 'left':
            tooltipLeft = targetLeft - thisRect.width - offset;
            tooltipTop = targetTop + verticalCenterOffset;
            break;
          case 'right':
            tooltipLeft = targetLeft + targetRect.width + offset;
            tooltipTop = targetTop + verticalCenterOffset;
            break;
        }

        // TODO(noms): This should use IronFitBehavior if possible.
        if (this.fitToVisibleBounds) {
          // Clip the left/right side.
          if (tooltipLeft + thisRect.width > window.innerWidth) {
            this.style.right = '0px';
            this.style.left = 'auto';
          } else {
            this.style.left = Math.max(0, tooltipLeft) + 'px';
            this.style.right = 'auto';
          }

          // Clip the top/bottom side.
          if (tooltipTop + thisRect.height > window.innerHeight) {
            this.style.bottom = '0px';
            this.style.top = 'auto';
          } else {
            this.style.top = Math.max(0, tooltipTop) + 'px';
            this.style.bottom = 'auto';
          }
        } else {
          this.style.left = tooltipLeft + 'px';
          this.style.top = tooltipTop + 'px';
        }

      },

      _onAnimationFinish: function() {
        this._animationPlaying = false;
        if (!this._showing) {
          this.toggleClass('hidden', true, this.$.tooltip);
        }
      },
    });
  </script>
</dom-module>


<style>
  /* IE 10 support for HTML5 hidden attr */
  [hidden] {
    display: none !important;
  }
</style>

<style is="custom-style">
  :root {

    --layout: {
      display: -ms-flexbox;
      display: -webkit-flex;
      display: flex;
    };

    --layout-inline: {
      display: -ms-inline-flexbox;
      display: -webkit-inline-flex;
      display: inline-flex;
    };

    --layout-horizontal: {
      @apply(--layout);

      -ms-flex-direction: row;
      -webkit-flex-direction: row;
      flex-direction: row;
    };

    --layout-horizontal-reverse: {
      @apply(--layout);

      -ms-flex-direction: row-reverse;
      -webkit-flex-direction: row-reverse;
      flex-direction: row-reverse;
    };

    --layout-vertical: {
      @apply(--layout);

      -ms-flex-direction: column;
      -webkit-flex-direction: column;
      flex-direction: column;
    };

    --layout-vertical-reverse: {
      @apply(--layout);

      -ms-flex-direction: column-reverse;
      -webkit-flex-direction: column-reverse;
      flex-direction: column-reverse;
    };

    --layout-wrap: {
      -ms-flex-wrap: wrap;
      -webkit-flex-wrap: wrap;
      flex-wrap: wrap;
    };

    --layout-wrap-reverse: {
      -ms-flex-wrap: wrap-reverse;
      -webkit-flex-wrap: wrap-reverse;
      flex-wrap: wrap-reverse;
    };

    --layout-flex-auto: {
      -ms-flex: 1 1 auto;
      -webkit-flex: 1 1 auto;
      flex: 1 1 auto;
    };

    --layout-flex-none: {
      -ms-flex: none;
      -webkit-flex: none;
      flex: none;
    };

    --layout-flex: {
      -ms-flex: 1 1 0.000000001px;
      -webkit-flex: 1;
      flex: 1;
      -webkit-flex-basis: 0.000000001px;
      flex-basis: 0.000000001px;
    };

    --layout-flex-2: {
      -ms-flex: 2;
      -webkit-flex: 2;
      flex: 2;
    };

    --layout-flex-3: {
      -ms-flex: 3;
      -webkit-flex: 3;
      flex: 3;
    };

    --layout-flex-4: {
      -ms-flex: 4;
      -webkit-flex: 4;
      flex: 4;
    };

    --layout-flex-5: {
      -ms-flex: 5;
      -webkit-flex: 5;
      flex: 5;
    };

    --layout-flex-6: {
      -ms-flex: 6;
      -webkit-flex: 6;
      flex: 6;
    };

    --layout-flex-7: {
      -ms-flex: 7;
      -webkit-flex: 7;
      flex: 7;
    };

    --layout-flex-8: {
      -ms-flex: 8;
      -webkit-flex: 8;
      flex: 8;
    };

    --layout-flex-9: {
      -ms-flex: 9;
      -webkit-flex: 9;
      flex: 9;
    };

    --layout-flex-10: {
      -ms-flex: 10;
      -webkit-flex: 10;
      flex: 10;
    };

    --layout-flex-11: {
      -ms-flex: 11;
      -webkit-flex: 11;
      flex: 11;
    };

    --layout-flex-12: {
      -ms-flex: 12;
      -webkit-flex: 12;
      flex: 12;
    };

    /* alignment in cross axis */

    --layout-start: {
      -ms-flex-align: start;
      -webkit-align-items: flex-start;
      align-items: flex-start;
    };

    --layout-center: {
      -ms-flex-align: center;
      -webkit-align-items: center;
      align-items: center;
    };

    --layout-end: {
      -ms-flex-align: end;
      -webkit-align-items: flex-end;
      align-items: flex-end;
    };

    --layout-baseline: {
      -ms-flex-align: baseline;
      -webkit-align-items: baseline;
      align-items: baseline;
    };

    /* alignment in main axis */

    --layout-start-justified: {
      -ms-flex-pack: start;
      -webkit-justify-content: flex-start;
      justify-content: flex-start;
    };

    --layout-center-justified: {
      -ms-flex-pack: center;
      -webkit-justify-content: center;
      justify-content: center;
    };

    --layout-end-justified: {
      -ms-flex-pack: end;
      -webkit-justify-content: flex-end;
      justify-content: flex-end;
    };

    --layout-around-justified: {
      -ms-flex-pack: distribute;
      -webkit-justify-content: space-around;
      justify-content: space-around;
    };

    --layout-justified: {
      -ms-flex-pack: justify;
      -webkit-justify-content: space-between;
      justify-content: space-between;
    };

    --layout-center-center: {
      @apply(--layout-center);
      @apply(--layout-center-justified);
    };

    /* self alignment */

    --layout-self-start: {
      -ms-align-self: flex-start;
      -webkit-align-self: flex-start;
      align-self: flex-start;
    };

    --layout-self-center: {
      -ms-align-self: center;
      -webkit-align-self: center;
      align-self: center;
    };

    --layout-self-end: {
      -ms-align-self: flex-end;
      -webkit-align-self: flex-end;
      align-self: flex-end;
    };

    --layout-self-stretch: {
      -ms-align-self: stretch;
      -webkit-align-self: stretch;
      align-self: stretch;
    };

    --layout-self-baseline: {
      -ms-align-self: baseline;
      -webkit-align-self: baseline;
      align-self: baseline;
    };

    /* multi-line alignment in main axis */

    --layout-start-aligned: {
      -ms-flex-line-pack: start;  /* IE10 */
      -ms-align-content: flex-start;
      -webkit-align-content: flex-start;
      align-content: flex-start;
    };

    --layout-end-aligned: {
      -ms-flex-line-pack: end;  /* IE10 */
      -ms-align-content: flex-end;
      -webkit-align-content: flex-end;
      align-content: flex-end;
    };

    --layout-center-aligned: {
      -ms-flex-line-pack: center;  /* IE10 */
      -ms-align-content: center;
      -webkit-align-content: center;
      align-content: center;
    };

    --layout-between-aligned: {
      -ms-flex-line-pack: justify;  /* IE10 */
      -ms-align-content: space-between;
      -webkit-align-content: space-between;
      align-content: space-between;
    };

    --layout-around-aligned: {
      -ms-flex-line-pack: distribute;  /* IE10 */
      -ms-align-content: space-around;
      -webkit-align-content: space-around;
      align-content: space-around;
    };

    /*******************************
              Other Layout
    *******************************/

    --layout-block: {
      display: block;
    };

    --layout-invisible: {
      visibility: hidden !important;
    };

    --layout-relative: {
      position: relative;
    };

    --layout-fit: {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
    };

    --layout-scroll: {
      -webkit-overflow-scrolling: touch;
      overflow: auto;
    };

    --layout-fullbleed: {
      margin: 0;
      height: 100vh;
    };

    /* fixed position */

    --layout-fixed-top: {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
    };

    --layout-fixed-right: {
      position: fixed;
      top: 0;
      right: 0;
      bottom: 0;
    };

    --layout-fixed-bottom: {
      position: fixed;
      right: 0;
      bottom: 0;
      left: 0;
    };

    --layout-fixed-left: {
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
    };

  }

</style>


<dom-module id="iron-icon" assetpath="bower_components/iron-icon/">

  <style>
    :host {
      @apply(--layout-inline);
      @apply(--layout-center-center);
      position: relative;

      vertical-align: middle;

      fill: var(--iron-icon-fill-color, currentcolor);
      stroke: var(--iron-icon-stroke-color, none);

      width: var(--iron-icon-width, 24px);
      height: var(--iron-icon-height, 24px);
    }
  </style>

  <template>
  </template>

  <script>

    Polymer({

      is: 'iron-icon',

      properties: {

        /**
         * The name of the icon to use. The name should be of the form:
         * `iconset_name:icon_name`.
         */
        icon: {
          type: String,
          observer: '_iconChanged'
        },

        /**
         * The name of the theme to used, if one is specified by the
         * iconset.
         */
        theme: {
          type: String,
          observer: '_updateIcon'
        },

        /**
         * If using iron-icon without an iconset, you can set the src to be
         * the URL of an individual icon image file. Note that this will take
         * precedence over a given icon attribute.
         */
        src: {
          type: String,
          observer: '_srcChanged'
        },

        /**
         * @type {!Polymer.IronMeta}
         */
        _meta: {
          value: Polymer.Base.create('iron-meta', {type: 'iconset'}),
          observer: '_updateIcon'
        }

      },

      _DEFAULT_ICONSET: 'icons',

      _iconChanged: function(icon) {
        var parts = (icon || '').split(':');
        this._iconName = parts.pop();
        this._iconsetName = parts.pop() || this._DEFAULT_ICONSET;
        this._updateIcon();
      },

      _srcChanged: function(src) {
        this._updateIcon();
      },

      _usesIconset: function() {
        return this.icon || !this.src;
      },

      /** @suppress {visibility} */
      _updateIcon: function() {
        if (this._usesIconset()) {
          if (this._img && this._img.parentNode) {
            Polymer.dom(this.root).removeChild(this._img);
          }
          if (this._iconName === "") {
            if (this._iconset) {
              this._iconset.removeIcon(this);
            }
          } else if (this._iconsetName && this._meta) {
            this._iconset = /** @type {?Polymer.Iconset} */ (
              this._meta.byKey(this._iconsetName));
            if (this._iconset) {
              this._iconset.applyIcon(this, this._iconName, this.theme);
              this.unlisten(window, 'iron-iconset-added', '_updateIcon');
            } else {
              this.listen(window, 'iron-iconset-added', '_updateIcon');
            }
          }
        } else {
          if (this._iconset) {
            this._iconset.removeIcon(this);
          }
          if (!this._img) {
            this._img = document.createElement('img');
            this._img.style.width = '100%';
            this._img.style.height = '100%';
            this._img.draggable = false;
          }
          this._img.src = this.src;
          Polymer.dom(this.root).appendChild(this._img);
        }
      }

    });

  </script>

</dom-module>
<script>
  (function() {
    'use strict';

    /**
     * Chrome uses an older version of DOM Level 3 Keyboard Events
     *
     * Most keys are labeled as text, but some are Unicode codepoints.
     * Values taken from: http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/keyset.html#KeySet-Set
     */
    var KEY_IDENTIFIER = {
      'U+0008': 'backspace',
      'U+0009': 'tab',
      'U+001B': 'esc',
      'U+0020': 'space',
      'U+007F': 'del'
    };

    /**
     * Special table for KeyboardEvent.keyCode.
     * KeyboardEvent.keyIdentifier is better, and KeyBoardEvent.key is even better
     * than that.
     *
     * Values from: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent.keyCode#Value_of_keyCode
     */
    var KEY_CODE = {
      8: 'backspace',
      9: 'tab',
      13: 'enter',
      27: 'esc',
      33: 'pageup',
      34: 'pagedown',
      35: 'end',
      36: 'home',
      32: 'space',
      37: 'left',
      38: 'up',
      39: 'right',
      40: 'down',
      46: 'del',
      106: '*'
    };

    /**
     * MODIFIER_KEYS maps the short name for modifier keys used in a key
     * combo string to the property name that references those same keys
     * in a KeyboardEvent instance.
     */
    var MODIFIER_KEYS = {
      'shift': 'shiftKey',
      'ctrl': 'ctrlKey',
      'alt': 'altKey',
      'meta': 'metaKey'
    };

    /**
     * KeyboardEvent.key is mostly represented by printable character made by
     * the keyboard, with unprintable keys labeled nicely.
     *
     * However, on OS X, Alt+char can make a Unicode character that follows an
     * Apple-specific mapping. In this case, we fall back to .keyCode.
     */
    var KEY_CHAR = /[a-z0-9*]/;

    /**
     * Matches a keyIdentifier string.
     */
    var IDENT_CHAR = /U\+/;

    /**
     * Matches arrow keys in Gecko 27.0+
     */
    var ARROW_KEY = /^arrow/;

    /**
     * Matches space keys everywhere (notably including IE10's exceptional name
     * `spacebar`).
     */
    var SPACE_KEY = /^space(bar)?/;

    /**
     * Matches ESC key.
     *
     * Value from: http://w3c.github.io/uievents-key/#key-Escape
     */
    var ESC_KEY = /^escape$/;

    /**
     * Transforms the key.
     * @param {string} key The KeyBoardEvent.key
     * @param {Boolean} [noSpecialChars] Limits the transformation to
     * alpha-numeric characters.
     */
    function transformKey(key, noSpecialChars) {
      var validKey = '';
      if (key) {
        var lKey = key.toLowerCase();
        if (lKey === ' ' || SPACE_KEY.test(lKey)) {
          validKey = 'space';
        } else if (ESC_KEY.test(lKey)) {
          validKey = 'esc';
        } else if (lKey.length == 1) {
          if (!noSpecialChars || KEY_CHAR.test(lKey)) {
            validKey = lKey;
          }
        } else if (ARROW_KEY.test(lKey)) {
          validKey = lKey.replace('arrow', '');
        } else if (lKey == 'multiply') {
          // numpad '*' can map to Multiply on IE/Windows
          validKey = '*';
        } else {
          validKey = lKey;
        }
      }
      return validKey;
    }

    function transformKeyIdentifier(keyIdent) {
      var validKey = '';
      if (keyIdent) {
        if (keyIdent in KEY_IDENTIFIER) {
          validKey = KEY_IDENTIFIER[keyIdent];
        } else if (IDENT_CHAR.test(keyIdent)) {
          keyIdent = parseInt(keyIdent.replace('U+', '0x'), 16);
          validKey = String.fromCharCode(keyIdent).toLowerCase();
        } else {
          validKey = keyIdent.toLowerCase();
        }
      }
      return validKey;
    }

    function transformKeyCode(keyCode) {
      var validKey = '';
      if (Number(keyCode)) {
        if (keyCode >= 65 && keyCode <= 90) {
          // ascii a-z
          // lowercase is 32 offset from uppercase
          validKey = String.fromCharCode(32 + keyCode);
        } else if (keyCode >= 112 && keyCode <= 123) {
          // function keys f1-f12
          validKey = 'f' + (keyCode - 112);
        } else if (keyCode >= 48 && keyCode <= 57) {
          // top 0-9 keys
          validKey = String(keyCode - 48);
        } else if (keyCode >= 96 && keyCode <= 105) {
          // num pad 0-9
          validKey = String(keyCode - 96);
        } else {
          validKey = KEY_CODE[keyCode];
        }
      }
      return validKey;
    }

    /**
      * Calculates the normalized key for a KeyboardEvent.
      * @param {KeyboardEvent} keyEvent
      * @param {Boolean} [noSpecialChars] Set to true to limit keyEvent.key
      * transformation to alpha-numeric chars. This is useful with key
      * combinations like shift + 2, which on FF for MacOS produces
      * keyEvent.key = @
      * To get 2 returned, set noSpecialChars = true
      * To get @ returned, set noSpecialChars = false
     */
    function normalizedKeyForEvent(keyEvent, noSpecialChars) {
      // Fall back from .key, to .keyIdentifier, to .keyCode, and then to
      // .detail.key to support artificial keyboard events.
      return transformKey(keyEvent.key, noSpecialChars) ||
        transformKeyIdentifier(keyEvent.keyIdentifier) ||
        transformKeyCode(keyEvent.keyCode) ||
        transformKey(keyEvent.detail.key, noSpecialChars) || '';
    }

    function keyComboMatchesEvent(keyCombo, event) {
      // For combos with modifiers we support only alpha-numeric keys
      var keyEvent = normalizedKeyForEvent(event, keyCombo.hasModifiers);
      return keyEvent === keyCombo.key &&
        (!keyCombo.hasModifiers || (
          !!event.shiftKey === !!keyCombo.shiftKey &&
          !!event.ctrlKey === !!keyCombo.ctrlKey &&
          !!event.altKey === !!keyCombo.altKey &&
          !!event.metaKey === !!keyCombo.metaKey)
        );
    }

    function parseKeyComboString(keyComboString) {
      if (keyComboString.length === 1) {
        return {
          combo: keyComboString,
          key: keyComboString,
          event: 'keydown'
        };
      }
      return keyComboString.split('+').reduce(function(parsedKeyCombo, keyComboPart) {
        var eventParts = keyComboPart.split(':');
        var keyName = eventParts[0];
        var event = eventParts[1];

        if (keyName in MODIFIER_KEYS) {
          parsedKeyCombo[MODIFIER_KEYS[keyName]] = true;
          parsedKeyCombo.hasModifiers = true;
        } else if (keyName === "only"){
          parsedKeyCombo.hasModifiers = true;
        } else {
          parsedKeyCombo.key = keyName;
          parsedKeyCombo.event = event || 'keydown';
        }

        return parsedKeyCombo;
      }, {
        combo: keyComboString.split(':').shift()
      });
    }

    function parseEventString(eventString) {
      return eventString.trim().split(' ').map(function(keyComboString) {
        return parseKeyComboString(keyComboString);
      });
    }

    /**
     * `Polymer.IronA11yKeysBehavior` provides a normalized interface for processing
     * keyboard commands that pertain to [WAI-ARIA best practices](http://www.w3.org/TR/wai-aria-practices/#kbd_general_binding).
     * The element takes care of browser differences with respect to Keyboard events
     * and uses an expressive syntax to filter key presses.
     *
     * Use the `keyBindings` prototype property to express what combination of keys
     * will trigger the event to fire.
     *
     * Use the `key-event-target` attribute to set up event handlers on a specific
     * node.
     * The `keys-pressed` event will fire when one of the key combinations set with the
     * `keys` property is pressed.
     *
     * @demo demo/index.html
     * @polymerBehavior
     */
    Polymer.IronA11yKeysBehavior = {
      properties: {
        /**
         * The HTMLElement that will be firing relevant KeyboardEvents.
         */
        keyEventTarget: {
          type: Object,
          value: function() {
            return this;
          }
        },

        /**
         * If true, this property will cause the implementing element to
         * automatically stop propagation on any handled KeyboardEvents.
         */
        stopKeyboardEventPropagation: {
          type: Boolean,
          value: false
        },

        _boundKeyHandlers: {
          type: Array,
          value: function() {
            return [];
          }
        },

        // We use this due to a limitation in IE10 where instances will have
        // own properties of everything on the "prototype".
        _imperativeKeyBindings: {
          type: Object,
          value: function() {
            return {};
          }
        }
      },

      observers: [
        '_resetKeyEventListeners(keyEventTarget, _boundKeyHandlers)'
      ],

      keyBindings: {},

      registered: function() {
        this._prepKeyBindings();
      },

      attached: function() {
        this._listenKeyEventListeners();
      },

      detached: function() {
        this._unlistenKeyEventListeners();
      },

      /**
       * Can be used to imperatively add a key binding to the implementing
       * element. This is the imperative equivalent of declaring a keybinding
       * in the `keyBindings` prototype property.
       */
      addOwnKeyBinding: function(eventString, handlerName) {
        this._imperativeKeyBindings[eventString] = handlerName;
        this._prepKeyBindings();
        this._resetKeyEventListeners();
      },

      /**
       * When called, will remove all imperatively-added key bindings.
       */
      removeOwnKeyBindings: function() {
        this._imperativeKeyBindings = {};
        this._prepKeyBindings();
        this._resetKeyEventListeners();
      },

      /**
       * Returns true if a keyboard event matches `eventString`.
       *
       * @param {KeyboardEvent} event
       * @param {string} eventString
       * @return {boolean}
       */
      keyboardEventMatchesKeys: function(event, eventString) {
        var keyCombos = parseEventString(eventString);
        for (var i = 0; i < keyCombos.length; ++i) {
          if (keyComboMatchesEvent(keyCombos[i], event)) {
            return true;
          }
        }
        return false;
      },

      _collectKeyBindings: function() {
        var keyBindings = this.behaviors.map(function(behavior) {
          return behavior.keyBindings;
        });

        if (keyBindings.indexOf(this.keyBindings) === -1) {
          keyBindings.push(this.keyBindings);
        }

        return keyBindings;
      },

      _prepKeyBindings: function() {
        this._keyBindings = {};

        this._collectKeyBindings().forEach(function(keyBindings) {
          for (var eventString in keyBindings) {
            this._addKeyBinding(eventString, keyBindings[eventString]);
          }
        }, this);

        for (var eventString in this._imperativeKeyBindings) {
          this._addKeyBinding(eventString, this._imperativeKeyBindings[eventString]);
        }

        // Give precedence to combos with modifiers to be checked first.
        for (var eventName in this._keyBindings) {
          this._keyBindings[eventName].sort(function (kb1, kb2) {
            var b1 = kb1[0].hasModifiers;
            var b2 = kb2[0].hasModifiers;
            return (b1 === b2) ? 0 : b1 ? -1 : 1;
          })
        }
      },

      _addKeyBinding: function(eventString, handlerName) {
        parseEventString(eventString).forEach(function(keyCombo) {
          this._keyBindings[keyCombo.event] =
            this._keyBindings[keyCombo.event] || [];

          this._keyBindings[keyCombo.event].push([
            keyCombo,
            handlerName
          ]);
        }, this);
      },

      _resetKeyEventListeners: function() {
        this._unlistenKeyEventListeners();

        if (this.isAttached) {
          this._listenKeyEventListeners();
        }
      },

      _listenKeyEventListeners: function() {
        Object.keys(this._keyBindings).forEach(function(eventName) {
          var keyBindings = this._keyBindings[eventName];
          var boundKeyHandler = this._onKeyBindingEvent.bind(this, keyBindings);

          this._boundKeyHandlers.push([this.keyEventTarget, eventName, boundKeyHandler]);

          this.keyEventTarget.addEventListener(eventName, boundKeyHandler);
        }, this);
      },

      _unlistenKeyEventListeners: function() {
        var keyHandlerTuple;
        var keyEventTarget;
        var eventName;
        var boundKeyHandler;

        while (this._boundKeyHandlers.length) {
          // My kingdom for block-scope binding and destructuring assignment..
          keyHandlerTuple = this._boundKeyHandlers.pop();
          keyEventTarget = keyHandlerTuple[0];
          eventName = keyHandlerTuple[1];
          boundKeyHandler = keyHandlerTuple[2];

          keyEventTarget.removeEventListener(eventName, boundKeyHandler);
        }
      },

      _onKeyBindingEvent: function(keyBindings, event) {
        if (this.stopKeyboardEventPropagation) {
          event.stopPropagation();
        }

        // if event has been already prevented, don't do anything
        if (event.defaultPrevented) {
          return;
        }

        for (var i = 0; i < keyBindings.length; i++) {
          var keyCombo = keyBindings[i][0];
          var handlerName = keyBindings[i][1];
          if (keyComboMatchesEvent(keyCombo, event)) {
            this._triggerKeyHandler(keyCombo, handlerName, event);
            // exit the loop if eventDefault was prevented
            if (event.defaultPrevented) {
              return;
            }
          }
        }
      },

      _triggerKeyHandler: function(keyCombo, handlerName, keyboardEvent) {
        var detail = Object.create(keyCombo);
        detail.keyboardEvent = keyboardEvent;
        var event = new CustomEvent(keyCombo.event, {
          detail: detail,
          cancelable: true
        });
        this[handlerName].call(this, event);
        if (event.defaultPrevented) {
          keyboardEvent.preventDefault();
        }
      }
    };
  })();
</script>
<script>

  /**
   * @demo demo/index.html
   * @polymerBehavior
   */
  Polymer.IronControlState = {

    properties: {

      /**
       * If true, the element currently has focus.
       */
      focused: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true,
        reflectToAttribute: true
      },

      /**
       * If true, the user cannot interact with this element.
       */
      disabled: {
        type: Boolean,
        value: false,
        notify: true,
        observer: '_disabledChanged',
        reflectToAttribute: true
      },

      _oldTabIndex: {
        type: Number
      },

      _boundFocusBlurHandler: {
        type: Function,
        value: function() {
          return this._focusBlurHandler.bind(this);
        }
      }

    },

    observers: [
      '_changedControlState(focused, disabled)'
    ],

    ready: function() {
      this.addEventListener('focus', this._boundFocusBlurHandler, true);
      this.addEventListener('blur', this._boundFocusBlurHandler, true);
    },

    _focusBlurHandler: function(event) {
      // NOTE(cdata):  if we are in ShadowDOM land, `event.target` will
      // eventually become `this` due to retargeting; if we are not in
      // ShadowDOM land, `event.target` will eventually become `this` due
      // to the second conditional which fires a synthetic event (that is also
      // handled). In either case, we can disregard `event.path`.

      if (event.target === this) {
        this._setFocused(event.type === 'focus');
      } else if (!this.shadowRoot && !this.isLightDescendant(event.target)) {
        this.fire(event.type, {sourceEvent: event}, {
          node: this,
          bubbles: event.bubbles,
          cancelable: event.cancelable
        });
      }
    },

    _disabledChanged: function(disabled, old) {
      this.setAttribute('aria-disabled', disabled ? 'true' : 'false');
      this.style.pointerEvents = disabled ? 'none' : '';
      if (disabled) {
        this._oldTabIndex = this.tabIndex;
        this.focused = false;
        this.tabIndex = -1;
        this.blur();
      } else if (this._oldTabIndex !== undefined) {
        this.tabIndex = this._oldTabIndex;
      }
    },

    _changedControlState: function() {
      // _controlStateChanged is abstract, follow-on behaviors may implement it
      if (this._controlStateChanged) {
        this._controlStateChanged();
      }
    }

  };

</script>
<script>

  /**
   * @demo demo/index.html
   * @polymerBehavior Polymer.IronButtonState
   */
  Polymer.IronButtonStateImpl = {

    properties: {

      /**
       * If true, the user is currently holding down the button.
       */
      pressed: {
        type: Boolean,
        readOnly: true,
        value: false,
        reflectToAttribute: true,
        observer: '_pressedChanged'
      },

      /**
       * If true, the button toggles the active state with each tap or press
       * of the spacebar.
       */
      toggles: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },

      /**
       * If true, the button is a toggle and is currently in the active state.
       */
      active: {
        type: Boolean,
        value: false,
        notify: true,
        reflectToAttribute: true
      },

      /**
       * True if the element is currently being pressed by a "pointer," which
       * is loosely defined as mouse or touch input (but specifically excluding
       * keyboard input).
       */
      pointerDown: {
        type: Boolean,
        readOnly: true,
        value: false
      },

      /**
       * True if the input device that caused the element to receive focus
       * was a keyboard.
       */
      receivedFocusFromKeyboard: {
        type: Boolean,
        readOnly: true
      },

      /**
       * The aria attribute to be set if the button is a toggle and in the
       * active state.
       */
      ariaActiveAttribute: {
        type: String,
        value: 'aria-pressed',
        observer: '_ariaActiveAttributeChanged'
      }
    },

    listeners: {
      down: '_downHandler',
      up: '_upHandler',
      tap: '_tapHandler'
    },

    observers: [
      '_detectKeyboardFocus(focused)',
      '_activeChanged(active, ariaActiveAttribute)'
    ],

    keyBindings: {
      'enter:keydown': '_asyncClick',
      'space:keydown': '_spaceKeyDownHandler',
      'space:keyup': '_spaceKeyUpHandler',
    },

    _mouseEventRe: /^mouse/,

    _tapHandler: function() {
      if (this.toggles) {
       // a tap is needed to toggle the active state
        this._userActivate(!this.active);
      } else {
        this.active = false;
      }
    },

    _detectKeyboardFocus: function(focused) {
      this._setReceivedFocusFromKeyboard(!this.pointerDown && focused);
    },

    // to emulate native checkbox, (de-)activations from a user interaction fire
    // 'change' events
    _userActivate: function(active) {
      if (this.active !== active) {
        this.active = active;
        this.fire('change');
      }
    },

    _downHandler: function(event) {
      this._setPointerDown(true);
      this._setPressed(true);
      this._setReceivedFocusFromKeyboard(false);
    },

    _upHandler: function() {
      this._setPointerDown(false);
      this._setPressed(false);
    },

    /**
     * @param {!KeyboardEvent} event .
     */
    _spaceKeyDownHandler: function(event) {
      var keyboardEvent = event.detail.keyboardEvent;
      var target = Polymer.dom(keyboardEvent).localTarget;

      // Ignore the event if this is coming from a focused light child, since that
      // element will deal with it.
      if (this.isLightDescendant(/** @type {Node} */(target)))
        return;

      keyboardEvent.preventDefault();
      keyboardEvent.stopImmediatePropagation();
      this._setPressed(true);
    },

    /**
     * @param {!KeyboardEvent} event .
     */
    _spaceKeyUpHandler: function(event) {
      var keyboardEvent = event.detail.keyboardEvent;
      var target = Polymer.dom(keyboardEvent).localTarget;

      // Ignore the event if this is coming from a focused light child, since that
      // element will deal with it.
      if (this.isLightDescendant(/** @type {Node} */(target)))
        return;

      if (this.pressed) {
        this._asyncClick();
      }
      this._setPressed(false);
    },

    // trigger click asynchronously, the asynchrony is useful to allow one
    // event handler to unwind before triggering another event
    _asyncClick: function() {
      this.async(function() {
        this.click();
      }, 1);
    },

    // any of these changes are considered a change to button state

    _pressedChanged: function(pressed) {
      this._changedButtonState();
    },

    _ariaActiveAttributeChanged: function(value, oldValue) {
      if (oldValue && oldValue != value && this.hasAttribute(oldValue)) {
        this.removeAttribute(oldValue);
      }
    },

    _activeChanged: function(active, ariaActiveAttribute) {
      if (this.toggles) {
        this.setAttribute(this.ariaActiveAttribute,
                          active ? 'true' : 'false');
      } else {
        this.removeAttribute(this.ariaActiveAttribute);
      }
      this._changedButtonState();
    },

    _controlStateChanged: function() {
      if (this.disabled) {
        this._setPressed(false);
      } else {
        this._changedButtonState();
      }
    },

    // provide hook for follow-on behaviors to react to button-state

    _changedButtonState: function() {
      if (this._buttonStateChanged) {
        this._buttonStateChanged(); // abstract
      }
    }

  };

  /** @polymerBehavior */
  Polymer.IronButtonState = [
    Polymer.IronA11yKeysBehavior,
    Polymer.IronButtonStateImpl
  ];

</script>


<dom-module id="paper-ripple" assetpath="bower_components/paper-ripple/">

  

  <template>
    <style>
      :host {
        display: block;
        position: absolute;
        border-radius: inherit;
        overflow: hidden;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;

        /* See PolymerElements/paper-behaviors/issues/34. On non-Chrome browsers,
         * creating a node (with a position:absolute) in the middle of an event
         * handler "interrupts" that event handler (which happens when the
         * ripple is created on demand) */
        pointer-events: none;
      }

      :host([animating]) {
        /* This resolves a rendering issue in Chrome (as of 40) where the
           ripple is not properly clipped by its parent (which may have
           rounded corners). See: http://jsbin.com/temexa/4

           Note: We only apply this style conditionally. Otherwise, the browser
           will create a new compositing layer for every ripple element on the
           page, and that would be bad. */
        -webkit-transform: translate(0, 0);
        transform: translate3d(0, 0, 0);
      }

      #background,
      #waves,
      .wave-container,
      .wave {
        pointer-events: none;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      #background,
      .wave {
        opacity: 0;
      }

      #waves,
      .wave {
        overflow: hidden;
      }

      .wave-container,
      .wave {
        border-radius: 50%;
      }

      :host(.circle) #background,
      :host(.circle) #waves {
        border-radius: 50%;
      }

      :host(.circle) .wave-container {
        overflow: hidden;
      }
    </style>

    <div id="background"></div>
    <div id="waves"></div>
  </template>
</dom-module>
<script>
  (function() {
    var Utility = {
      distance: function(x1, y1, x2, y2) {
        var xDelta = (x1 - x2);
        var yDelta = (y1 - y2);

        return Math.sqrt(xDelta * xDelta + yDelta * yDelta);
      },

      now: window.performance && window.performance.now ?
          window.performance.now.bind(window.performance) : Date.now
    };

    /**
     * @param {HTMLElement} element
     * @constructor
     */
    function ElementMetrics(element) {
      this.element = element;
      this.width = this.boundingRect.width;
      this.height = this.boundingRect.height;

      this.size = Math.max(this.width, this.height);
    }

    ElementMetrics.prototype = {
      get boundingRect () {
        return this.element.getBoundingClientRect();
      },

      furthestCornerDistanceFrom: function(x, y) {
        var topLeft = Utility.distance(x, y, 0, 0);
        var topRight = Utility.distance(x, y, this.width, 0);
        var bottomLeft = Utility.distance(x, y, 0, this.height);
        var bottomRight = Utility.distance(x, y, this.width, this.height);

        return Math.max(topLeft, topRight, bottomLeft, bottomRight);
      }
    };

    /**
     * @param {HTMLElement} element
     * @constructor
     */
    function Ripple(element) {
      this.element = element;
      this.color = window.getComputedStyle(element).color;

      this.wave = document.createElement('div');
      this.waveContainer = document.createElement('div');
      this.wave.style.backgroundColor = this.color;
      this.wave.classList.add('wave');
      this.waveContainer.classList.add('wave-container');
      Polymer.dom(this.waveContainer).appendChild(this.wave);

      this.resetInteractionState();
    }

    Ripple.MAX_RADIUS = 300;

    Ripple.prototype = {
      get recenters() {
        return this.element.recenters;
      },

      get center() {
        return this.element.center;
      },

      get mouseDownElapsed() {
        var elapsed;

        if (!this.mouseDownStart) {
          return 0;
        }

        elapsed = Utility.now() - this.mouseDownStart;

        if (this.mouseUpStart) {
          elapsed -= this.mouseUpElapsed;
        }

        return elapsed;
      },

      get mouseUpElapsed() {
        return this.mouseUpStart ?
          Utility.now () - this.mouseUpStart : 0;
      },

      get mouseDownElapsedSeconds() {
        return this.mouseDownElapsed / 1000;
      },

      get mouseUpElapsedSeconds() {
        return this.mouseUpElapsed / 1000;
      },

      get mouseInteractionSeconds() {
        return this.mouseDownElapsedSeconds + this.mouseUpElapsedSeconds;
      },

      get initialOpacity() {
        return this.element.initialOpacity;
      },

      get opacityDecayVelocity() {
        return this.element.opacityDecayVelocity;
      },

      get radius() {
        var width2 = this.containerMetrics.width * this.containerMetrics.width;
        var height2 = this.containerMetrics.height * this.containerMetrics.height;
        var waveRadius = Math.min(
          Math.sqrt(width2 + height2),
          Ripple.MAX_RADIUS
        ) * 1.1 + 5;

        var duration = 1.1 - 0.2 * (waveRadius / Ripple.MAX_RADIUS);
        var timeNow = this.mouseInteractionSeconds / duration;
        var size = waveRadius * (1 - Math.pow(80, -timeNow));

        return Math.abs(size);
      },

      get opacity() {
        if (!this.mouseUpStart) {
          return this.initialOpacity;
        }

        return Math.max(
          0,
          this.initialOpacity - this.mouseUpElapsedSeconds * this.opacityDecayVelocity
        );
      },

      get outerOpacity() {
        // Linear increase in background opacity, capped at the opacity
        // of the wavefront (waveOpacity).
        var outerOpacity = this.mouseUpElapsedSeconds * 0.3;
        var waveOpacity = this.opacity;

        return Math.max(
          0,
          Math.min(outerOpacity, waveOpacity)
        );
      },

      get isOpacityFullyDecayed() {
        return this.opacity < 0.01 &&
          this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
      },

      get isRestingAtMaxRadius() {
        return this.opacity >= this.initialOpacity &&
          this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
      },

      get isAnimationComplete() {
        return this.mouseUpStart ?
          this.isOpacityFullyDecayed : this.isRestingAtMaxRadius;
      },

      get translationFraction() {
        return Math.min(
          1,
          this.radius / this.containerMetrics.size * 2 / Math.sqrt(2)
        );
      },

      get xNow() {
        if (this.xEnd) {
          return this.xStart + this.translationFraction * (this.xEnd - this.xStart);
        }

        return this.xStart;
      },

      get yNow() {
        if (this.yEnd) {
          return this.yStart + this.translationFraction * (this.yEnd - this.yStart);
        }

        return this.yStart;
      },

      get isMouseDown() {
        return this.mouseDownStart && !this.mouseUpStart;
      },

      resetInteractionState: function() {
        this.maxRadius = 0;
        this.mouseDownStart = 0;
        this.mouseUpStart = 0;

        this.xStart = 0;
        this.yStart = 0;
        this.xEnd = 0;
        this.yEnd = 0;
        this.slideDistance = 0;

        this.containerMetrics = new ElementMetrics(this.element);
      },

      draw: function() {
        var scale;
        var translateString;
        var dx;
        var dy;

        this.wave.style.opacity = this.opacity;

        scale = this.radius / (this.containerMetrics.size / 2);
        dx = this.xNow - (this.containerMetrics.width / 2);
        dy = this.yNow - (this.containerMetrics.height / 2);


        // 2d transform for safari because of border-radius and overflow:hidden clipping bug.
        // https://bugs.webkit.org/show_bug.cgi?id=98538
        this.waveContainer.style.webkitTransform = 'translate(' + dx + 'px, ' + dy + 'px)';
        this.waveContainer.style.transform = 'translate3d(' + dx + 'px, ' + dy + 'px, 0)';
        this.wave.style.webkitTransform = 'scale(' + scale + ',' + scale + ')';
        this.wave.style.transform = 'scale3d(' + scale + ',' + scale + ',1)';
      },

      /** @param {Event=} event */
      downAction: function(event) {
        var xCenter = this.containerMetrics.width / 2;
        var yCenter = this.containerMetrics.height / 2;

        this.resetInteractionState();
        this.mouseDownStart = Utility.now();

        if (this.center) {
          this.xStart = xCenter;
          this.yStart = yCenter;
          this.slideDistance = Utility.distance(
            this.xStart, this.yStart, this.xEnd, this.yEnd
          );
        } else {
          this.xStart = event ?
              event.detail.x - this.containerMetrics.boundingRect.left :
              this.containerMetrics.width / 2;
          this.yStart = event ?
              event.detail.y - this.containerMetrics.boundingRect.top :
              this.containerMetrics.height / 2;
        }

        if (this.recenters) {
          this.xEnd = xCenter;
          this.yEnd = yCenter;
          this.slideDistance = Utility.distance(
            this.xStart, this.yStart, this.xEnd, this.yEnd
          );
        }

        this.maxRadius = this.containerMetrics.furthestCornerDistanceFrom(
          this.xStart,
          this.yStart
        );

        this.waveContainer.style.top =
          (this.containerMetrics.height - this.containerMetrics.size) / 2 + 'px';
        this.waveContainer.style.left =
          (this.containerMetrics.width - this.containerMetrics.size) / 2 + 'px';

        this.waveContainer.style.width = this.containerMetrics.size + 'px';
        this.waveContainer.style.height = this.containerMetrics.size + 'px';
      },

      /** @param {Event=} event */
      upAction: function(event) {
        if (!this.isMouseDown) {
          return;
        }

        this.mouseUpStart = Utility.now();
      },

      remove: function() {
        Polymer.dom(this.waveContainer.parentNode).removeChild(
          this.waveContainer
        );
      }
    };

    Polymer({
      is: 'paper-ripple',

      behaviors: [
        Polymer.IronA11yKeysBehavior
      ],

      properties: {
        /**
         * The initial opacity set on the wave.
         *
         * @attribute initialOpacity
         * @type number
         * @default 0.25
         */
        initialOpacity: {
          type: Number,
          value: 0.25
        },

        /**
         * How fast (opacity per second) the wave fades out.
         *
         * @attribute opacityDecayVelocity
         * @type number
         * @default 0.8
         */
        opacityDecayVelocity: {
          type: Number,
          value: 0.8
        },

        /**
         * If true, ripples will exhibit a gravitational pull towards
         * the center of their container as they fade away.
         *
         * @attribute recenters
         * @type boolean
         * @default false
         */
        recenters: {
          type: Boolean,
          value: false
        },

        /**
         * If true, ripples will center inside its container
         *
         * @attribute recenters
         * @type boolean
         * @default false
         */
        center: {
          type: Boolean,
          value: false
        },

        /**
         * A list of the visual ripples.
         *
         * @attribute ripples
         * @type Array
         * @default []
         */
        ripples: {
          type: Array,
          value: function() {
            return [];
          }
        },

        /**
         * True when there are visible ripples animating within the
         * element.
         */
        animating: {
          type: Boolean,
          readOnly: true,
          reflectToAttribute: true,
          value: false
        },

        /**
         * If true, the ripple will remain in the "down" state until `holdDown`
         * is set to false again.
         */
        holdDown: {
          type: Boolean,
          value: false,
          observer: '_holdDownChanged'
        },

        /**
         * If true, the ripple will not generate a ripple effect
         * via pointer interaction.
         * Calling ripple's imperative api like `simulatedRipple` will
         * still generate the ripple effect.
         */
        noink: {
          type: Boolean,
          value: false
        },

        _animating: {
          type: Boolean
        },

        _boundAnimate: {
          type: Function,
          value: function() {
            return this.animate.bind(this);
          }
        }
      },

      get target () {
        var ownerRoot = Polymer.dom(this).getOwnerRoot();
        var target;

        if (this.parentNode.nodeType == 11) { // DOCUMENT_FRAGMENT_NODE
          target = ownerRoot.host;
        } else {
          target = this.parentNode;
        }

        return target;
      },

      keyBindings: {
        'enter:keydown': '_onEnterKeydown',
        'space:keydown': '_onSpaceKeydown',
        'space:keyup': '_onSpaceKeyup'
      },

      attached: function() {
        // Set up a11yKeysBehavior to listen to key events on the target,
        // so that space and enter activate the ripple even if the target doesn't
        // handle key events. The key handlers deal with `noink` themselves.
        this.keyEventTarget = this.target;
        this.listen(this.target, 'up', 'uiUpAction');
        this.listen(this.target, 'down', 'uiDownAction');
      },

      detached: function() {
        this.unlisten(this.target, 'up', 'uiUpAction');
        this.unlisten(this.target, 'down', 'uiDownAction');
      },

      get shouldKeepAnimating () {
        for (var index = 0; index < this.ripples.length; ++index) {
          if (!this.ripples[index].isAnimationComplete) {
            return true;
          }
        }

        return false;
      },

      simulatedRipple: function() {
        this.downAction(null);

        // Please see polymer/polymer#1305
        this.async(function() {
          this.upAction();
        }, 1);
      },

      /**
       * Provokes a ripple down effect via a UI event,
       * respecting the `noink` property.
       * @param {Event=} event
       */
      uiDownAction: function(event) {
        if (!this.noink) {
          this.downAction(event);
        }
      },

      /**
       * Provokes a ripple down effect via a UI event,
       * *not* respecting the `noink` property.
       * @param {Event=} event
       */
      downAction: function(event) {
        if (this.holdDown && this.ripples.length > 0) {
          return;
        }

        var ripple = this.addRipple();

        ripple.downAction(event);

        if (!this._animating) {
          this.animate();
        }
      },

      /**
       * Provokes a ripple up effect via a UI event,
       * respecting the `noink` property.
       * @param {Event=} event
       */
      uiUpAction: function(event) {
        if (!this.noink) {
          this.upAction(event);
        }
      },

      /**
       * Provokes a ripple up effect via a UI event,
       * *not* respecting the `noink` property.
       * @param {Event=} event
       */
      upAction: function(event) {
        if (this.holdDown) {
          return;
        }

        this.ripples.forEach(function(ripple) {
          ripple.upAction(event);
        });

        this.animate();
      },

      onAnimationComplete: function() {
        this._animating = false;
        this.$.background.style.backgroundColor = null;
        this.fire('transitionend');
      },

      addRipple: function() {
        var ripple = new Ripple(this);

        Polymer.dom(this.$.waves).appendChild(ripple.waveContainer);
        this.$.background.style.backgroundColor = ripple.color;
        this.ripples.push(ripple);

        this._setAnimating(true);

        return ripple;
      },

      removeRipple: function(ripple) {
        var rippleIndex = this.ripples.indexOf(ripple);

        if (rippleIndex < 0) {
          return;
        }

        this.ripples.splice(rippleIndex, 1);

        ripple.remove();

        if (!this.ripples.length) {
          this._setAnimating(false);
        }
      },

      animate: function() {
        var index;
        var ripple;

        this._animating = true;

        for (index = 0; index < this.ripples.length; ++index) {
          ripple = this.ripples[index];

          ripple.draw();

          this.$.background.style.opacity = ripple.outerOpacity;

          if (ripple.isOpacityFullyDecayed && !ripple.isRestingAtMaxRadius) {
            this.removeRipple(ripple);
          }
        }

        if (!this.shouldKeepAnimating && this.ripples.length === 0) {
          this.onAnimationComplete();
        } else {
          window.requestAnimationFrame(this._boundAnimate);
        }
      },

      _onEnterKeydown: function() {
        this.uiDownAction();
        this.async(this.uiUpAction, 1);
      },

      _onSpaceKeydown: function() {
        this.uiDownAction();
      },

      _onSpaceKeyup: function() {
        this.uiUpAction();
      },

      // note: holdDown does not respect noink since it can be a focus based
      // effect.
      _holdDownChanged: function(newVal, oldVal) {
        if (oldVal === undefined) {
          return;
        }
        if (newVal) {
          this.downAction();
        } else {
          this.upAction();
        }
      }
    });
  })();
</script>
<script>

  /**
   * `Polymer.PaperRippleBehavior` dynamically implements a ripple
   * when the element has focus via pointer or keyboard.
   *
   * NOTE: This behavior is intended to be used in conjunction with and after
   * `Polymer.IronButtonState` and `Polymer.IronControlState`.
   *
   * @polymerBehavior Polymer.PaperRippleBehavior
   */
  Polymer.PaperRippleBehavior = {

    properties: {
      /**
       * If true, the element will not produce a ripple effect when interacted
       * with via the pointer.
       */
      noink: {
        type: Boolean,
        observer: '_noinkChanged'
      },

      /**
       * @type {Element|undefined}
       */
      _rippleContainer: {
        type: Object,
      }
    },

    /**
     * Ensures a `<paper-ripple>` element is available when the element is
     * focused.
     */
    _buttonStateChanged: function() {
      if (this.focused) {
        this.ensureRipple();
      }
    },

    /**
     * In addition to the functionality provided in `IronButtonState`, ensures
     * a ripple effect is created when the element is in a `pressed` state.
     */
    _downHandler: function(event) {
      Polymer.IronButtonStateImpl._downHandler.call(this, event);
      if (this.pressed) {
        this.ensureRipple(event);
      }
    },

    /**
     * Ensures this element contains a ripple effect. For startup efficiency
     * the ripple effect is dynamically on demand when needed.
     * @param {!Event=} optTriggeringEvent (optional) event that triggered the
     * ripple.
     */
    ensureRipple: function(optTriggeringEvent) {
      if (!this.hasRipple()) {
        this._ripple = this._createRipple();
        this._ripple.noink = this.noink;
        var rippleContainer = this._rippleContainer || this.root;
        if (rippleContainer) {
          Polymer.dom(rippleContainer).appendChild(this._ripple);
        }
        if (optTriggeringEvent) {
          // Check if the event happened inside of the ripple container
          // Fall back to host instead of the root because distributed text
          // nodes are not valid event targets
          var domContainer = Polymer.dom(this._rippleContainer || this);
          var target = Polymer.dom(optTriggeringEvent).rootTarget;
          if (domContainer.deepContains( /** @type {Node} */(target))) {
            this._ripple.uiDownAction(optTriggeringEvent);
          }
        }
      }
    },

    /**
     * Returns the `<paper-ripple>` element used by this element to create
     * ripple effects. The element's ripple is created on demand, when
     * necessary, and calling this method will force the
     * ripple to be created.
     */
    getRipple: function() {
      this.ensureRipple();
      return this._ripple;
    },

    /**
     * Returns true if this element currently contains a ripple effect.
     * @return {boolean}
     */
    hasRipple: function() {
      return Boolean(this._ripple);
    },

    /**
     * Create the element's ripple effect via creating a `<paper-ripple>`.
     * Override this method to customize the ripple element.
     * @return {!PaperRippleElement} Returns a `<paper-ripple>` element.
     */
    _createRipple: function() {
      return /** @type {!PaperRippleElement} */ (
          document.createElement('paper-ripple'));
    },

    _noinkChanged: function(noink) {
      if (this.hasRipple()) {
        this._ripple.noink = noink;
      }
    }

  };

</script>
<script>

  /**
   * `Polymer.PaperInkyFocusBehavior` implements a ripple when the element has keyboard focus.
   *
   * @polymerBehavior Polymer.PaperInkyFocusBehavior
   */
  Polymer.PaperInkyFocusBehaviorImpl = {

    observers: [
      '_focusedChanged(receivedFocusFromKeyboard)'
    ],

    _focusedChanged: function(receivedFocusFromKeyboard) {
      if (receivedFocusFromKeyboard) {
        this.ensureRipple();
      }
      if (this.hasRipple()) {
        this._ripple.holdDown = receivedFocusFromKeyboard;
      }
    },

    _createRipple: function() {
      var ripple = Polymer.PaperRippleBehavior._createRipple();
      ripple.id = 'ink';
      ripple.setAttribute('center', '');
      ripple.classList.add('circle');
      return ripple;
    }

  };

  /** @polymerBehavior Polymer.PaperInkyFocusBehavior */
  Polymer.PaperInkyFocusBehavior = [
    Polymer.IronButtonState,
    Polymer.IronControlState,
    Polymer.PaperRippleBehavior,
    Polymer.PaperInkyFocusBehaviorImpl
  ];

</script>
<style is="custom-style">

  :root {

    /* Material Design color palette for Google products */

    --google-red-100: #f4c7c3;
    --google-red-300: #e67c73;
    --google-red-500: #db4437;
    --google-red-700: #c53929;

    --google-blue-100: #c6dafc;
    --google-blue-300: #7baaf7;
    --google-blue-500: #4285f4;
    --google-blue-700: #3367d6;

    --google-green-100: #b7e1cd;
    --google-green-300: #57bb8a;
    --google-green-500: #0f9d58;
    --google-green-700: #0b8043;

    --google-yellow-100: #fce8b2;
    --google-yellow-300: #f7cb4d;
    --google-yellow-500: #f4b400;
    --google-yellow-700: #f09300;

    --google-grey-100: #f5f5f5;
    --google-grey-300: #e0e0e0;
    --google-grey-500: #9e9e9e;
    --google-grey-700: #616161;
    
    /* Material Design color palette from online spec document */

    --paper-red-50: #ffebee;
    --paper-red-100: #ffcdd2;
    --paper-red-200: #ef9a9a;
    --paper-red-300: #e57373;
    --paper-red-400: #ef5350;
    --paper-red-500: #f44336;
    --paper-red-600: #e53935;
    --paper-red-700: #d32f2f;
    --paper-red-800: #c62828;
    --paper-red-900: #b71c1c;
    --paper-red-a100: #ff8a80;
    --paper-red-a200: #ff5252;
    --paper-red-a400: #ff1744;
    --paper-red-a700: #d50000;
 
    --paper-pink-50: #fce4ec;
    --paper-pink-100: #f8bbd0;
    --paper-pink-200: #f48fb1;
    --paper-pink-300: #f06292;
    --paper-pink-400: #ec407a;
    --paper-pink-500: #e91e63;
    --paper-pink-600: #d81b60;
    --paper-pink-700: #c2185b;
    --paper-pink-800: #ad1457;
    --paper-pink-900: #880e4f;
    --paper-pink-a100: #ff80ab;
    --paper-pink-a200: #ff4081;
    --paper-pink-a400: #f50057;
    --paper-pink-a700: #c51162;
 
    --paper-purple-50: #f3e5f5;
    --paper-purple-100: #e1bee7;
    --paper-purple-200: #ce93d8;
    --paper-purple-300: #ba68c8;
    --paper-purple-400: #ab47bc;
    --paper-purple-500: #9c27b0;
    --paper-purple-600: #8e24aa;
    --paper-purple-700: #7b1fa2;
    --paper-purple-800: #6a1b9a;
    --paper-purple-900: #4a148c;
    --paper-purple-a100: #ea80fc;
    --paper-purple-a200: #e040fb;
    --paper-purple-a400: #d500f9;
    --paper-purple-a700: #aa00ff;
 
    --paper-deep-purple-50: #ede7f6;
    --paper-deep-purple-100: #d1c4e9;
    --paper-deep-purple-200: #b39ddb;
    --paper-deep-purple-300: #9575cd;
    --paper-deep-purple-400: #7e57c2;
    --paper-deep-purple-500: #673ab7;
    --paper-deep-purple-600: #5e35b1;
    --paper-deep-purple-700: #512da8;
    --paper-deep-purple-800: #4527a0;
    --paper-deep-purple-900: #311b92;
    --paper-deep-purple-a100: #b388ff;
    --paper-deep-purple-a200: #7c4dff;
    --paper-deep-purple-a400: #651fff;
    --paper-deep-purple-a700: #6200ea;
 
    --paper-indigo-50: #e8eaf6;
    --paper-indigo-100: #c5cae9;
    --paper-indigo-200: #9fa8da;
    --paper-indigo-300: #7986cb;
    --paper-indigo-400: #5c6bc0;
    --paper-indigo-500: #3f51b5;
    --paper-indigo-600: #3949ab;
    --paper-indigo-700: #303f9f;
    --paper-indigo-800: #283593;
    --paper-indigo-900: #1a237e;
    --paper-indigo-a100: #8c9eff;
    --paper-indigo-a200: #536dfe;
    --paper-indigo-a400: #3d5afe;
    --paper-indigo-a700: #304ffe;
 
    --paper-blue-50: #e3f2fd;
    --paper-blue-100: #bbdefb;
    --paper-blue-200: #90caf9;
    --paper-blue-300: #64b5f6;
    --paper-blue-400: #42a5f5;
    --paper-blue-500: #2196f3;
    --paper-blue-600: #1e88e5;
    --paper-blue-700: #1976d2;
    --paper-blue-800: #1565c0;
    --paper-blue-900: #0d47a1;
    --paper-blue-a100: #82b1ff;
    --paper-blue-a200: #448aff;
    --paper-blue-a400: #2979ff;
    --paper-blue-a700: #2962ff;
 
    --paper-light-blue-50: #e1f5fe;
    --paper-light-blue-100: #b3e5fc;
    --paper-light-blue-200: #81d4fa;
    --paper-light-blue-300: #4fc3f7;
    --paper-light-blue-400: #29b6f6;
    --paper-light-blue-500: #03a9f4;
    --paper-light-blue-600: #039be5;
    --paper-light-blue-700: #0288d1;
    --paper-light-blue-800: #0277bd;
    --paper-light-blue-900: #01579b;
    --paper-light-blue-a100: #80d8ff;
    --paper-light-blue-a200: #40c4ff;
    --paper-light-blue-a400: #00b0ff;
    --paper-light-blue-a700: #0091ea;
 
    --paper-cyan-50: #e0f7fa;
    --paper-cyan-100: #b2ebf2;
    --paper-cyan-200: #80deea;
    --paper-cyan-300: #4dd0e1;
    --paper-cyan-400: #26c6da;
    --paper-cyan-500: #00bcd4;
    --paper-cyan-600: #00acc1;
    --paper-cyan-700: #0097a7;
    --paper-cyan-800: #00838f;
    --paper-cyan-900: #006064;
    --paper-cyan-a100: #84ffff;
    --paper-cyan-a200: #18ffff;
    --paper-cyan-a400: #00e5ff;
    --paper-cyan-a700: #00b8d4;
 
    --paper-teal-50: #e0f2f1;
    --paper-teal-100: #b2dfdb;
    --paper-teal-200: #80cbc4;
    --paper-teal-300: #4db6ac;
    --paper-teal-400: #26a69a;
    --paper-teal-500: #009688;
    --paper-teal-600: #00897b;
    --paper-teal-700: #00796b;
    --paper-teal-800: #00695c;
    --paper-teal-900: #004d40;
    --paper-teal-a100: #a7ffeb;
    --paper-teal-a200: #64ffda;
    --paper-teal-a400: #1de9b6;
    --paper-teal-a700: #00bfa5;
 
    --paper-green-50: #e8f5e9;
    --paper-green-100: #c8e6c9;
    --paper-green-200: #a5d6a7;
    --paper-green-300: #81c784;
    --paper-green-400: #66bb6a;
    --paper-green-500: #4caf50;
    --paper-green-600: #43a047;
    --paper-green-700: #388e3c;
    --paper-green-800: #2e7d32;
    --paper-green-900: #1b5e20;
    --paper-green-a100: #b9f6ca;
    --paper-green-a200: #69f0ae;
    --paper-green-a400: #00e676;
    --paper-green-a700: #00c853;
 
    --paper-light-green-50: #f1f8e9;
    --paper-light-green-100: #dcedc8;
    --paper-light-green-200: #c5e1a5;
    --paper-light-green-300: #aed581;
    --paper-light-green-400: #9ccc65;
    --paper-light-green-500: #8bc34a;
    --paper-light-green-600: #7cb342;
    --paper-light-green-700: #689f38;
    --paper-light-green-800: #558b2f;
    --paper-light-green-900: #33691e;
    --paper-light-green-a100: #ccff90;
    --paper-light-green-a200: #b2ff59;
    --paper-light-green-a400: #76ff03;
    --paper-light-green-a700: #64dd17;
 
    --paper-lime-50: #f9fbe7;
    --paper-lime-100: #f0f4c3;
    --paper-lime-200: #e6ee9c;
    --paper-lime-300: #dce775;
    --paper-lime-400: #d4e157;
    --paper-lime-500: #cddc39;
    --paper-lime-600: #c0ca33;
    --paper-lime-700: #afb42b;
    --paper-lime-800: #9e9d24;
    --paper-lime-900: #827717;
    --paper-lime-a100: #f4ff81;
    --paper-lime-a200: #eeff41;
    --paper-lime-a400: #c6ff00;
    --paper-lime-a700: #aeea00;
 
    --paper-yellow-50: #fffde7;
    --paper-yellow-100: #fff9c4;
    --paper-yellow-200: #fff59d;
    --paper-yellow-300: #fff176;
    --paper-yellow-400: #ffee58;
    --paper-yellow-500: #ffeb3b;
    --paper-yellow-600: #fdd835;
    --paper-yellow-700: #fbc02d;
    --paper-yellow-800: #f9a825;
    --paper-yellow-900: #f57f17;
    --paper-yellow-a100: #ffff8d;
    --paper-yellow-a200: #ffff00;
    --paper-yellow-a400: #ffea00;
    --paper-yellow-a700: #ffd600;
 
    --paper-amber-50: #fff8e1;
    --paper-amber-100: #ffecb3;
    --paper-amber-200: #ffe082;
    --paper-amber-300: #ffd54f;
    --paper-amber-400: #ffca28;
    --paper-amber-500: #ffc107;
    --paper-amber-600: #ffb300;
    --paper-amber-700: #ffa000;
    --paper-amber-800: #ff8f00;
    --paper-amber-900: #ff6f00;
    --paper-amber-a100: #ffe57f;
    --paper-amber-a200: #ffd740;
    --paper-amber-a400: #ffc400;
    --paper-amber-a700: #ffab00;
 
    --paper-orange-50: #fff3e0;
    --paper-orange-100: #ffe0b2;
    --paper-orange-200: #ffcc80;
    --paper-orange-300: #ffb74d;
    --paper-orange-400: #ffa726;
    --paper-orange-500: #ff9800;
    --paper-orange-600: #fb8c00;
    --paper-orange-700: #f57c00;
    --paper-orange-800: #ef6c00;
    --paper-orange-900: #e65100;
    --paper-orange-a100: #ffd180;
    --paper-orange-a200: #ffab40;
    --paper-orange-a400: #ff9100;
    --paper-orange-a700: #ff6500;
 
    --paper-deep-orange-50: #fbe9e7;
    --paper-deep-orange-100: #ffccbc;
    --paper-deep-orange-200: #ffab91;
    --paper-deep-orange-300: #ff8a65;
    --paper-deep-orange-400: #ff7043;
    --paper-deep-orange-500: #ff5722;
    --paper-deep-orange-600: #f4511e;
    --paper-deep-orange-700: #e64a19;
    --paper-deep-orange-800: #d84315;
    --paper-deep-orange-900: #bf360c;
    --paper-deep-orange-a100: #ff9e80;
    --paper-deep-orange-a200: #ff6e40;
    --paper-deep-orange-a400: #ff3d00;
    --paper-deep-orange-a700: #dd2c00;
 
    --paper-brown-50: #efebe9;
    --paper-brown-100: #d7ccc8;
    --paper-brown-200: #bcaaa4;
    --paper-brown-300: #a1887f;
    --paper-brown-400: #8d6e63;
    --paper-brown-500: #795548;
    --paper-brown-600: #6d4c41;
    --paper-brown-700: #5d4037;
    --paper-brown-800: #4e342e;
    --paper-brown-900: #3e2723;
 
    --paper-grey-50: #fafafa;
    --paper-grey-100: #f5f5f5;
    --paper-grey-200: #eeeeee;
    --paper-grey-300: #e0e0e0;
    --paper-grey-400: #bdbdbd;
    --paper-grey-500: #9e9e9e;
    --paper-grey-600: #757575;
    --paper-grey-700: #616161;
    --paper-grey-800: #424242;
    --paper-grey-900: #212121;
 
    --paper-blue-grey-50: #eceff1;
    --paper-blue-grey-100: #cfd8dc;
    --paper-blue-grey-200: #b0bec5;
    --paper-blue-grey-300: #90a4ae;
    --paper-blue-grey-400: #78909c;
    --paper-blue-grey-500: #607d8b;
    --paper-blue-grey-600: #546e7a;
    --paper-blue-grey-700: #455a64;
    --paper-blue-grey-800: #37474f;
    --paper-blue-grey-900: #263238;

    /* opacity for dark text on a light background */
    --dark-divider-opacity: 0.12;
    --dark-disabled-opacity: 0.38; /* or hint text or icon */
    --dark-secondary-opacity: 0.54;
    --dark-primary-opacity: 0.87;

    /* opacity for light text on a dark background */
    --light-divider-opacity: 0.12;
    --light-disabled-opacity: 0.3; /* or hint text or icon */
    --light-secondary-opacity: 0.7;
    --light-primary-opacity: 1.0;

  }

</style>


<style is="custom-style">

  :root {
    /*
     * You can use these generic variables in your elements for easy theming.
     * For example, if all your elements use `--primary-text-color` as its main
     * color, then switching from a light to a dark theme is just a matter of
     * changing the value of `--primary-text-color` in your application.
     */
    --primary-text-color: var(--light-theme-text-color);
    --primary-background-color: var(--light-theme-background-color);
    --secondary-text-color: var(--light-theme-secondary-color);
    --disabled-text-color: var(--light-theme-disabled-color);
    --divider-color: var(--light-theme-divider-color);
    --error-color: var(--paper-deep-orange-a700);

    /*
     * Primary and accent colors. Also see color.html for more colors.
     */
    --primary-color: var(--paper-indigo-500);
    --light-primary-color: var(--paper-indigo-100);
    --dark-primary-color: var(--paper-indigo-700);

    --accent-color: var(--paper-pink-a200);
    --light-accent-color: var(--paper-pink-a100);
    --dark-accent-color: var(--paper-pink-a400);


    /*
     * Material Design Light background theme
     */
    --light-theme-background-color: #ffffff;
    --light-theme-base-color: #000000;
    --light-theme-text-color: var(--paper-grey-900);
    --light-theme-secondary-color: #737373;  /* for secondary text and icons */
    --light-theme-disabled-color: #9b9b9b;  /* disabled/hint text */
    --light-theme-divider-color: #dbdbdb;

    /*
     * Material Design Dark background theme
     */
    --dark-theme-background-color: var(--paper-grey-900);
    --dark-theme-base-color: #ffffff;
    --dark-theme-text-color: #ffffff;
    --dark-theme-secondary-color: #bcbcbc;  /* for secondary text and icons */
    --dark-theme-disabled-color: #646464;  /* disabled/hint text */
    --dark-theme-divider-color: #3c3c3c;

    /*
     * Deprecated values because of their confusing names.
     */
    --text-primary-color: var(--dark-theme-text-color);
    --default-primary-color: var(--primary-color);

  }

</style>


<dom-module id="paper-icon-button" assetpath="bower_components/paper-icon-button/">
  <template strip-whitespace="">
    <style>
      :host {
        display: inline-block;
        position: relative;
        padding: 8px;
        outline: none;
        -webkit-tap-highlight-color: rgba(0,0,0,0);
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        cursor: pointer;
        z-index: 0;
        line-height: 1;

        width: 40px;
        height: 40px;

        /* Because of polymer/2558, this style has lower specificity than * */
        box-sizing: border-box !important;

        @apply(--paper-icon-button);
      }

      :host #ink {
        color: var(--paper-icon-button-ink-color, --primary-text-color);
        opacity: 0.6;
      }

      :host([disabled]) {
        color: var(--paper-icon-button-disabled-text, --disabled-text-color);
        pointer-events: none;
        cursor: auto;

        @apply(--paper-icon-button-disabled);
      }

      :host(:hover) {
        @apply(--paper-icon-button-hover);
      }

      iron-icon {
        --iron-icon-width: 100%;
        --iron-icon-height: 100%;
      }
    </style>

    <iron-icon id="icon" src="[[src]]" icon="[[icon]]" alt$="[[alt]]"></iron-icon>
  </template>

  <script>
    Polymer({
      is: 'paper-icon-button',

      hostAttributes: {
        role: 'button',
        tabindex: '0'
      },

      behaviors: [
        Polymer.PaperInkyFocusBehavior
      ],

      properties: {
        /**
         * The URL of an image for the icon. If the src property is specified,
         * the icon property should not be.
         */
        src: {
          type: String
        },

        /**
         * Specifies the icon name or index in the set of icons available in
         * the icon's icon set. If the icon property is specified,
         * the src property should not be.
         */
        icon: {
          type: String
        },

        /**
         * Specifies the alternate text for the button, for accessibility.
         */
        alt: {
          type: String,
          observer: "_altChanged"
        }
      },

      _altChanged: function(newValue, oldValue) {
        var label = this.getAttribute('aria-label');

        // Don't stomp over a user-set aria-label.
        if (!label || oldValue == label) {
          this.setAttribute('aria-label', newValue);
        }
      }
    });
  </script>
</dom-module>
<script>
  /**
  Polymer.IronFormElementBehavior enables a custom element to be included
  in an `iron-form`.

  @demo demo/index.html
  @polymerBehavior
  */
  Polymer.IronFormElementBehavior = {

    properties: {
      /**
       * Fired when the element is added to an `iron-form`.
       *
       * @event iron-form-element-register
       */

      /**
       * Fired when the element is removed from an `iron-form`.
       *
       * @event iron-form-element-unregister
       */

      /**
       * The name of this element.
       */
      name: {
        type: String
      },

      /**
       * The value for this element.
       */
      value: {
        notify: true,
        type: String
      },

      /**
       * Set to true to mark the input as required. If used in a form, a
       * custom element that uses this behavior should also use
       * Polymer.IronValidatableBehavior and define a custom validation method.
       * Otherwise, a `required` element will always be considered valid.
       * It's also strongly recommended to provide a visual style for the element
       * when its value is invalid.
       */
      required: {
        type: Boolean,
        value: false
      },

      /**
       * The form that the element is registered to.
       */
      _parentForm: {
        type: Object
      }
    },

    attached: function() {
      // Note: the iron-form that this element belongs to will set this
      // element's _parentForm property when handling this event.
      this.fire('iron-form-element-register');
    },

    detached: function() {
      if (this._parentForm) {
        this._parentForm.fire('iron-form-element-unregister', {target: this});
      }
    }

  };

</script>
<script>

 /**
 * `iron-range-behavior` provides the behavior for something with a minimum to maximum range.
 *
 * @demo demo/index.html
 * @polymerBehavior
 */
 Polymer.IronRangeBehavior = {

  properties: {

    /**
     * The number that represents the current value.
     */
    value: {
      type: Number,
      value: 0,
      notify: true,
      reflectToAttribute: true
    },

    /**
     * The number that indicates the minimum value of the range.
     */
    min: {
      type: Number,
      value: 0,
      notify: true
    },

    /**
     * The number that indicates the maximum value of the range.
     */
    max: {
      type: Number,
      value: 100,
      notify: true
    },

    /**
     * Specifies the value granularity of the range's value.
     */
    step: {
      type: Number,
      value: 1,
      notify: true
    },

    /**
     * Returns the ratio of the value.
     */
    ratio: {
      type: Number,
      value: 0,
      readOnly: true,
      notify: true
    },
  },

  observers: [
    '_update(value, min, max, step)'
  ],

  _calcRatio: function(value) {
    return (this._clampValue(value) - this.min) / (this.max - this.min);
  },

  _clampValue: function(value) {
    return Math.min(this.max, Math.max(this.min, this._calcStep(value)));
  },

  _calcStep: function(value) {
   /**
    * if we calculate the step using
    * `Math.round(value / step) * step` we may hit a precision point issue
    * eg. 0.1 * 0.2 =  0.020000000000000004
    * http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
    *
    * as a work around we can divide by the reciprocal of `step`
    */
    // polymer/issues/2493
    value = parseFloat(value);
    return this.step ? (Math.round((value + this.min) / this.step) -
        (this.min / this.step)) / (1 / this.step) : value;
  },

  _validateValue: function() {
    var v = this._clampValue(this.value);
    this.value = this.oldValue = isNaN(v) ? this.oldValue : v;
    return this.value !== v;
  },

  _update: function() {
    this._validateValue();
    this._setRatio(this._calcRatio(this.value) * 100);
  }

};
</script>
<script>

  /**
   * `Use Polymer.IronValidatableBehavior` to implement an element that validates user input.
   * Use the related `Polymer.IronValidatorBehavior` to add custom validation logic to an iron-input.
   *
   * By default, an `<iron-form>` element validates its fields when the user presses the submit button.
   * To validate a form imperatively, call the form's `validate()` method, which in turn will
   * call `validate()` on all its children. By using `Polymer.IronValidatableBehavior`, your
   * custom element will get a public `validate()`, which
   * will return the validity of the element, and a corresponding `invalid` attribute,
   * which can be used for styling.
   *
   * To implement the custom validation logic of your element, you must override
   * the protected `_getValidity()` method of this behaviour, rather than `validate()`.
   * See [this](https://github.com/PolymerElements/iron-form/blob/master/demo/simple-element.html)
   * for an example.
   *
   * ### Accessibility
   *
   * Changing the `invalid` property, either manually or by calling `validate()` will update the
   * `aria-invalid` attribute.
   *
   * @demo demo/index.html
   * @polymerBehavior
   */
  Polymer.IronValidatableBehavior = {

    properties: {

      /**
       * Namespace for this validator.
       */
      validatorType: {
        type: String,
        value: 'validator'
      },

      /**
       * Name of the validator to use.
       */
      validator: {
        type: String
      },

      /**
       * True if the last call to `validate` is invalid.
       */
      invalid: {
        notify: true,
        reflectToAttribute: true,
        type: Boolean,
        value: false
      },

      _validatorMeta: {
        type: Object
      }

    },

    observers: [
      '_invalidChanged(invalid)'
    ],

    get _validator() {
      return this._validatorMeta && this._validatorMeta.byKey(this.validator);
    },

    ready: function() {
      this._validatorMeta = new Polymer.IronMeta({type: this.validatorType});
    },

    _invalidChanged: function() {
      if (this.invalid) {
        this.setAttribute('aria-invalid', 'true');
      } else {
        this.removeAttribute('aria-invalid');
      }
    },

    /**
     * @return {boolean} True if the validator `validator` exists.
     */
    hasValidator: function() {
      return this._validator != null;
    },

    /**
     * Returns true if the `value` is valid, and updates `invalid`. If you want
     * your element to have custom validation logic, do not override this method;
     * override `_getValidity(value)` instead.

     * @param {Object} value The value to be validated. By default, it is passed
     * to the validator's `validate()` function, if a validator is set.
     * @return {boolean} True if `value` is valid.
     */
    validate: function(value) {
      this.invalid = !this._getValidity(value);
      return !this.invalid;
    },

    /**
     * Returns true if `value` is valid.  By default, it is passed
     * to the validator's `validate()` function, if a validator is set. You
     * should override this method if you want to implement custom validity
     * logic for your element.
     *
     * @param {Object} value The value to be validated.
     * @return {boolean} True if `value` is valid.
     */

    _getValidity: function(value) {
      if (this.hasValidator()) {
        return this._validator.validate(value);
      }
      return true;
    }
  };

</script>
<script>

/*
`<iron-input>` adds two-way binding and custom validators using `Polymer.IronValidatorBehavior`
to `<input>`.

### Two-way binding

By default you can only get notified of changes to an `input`'s `value` due to user input:

    <input value="{{myValue::input}}">

`iron-input` adds the `bind-value` property that mirrors the `value` property, and can be used
for two-way data binding. `bind-value` will notify if it is changed either by user input or by script.

    <input is="iron-input" bind-value="{{myValue}}">

### Custom validators

You can use custom validators that implement `Polymer.IronValidatorBehavior` with `<iron-input>`.

    <input is="iron-input" validator="my-custom-validator">

### Stopping invalid input

It may be desirable to only allow users to enter certain characters. You can use the
`prevent-invalid-input` and `allowed-pattern` attributes together to accomplish this. This feature
is separate from validation, and `allowed-pattern` does not affect how the input is validated.

    <!-- only allow characters that match [0-9] -->
    <input is="iron-input" prevent-invalid-input allowed-pattern="[0-9]">

@hero hero.svg
@demo demo/index.html
*/

  Polymer({

    is: 'iron-input',

    extends: 'input',

    behaviors: [
      Polymer.IronValidatableBehavior
    ],

    properties: {

      /**
       * Use this property instead of `value` for two-way data binding.
       */
      bindValue: {
        observer: '_bindValueChanged',
        type: String
      },

      /**
       * Set to true to prevent the user from entering invalid input. The new input characters are
       * matched with `allowedPattern` if it is set, otherwise it will use the `type` attribute (only
       * supported for `type=number`).
       */
      preventInvalidInput: {
        type: Boolean
      },

      /**
       * Regular expression expressing a set of characters to enforce the validity of input characters.
       * The recommended value should follow this format: `[a-ZA-Z0-9.+-!;:]` that list the characters 
       * allowed as input.
       */
      allowedPattern: {
        type: String,
        observer: "_allowedPatternChanged"
      },

      _previousValidInput: {
        type: String,
        value: ''
      },

      _patternAlreadyChecked: {
        type: Boolean,
        value: false
      }

    },

    listeners: {
      'input': '_onInput',
      'keypress': '_onKeypress'
    },

    get _patternRegExp() {
      var pattern;
      if (this.allowedPattern) {
        pattern = new RegExp(this.allowedPattern);
      } else {
        switch (this.type) {
          case 'number':
            pattern = /[0-9.,e-]/;
            break;
        }
      }
      return pattern;
    },

    ready: function() {
      this.bindValue = this.value;
    },

    /**
     * @suppress {checkTypes}
     */
    _bindValueChanged: function() {
      if (this.value !== this.bindValue) {
        this.value = !(this.bindValue || this.bindValue === 0 || this.bindValue === false) ? '' : this.bindValue;
      }
      // manually notify because we don't want to notify until after setting value
      this.fire('bind-value-changed', {value: this.bindValue});
    },

    _allowedPatternChanged: function() {
      // Force to prevent invalid input when an `allowed-pattern` is set
      this.preventInvalidInput = this.allowedPattern ? true : false;
    },

    _onInput: function() {
      // Need to validate each of the characters pasted if they haven't
      // been validated inside `_onKeypress` already.
      if (this.preventInvalidInput && !this._patternAlreadyChecked) {
        var valid = this._checkPatternValidity();
        if (!valid) {
          this.value = this._previousValidInput;
        }
      }

      this.bindValue = this.value;
      this._previousValidInput = this.value;
      this._patternAlreadyChecked = false;
    },

    _isPrintable: function(event) {
      // What a control/printable character is varies wildly based on the browser.
      // - most control characters (arrows, backspace) do not send a `keypress` event
      //   in Chrome, but the *do* on Firefox
      // - in Firefox, when they do send a `keypress` event, control chars have
      //   a charCode = 0, keyCode = xx (for ex. 40 for down arrow)
      // - printable characters always send a keypress event.
      // - in Firefox, printable chars always have a keyCode = 0. In Chrome, the keyCode
      //   always matches the charCode.
      // None of this makes any sense.

      // For these keys, ASCII code == browser keycode.
      var anyNonPrintable =
        (event.keyCode == 8)   ||  // backspace
        (event.keyCode == 9)   ||  // tab
        (event.keyCode == 13)  ||  // enter
        (event.keyCode == 27);     // escape

      // For these keys, make sure it's a browser keycode and not an ASCII code.
      var mozNonPrintable =
        (event.keyCode == 19)  ||  // pause
        (event.keyCode == 20)  ||  // caps lock
        (event.keyCode == 45)  ||  // insert
        (event.keyCode == 46)  ||  // delete
        (event.keyCode == 144) ||  // num lock
        (event.keyCode == 145) ||  // scroll lock
        (event.keyCode > 32 && event.keyCode < 41)   || // page up/down, end, home, arrows
        (event.keyCode > 111 && event.keyCode < 124); // fn keys

      return !anyNonPrintable && !(event.charCode == 0 && mozNonPrintable);
    },

    _onKeypress: function(event) {
      if (!this.preventInvalidInput && this.type !== 'number') {
        return;
      }
      var regexp = this._patternRegExp;
      if (!regexp) {
        return;
      }

      // Handle special keys and backspace
      if (event.metaKey || event.ctrlKey || event.altKey)
        return;

      // Check the pattern either here or in `_onInput`, but not in both.
      this._patternAlreadyChecked = true;

      var thisChar = String.fromCharCode(event.charCode);
      if (this._isPrintable(event) && !regexp.test(thisChar)) {
        event.preventDefault();
      }
    },

    _checkPatternValidity: function() {
      var regexp = this._patternRegExp;
      if (!regexp) {
        return true;
      }
      for (var i = 0; i < this.value.length; i++) {
        if (!regexp.test(this.value[i])) {
          return false;
        }
      }
      return true;
    },

    /**
     * Returns true if `value` is valid. The validator provided in `validator` will be used first,
     * then any constraints.
     * @return {boolean} True if the value is valid.
     */
    validate: function() {
      // Empty, non-required input is valid.
      if (!this.required && this.value == '') {
        this.invalid = false;
        return true;
      }

      var valid;
      if (this.hasValidator()) {
        valid = Polymer.IronValidatableBehavior.validate.call(this, this.value);
      } else {
        valid = this.checkValidity();
        this.invalid = !valid;
      }
      this.fire('iron-input-validate');
      return valid;
    }

  });

  /*
  The `iron-input-validate` event is fired whenever `validate()` is called.
  @event iron-input-validate
  */

</script>
<script>
  /**
   * Use `Polymer.PaperInputBehavior` to implement inputs with `<paper-input-container>`. This
   * behavior is implemented by `<paper-input>`. It exposes a number of properties from
   * `<paper-input-container>` and `<input is="iron-input">` and they should be bound in your
   * template.
   *
   * The input element can be accessed by the `inputElement` property if you need to access
   * properties or methods that are not exposed.
   * @polymerBehavior Polymer.PaperInputBehavior
   */
  Polymer.PaperInputBehaviorImpl = {
    properties: {
      /**
       * Fired when the input changes due to user interaction.
       *
       * @event change
       */

      /**
       * The label for this input. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to
       * `<label>`'s content and `hidden` property, e.g.
       * `<label hidden$="[[!label]]">[[label]]</label>` in your `template`
       */
      label: {
        type: String
      },

      /**
       * The value for this input. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to
       * the `<input is="iron-input">`'s `bindValue`
       * property, or the value property of your input that is `notify:true`.
       */
      value: {
        notify: true,
        type: String
      },

      /**
       * Set to true to disable this input. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to
       * both the `<paper-input-container>`'s and the input's `disabled` property.
       */
      disabled: {
        type: Boolean,
        value: false
      },

      /**
       * Returns true if the value is invalid. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to both the
       * `<paper-input-container>`'s and the input's `invalid` property.
       *
       * If `autoValidate` is true, the `invalid` attribute is managed automatically,
       * which can clobber attempts to manage it manually.
       */
      invalid: {
        type: Boolean,
        value: false,
        notify: true
      },

      /**
       * Set to true to prevent the user from entering invalid input. If you're
       * using PaperInputBehavior to  implement your own paper-input-like element,
       * bind this to `<input is="iron-input">`'s `preventInvalidInput` property.
       */
      preventInvalidInput: {
        type: Boolean
      },

      /**
       * Set this to specify the pattern allowed by `preventInvalidInput`. If
       * you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `allowedPattern`
       * property.
       */
      allowedPattern: {
        type: String
      },

      /**
       * The type of the input. The supported types are `text`, `number` and `password`.
       * If you're using PaperInputBehavior to implement your own paper-input-like element,
       * bind this to the `<input is="iron-input">`'s `type` property.
       */
      type: {
        type: String
      },

      /**
       * The datalist of the input (if any). This should match the id of an existing `<datalist>`.
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `list` property.
       */
      list: {
        type: String
      },

      /**
       * A pattern to validate the `input` with. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to
       * the `<input is="iron-input">`'s `pattern` property.
       */
      pattern: {
        type: String
      },

      /**
       * Set to true to mark the input as required. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to
       * the `<input is="iron-input">`'s `required` property.
       */
      required: {
        type: Boolean,
        value: false
      },

      /**
       * The error message to display when the input is invalid. If you're using
       * PaperInputBehavior to implement your own paper-input-like element,
       * bind this to the `<paper-input-error>`'s content, if using.
       */
      errorMessage: {
        type: String
      },

      /**
       * Set to true to show a character counter.
       */
      charCounter: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to disable the floating label. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to
       * the `<paper-input-container>`'s `noLabelFloat` property.
       */
      noLabelFloat: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to always float the label. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to
       * the `<paper-input-container>`'s `alwaysFloatLabel` property.
       */
      alwaysFloatLabel: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to auto-validate the input value. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to
       * the `<paper-input-container>`'s `autoValidate` property.
       */
      autoValidate: {
        type: Boolean,
        value: false
      },

      /**
       * Name of the validator to use. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to
       * the `<input is="iron-input">`'s `validator` property.
       */
      validator: {
        type: String
      },

      // HTMLInputElement attributes for binding if needed

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `autocomplete` property.
       */
      autocomplete: {
        type: String,
        value: 'off'
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `autofocus` property.
       */
      autofocus: {
        type: Boolean
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `inputmode` property.
       */
      inputmode: {
        type: String
      },

      /**
       * The minimum length of the input value.
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `minlength` property.
       */
      minlength: {
        type: Number
      },

      /**
       * The maximum length of the input value.
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `maxlength` property.
       */
      maxlength: {
        type: Number
      },

      /**
       * The minimum (numeric or date-time) input value.
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `min` property.
       */
      min: {
        type: String
      },

      /**
       * The maximum (numeric or date-time) input value.
       * Can be a String (e.g. `"2000-1-1"`) or a Number (e.g. `2`).
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `max` property.
       */
      max: {
        type: String
      },

      /**
       * Limits the numeric or date-time increments.
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `step` property.
       */
      step: {
        type: String
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `name` property.
       */
      name: {
        type: String
      },

      /**
       * A placeholder string in addition to the label. If this is set, the label will always float.
       */
      placeholder: {
        type: String,
        // need to set a default so _computeAlwaysFloatLabel is run
        value: ''
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `readonly` property.
       */
      readonly: {
        type: Boolean,
        value: false
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `size` property.
       */
      size: {
        type: Number
      },

      // Nonstandard attributes for binding if needed

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `autocapitalize` property.
       */
      autocapitalize: {
        type: String,
        value: 'none'
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `autocorrect` property.
       */
      autocorrect: {
        type: String,
        value: 'off'
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `autosave` property,
       * used with type=search.
       */
      autosave: {
        type: String
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `results` property,
       * used with type=search.
       */
      results: {
        type: Number
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `accept` property,
       * used with type=file.
       */
      accept: {
        type: String
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the`<input is="iron-input">`'s `multiple` property,
       * used with type=file.
       */
      multiple: {
        type: Boolean
      },

      _ariaDescribedBy: {
        type: String,
        value: ''
      },

      _ariaLabelledBy: {
        type: String,
        value: ''
      }

    },

    listeners: {
      'addon-attached': '_onAddonAttached',
    },

    keyBindings: {
      'shift+tab:keydown': '_onShiftTabDown'
    },

    hostAttributes: {
      tabindex: 0
    },

    /**
     * Returns a reference to the input element.
     */
    get inputElement() {
      return this.$.input;
    },

    /**
     * Returns a reference to the focusable element.
     */
    get _focusableElement() {
      return this.inputElement;
    },

    registered: function() {
      // These types have some default placeholder text; overlapping
      // the label on top of it looks terrible. Auto-float the label in this case.
      this._typesThatHaveText = ["date", "datetime", "datetime-local", "month",
          "time", "week", "file"];
    },

    attached: function() {
      this._updateAriaLabelledBy();

      if (this.inputElement &&
          this._typesThatHaveText.indexOf(this.inputElement.type) !== -1) {
        this.alwaysFloatLabel = true;
      }
    },

    _appendStringWithSpace: function(str, more) {
      if (str) {
        str = str + ' ' + more;
      } else {
        str = more;
      }
      return str;
    },

    _onAddonAttached: function(event) {
      var target = event.path ? event.path[0] : event.target;
      if (target.id) {
        this._ariaDescribedBy = this._appendStringWithSpace(this._ariaDescribedBy, target.id);
      } else {
        var id = 'paper-input-add-on-' + Math.floor((Math.random() * 100000));
        target.id = id;
        this._ariaDescribedBy = this._appendStringWithSpace(this._ariaDescribedBy, id);
      }
    },

    /**
     * Validates the input element and sets an error style if needed.
     *
     * @return {boolean}
     */
    validate: function() {
      return this.inputElement.validate();
    },

    /**
     * Forward focus to inputElement. Overriden from IronControlState.
     */
    _focusBlurHandler: function(event) {
      if (this._shiftTabPressed)
        return;

      Polymer.IronControlState._focusBlurHandler.call(this, event);

      // Forward the focus to the nested input.
      if (this.focused)
        this._focusableElement.focus();
    },

    /**
     * Handler that is called when a shift+tab keypress is detected by the menu.
     *
     * @param {CustomEvent} event A key combination event.
     */
    _onShiftTabDown: function(event) {
      var oldTabIndex = this.getAttribute('tabindex');
      this._shiftTabPressed = true;
      this.setAttribute('tabindex', '-1');
      this.async(function() {
        this.setAttribute('tabindex', oldTabIndex);
        this._shiftTabPressed = false;
      }, 1);
    },

    /**
     * If `autoValidate` is true, then validates the element.
     */
    _handleAutoValidate: function() {
      if (this.autoValidate)
        this.validate();
    },

    /**
     * Restores the cursor to its original position after updating the value.
     * @param {string} newValue The value that should be saved.
     */
    updateValueAndPreserveCaret: function(newValue) {
      // Not all elements might have selection, and even if they have the
      // right properties, accessing them might throw an exception (like for
      // <input type=number>)
      try {
        var start = this.inputElement.selectionStart;
        this.value = newValue;

        // The cursor automatically jumps to the end after re-setting the value,
        // so restore it to its original position.
        this.inputElement.selectionStart = start;
        this.inputElement.selectionEnd = start;
      } catch (e) {
        // Just set the value and give up on the caret.
        this.value = newValue;
      }
    },

    _computeAlwaysFloatLabel: function(alwaysFloatLabel, placeholder) {
      return placeholder || alwaysFloatLabel;
    },

    _updateAriaLabelledBy: function() {
      var label = Polymer.dom(this.root).querySelector('label');
      if (!label) {
        this._ariaLabelledBy = '';
        return;
      }
      var labelledBy;
      if (label.id) {
        labelledBy = label.id;
      } else {
        labelledBy = 'paper-input-label-' + new Date().getUTCMilliseconds();
        label.id = labelledBy;
      }
      this._ariaLabelledBy = labelledBy;
    },

    _onChange:function(event) {
      // In the Shadow DOM, the `change` event is not leaked into the
      // ancestor tree, so we must do this manually.
      // See https://w3c.github.io/webcomponents/spec/shadow/#events-that-are-not-leaked-into-ancestor-trees.
      if (this.shadowRoot) {
        this.fire(event.type, {sourceEvent: event}, {
          node: this,
          bubbles: event.bubbles,
          cancelable: event.cancelable
        });
      }
    }
  };

  /** @polymerBehavior */
  Polymer.PaperInputBehavior = [
    Polymer.IronControlState,
    Polymer.IronA11yKeysBehavior,
    Polymer.PaperInputBehaviorImpl
  ];
</script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic,500,500italic,700,700italic">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,700">
<style is="custom-style">

  :root {

    /* Shared Styles */
    --paper-font-common-base: {
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
    };

    --paper-font-common-code: {
      font-family: 'Roboto Mono', 'Consolas', 'Menlo', monospace;
      -webkit-font-smoothing: antialiased;
    };

    --paper-font-common-expensive-kerning: {
      text-rendering: optimizeLegibility;
    };

    --paper-font-common-nowrap: {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    };

    /* Material Font Styles */

    --paper-font-display4: {
      @apply(--paper-font-common-base);
      @apply(--paper-font-common-nowrap);

      font-size: 112px;
      font-weight: 300;
      letter-spacing: -.044em;
      line-height: 120px;
    };

    --paper-font-display3: {
      @apply(--paper-font-common-base);
      @apply(--paper-font-common-nowrap);

      font-size: 56px;
      font-weight: 400;
      letter-spacing: -.026em;
      line-height: 60px;
    };

    --paper-font-display2: {
      @apply(--paper-font-common-base);

      font-size: 45px;
      font-weight: 400;
      letter-spacing: -.018em;
      line-height: 48px;
    };

    --paper-font-display1: {
      @apply(--paper-font-common-base);

      font-size: 34px;
      font-weight: 400;
      letter-spacing: -.01em;
      line-height: 40px;
    };

    --paper-font-headline: {
      @apply(--paper-font-common-base);

      font-size: 24px;
      font-weight: 400;
      letter-spacing: -.012em;
      line-height: 32px;
    };

    --paper-font-title: {
      @apply(--paper-font-common-base);
      @apply(--paper-font-common-nowrap);

      font-size: 20px;
      font-weight: 500;
      line-height: 28px;
    };

    --paper-font-subhead: {
      @apply(--paper-font-common-base);

      font-size: 16px;
      font-weight: 400;
      line-height: 24px;
    };

    --paper-font-body2: {
      @apply(--paper-font-common-base);

      font-size: 14px;
      font-weight: 500;
      line-height: 24px;
    };

    --paper-font-body1: {
      @apply(--paper-font-common-base);

      font-size: 14px;
      font-weight: 400;
      line-height: 20px;
    };

    --paper-font-caption: {
      @apply(--paper-font-common-base);
      @apply(--paper-font-common-nowrap);

      font-size: 12px;
      font-weight: 400;
      letter-spacing: 0.011em;
      line-height: 20px;
    };

    --paper-font-menu: {
      @apply(--paper-font-common-base);
      @apply(--paper-font-common-nowrap);

      font-size: 13px;
      font-weight: 500;
      line-height: 24px;
    };

    --paper-font-button: {
      @apply(--paper-font-common-base);
      @apply(--paper-font-common-nowrap);

      font-size: 14px;
      font-weight: 500;
      letter-spacing: 0.018em;
      line-height: 24px;
      text-transform: uppercase;
    };

    --paper-font-code2: {
      @apply(--paper-font-common-code);

      font-size: 14px;
      font-weight: 700;
      line-height: 20px;
    };

    --paper-font-code1: {
      @apply(--paper-font-common-code);

      font-size: 14px;
      font-weight: 500;
      line-height: 20px;
    };

  }

</style>
<script>

  /**
   * Use `Polymer.PaperInputAddonBehavior` to implement an add-on for `<paper-input-container>`. A
   * add-on appears below the input, and may display information based on the input value and
   * validity such as a character counter or an error message.
   * @polymerBehavior
   */
  Polymer.PaperInputAddonBehavior = {

    hostAttributes: {
      'add-on': ''
    },

    attached: function() {
      this.fire('addon-attached');
    },

    /**
     * The function called by `<paper-input-container>` when the input value or validity changes.
     * @param {{
     *   inputElement: (Element|undefined),
     *   value: (string|undefined),
     *   invalid: boolean
     * }} state -
     *     inputElement: The input element.
     *     value: The input value.
     *     invalid: True if the input value is invalid.
     */
    update: function(state) {
    }

  };

</script>


<dom-module id="paper-input-char-counter" assetpath="bower_components/paper-input/">
  <template>
    <style>
      :host {
        display: inline-block;
        float: right;

        @apply(--paper-font-caption);
        @apply(--paper-input-char-counter);
      }

      :host-context([dir="rtl"]) {
        float: left;
      }
    </style>

    <span>[[_charCounterStr]]</span>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'paper-input-char-counter',

    behaviors: [
      Polymer.PaperInputAddonBehavior
    ],

    properties: {
      _charCounterStr: {
        type: String,
        value: '0'
      }
    },

    /**
     * This overrides the update function in PaperInputAddonBehavior.
     * @param {{
     *   inputElement: (Element|undefined),
     *   value: (string|undefined),
     *   invalid: boolean
     * }} state -
     *     inputElement: The input element.
     *     value: The input value.
     *     invalid: True if the input value is invalid.
     */
    update: function(state) {
      if (!state.inputElement) {
        return;
      }

      state.value = state.value || '';

      var counter = state.value.length.toString();

      if (state.inputElement.hasAttribute('maxlength')) {
        counter += '/' + state.inputElement.getAttribute('maxlength');
      }

      this._charCounterStr = counter;
    }
  });
</script>


<dom-module id="paper-input-container" assetpath="bower_components/paper-input/">
  <template>
    <style>
      :host {
        display: block;
        padding: 8px 0;

        @apply(--paper-input-container);
      }

      :host[inline] {
        display: inline-block;
      }

      :host([disabled]) {
        pointer-events: none;
        opacity: 0.33;

        @apply(--paper-input-container-disabled);
      }

      .floated-label-placeholder {
        @apply(--paper-font-caption);
      }

      .underline {
        position: relative;
      }

      .focused-line {
        @apply(--layout-fit);

        background: var(--paper-input-container-focus-color, --primary-color);
        height: 2px;

        -webkit-transform-origin: center center;
        transform-origin: center center;
        -webkit-transform: scale3d(0,1,1);
        transform: scale3d(0,1,1);

        @apply(--paper-input-container-underline-focus);
      }

      .underline.is-highlighted .focused-line {
        -webkit-transform: none;
        transform: none;
        -webkit-transition: -webkit-transform 0.25s;
        transition: transform 0.25s;

        @apply(--paper-transition-easing);
      }

      .underline.is-invalid .focused-line {
        background: var(--paper-input-container-invalid-color, --error-color);
        -webkit-transform: none;
        transform: none;
        -webkit-transition: -webkit-transform 0.25s;
        transition: transform 0.25s;

        @apply(--paper-transition-easing);
      }

      .unfocused-line {
        @apply(--layout-fit);

        background: var(--paper-input-container-color, --secondary-text-color);
        height: 1px;

        @apply(--paper-input-container-underline);
      }

      :host([disabled]) .unfocused-line {
        border-bottom: 1px dashed;
        border-color: var(--paper-input-container-color, --secondary-text-color);
        background: transparent;

        @apply(--paper-input-container-underline-disabled);
      }

      .label-and-input-container {
        @apply(--layout-flex-auto);
        @apply(--layout-relative);

        width: 100%;
        max-width: 100%;
      }

      .input-content {
        @apply(--layout-horizontal);
        @apply(--layout-center);

        position: relative;
      }

      .input-content ::content label,
      .input-content ::content .paper-input-label {
        position: absolute;
        top: 0;
        right: 0;
        left: 0;
        width: 100%;
        font: inherit;
        color: var(--paper-input-container-color, --secondary-text-color);
        -webkit-transition: -webkit-transform 0.25s, width 0.25s;
        transition: transform 0.25s, width 0.25s;
        -webkit-transform-origin: left top;
        transform-origin: left top;

        @apply(--paper-font-common-nowrap);
        @apply(--paper-font-subhead);
        @apply(--paper-input-container-label);
        @apply(--paper-transition-easing);
      }

      .input-content.label-is-floating ::content label,
      .input-content.label-is-floating ::content .paper-input-label {
        -webkit-transform: translateY(-75%) scale(0.75);
        transform: translateY(-75%) scale(0.75);

        /* Since we scale to 75/100 of the size, we actually have 100/75 of the
        original space now available */
        width: 133%;

        @apply(--paper-input-container-label-floating);
      }

      :host-context([dir="rtl"]) .input-content.label-is-floating ::content label,
      :host-context([dir="rtl"]) .input-content.label-is-floating ::content .paper-input-label {
        /* TODO(noms): Figure out why leaving the width at 133% before the animation
         * actually makes
         * it wider on the right side, not left side, as you would expect in RTL */
        width: 100%;
        -webkit-transform-origin: right top;
        transform-origin: right top;
      }

      .input-content.label-is-highlighted ::content label,
      .input-content.label-is-highlighted ::content .paper-input-label {
        color: var(--paper-input-container-focus-color, --primary-color);

        @apply(--paper-input-container-label-focus);
      }

      .input-content.is-invalid ::content label,
      .input-content.is-invalid ::content .paper-input-label {
        color: var(--paper-input-container-invalid-color, --error-color);
      }

      .input-content.label-is-hidden ::content label,
      .input-content.label-is-hidden ::content .paper-input-label {
        visibility: hidden;
      }

      .input-content ::content input,
      .input-content ::content textarea,
      .input-content ::content iron-autogrow-textarea,
      .input-content ::content .paper-input-input {
        position: relative; /* to make a stacking context */
        outline: none;
        box-shadow: none;
        padding: 0;
        width: 100%;
        max-width: 100%;
        background: transparent;
        border: none;
        color: var(--paper-input-container-input-color, --primary-text-color);
        -webkit-appearance: none;
        text-align: inherit;

        @apply(--paper-font-subhead);
        @apply(--paper-input-container-input);
      }

      ::content [prefix] {
        @apply(--paper-font-subhead);

        @apply(--paper-input-prefix);
        @apply(--layout-flex-none);
      }

      ::content [suffix] {
        @apply(--paper-font-subhead);

        @apply(--paper-input-suffix);
        @apply(--layout-flex-none);
      }

      /* Firefox sets a min-width on the input, which can cause layout issues */
      .input-content ::content input {
        min-width: 0;
      }

      .input-content ::content textarea {
        resize: none;
      }

      .add-on-content {
        position: relative;
      }

      .add-on-content.is-invalid ::content * {
        color: var(--paper-input-container-invalid-color, --error-color);
      }

      .add-on-content.is-highlighted ::content * {
        color: var(--paper-input-container-focus-color, --primary-color);
      }
    </style>

    <template is="dom-if" if="[[!noLabelFloat]]">
      <div class="floated-label-placeholder">&nbsp;</div>
    </template>

    <div class$="[[_computeInputContentClass(noLabelFloat,alwaysFloatLabel,focused,invalid,_inputHasContent)]]">
      <content select="[prefix]" id="prefix"></content>

      <div class="label-and-input-container" id="labelAndInputContainer">
        <content select=":not([add-on]):not([prefix]):not([suffix])"></content>
      </div>

      <content select="[suffix]"></content>
    </div>

    <div class$="[[_computeUnderlineClass(focused,invalid)]]">
      <div class="unfocused-line"></div>
      <div class="focused-line"></div>
    </div>

    <div class$="[[_computeAddOnContentClass(focused,invalid)]]">
      <content id="addOnContent" select="[add-on]"></content>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'paper-input-container',

    properties: {
      /**
       * Set to true to disable the floating label. The label disappears when the input value is
       * not null.
       */
      noLabelFloat: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to always float the floating label.
       */
      alwaysFloatLabel: {
        type: Boolean,
        value: false
      },

      /**
       * The attribute to listen for value changes on.
       */
      attrForValue: {
        type: String,
        value: 'bind-value'
      },

      /**
       * Set to true to auto-validate the input value when it changes.
       */
      autoValidate: {
        type: Boolean,
        value: false
      },

      /**
       * True if the input is invalid. This property is set automatically when the input value
       * changes if auto-validating, or when the `iron-input-validate` event is heard from a child.
       */
      invalid: {
        observer: '_invalidChanged',
        type: Boolean,
        value: false
      },

      /**
       * True if the input has focus.
       */
      focused: {
        readOnly: true,
        type: Boolean,
        value: false,
        notify: true
      },

      _addons: {
        type: Array
        // do not set a default value here intentionally - it will be initialized lazily when a
        // distributed child is attached, which may occur before configuration for this element
        // in polyfill.
      },

      _inputHasContent: {
        type: Boolean,
        value: false
      },

      _inputSelector: {
        type: String,
        value: 'input,textarea,.paper-input-input'
      },

      _boundOnFocus: {
        type: Function,
        value: function() {
          return this._onFocus.bind(this);
        }
      },

      _boundOnBlur: {
        type: Function,
        value: function() {
          return this._onBlur.bind(this);
        }
      },

      _boundOnInput: {
        type: Function,
        value: function() {
          return this._onInput.bind(this);
        }
      },

      _boundValueChanged: {
        type: Function,
        value: function() {
          return this._onValueChanged.bind(this);
        }
      }
    },

    listeners: {
      'addon-attached': '_onAddonAttached',
      'iron-input-validate': '_onIronInputValidate'
    },

    get _valueChangedEvent() {
      return this.attrForValue + '-changed';
    },

    get _propertyForValue() {
      return Polymer.CaseMap.dashToCamelCase(this.attrForValue);
    },

    get _inputElement() {
      return Polymer.dom(this).querySelector(this._inputSelector);
    },

    get _inputElementValue() {
      return this._inputElement[this._propertyForValue] || this._inputElement.value;
    },

    ready: function() {
      if (!this._addons) {
        this._addons = [];
      }
      this.addEventListener('focus', this._boundOnFocus, true);
      this.addEventListener('blur', this._boundOnBlur, true);
    },

    attached: function() {
      if (this.attrForValue) {
        this._inputElement.addEventListener(this._valueChangedEvent, this._boundValueChanged);
      } else {
        this.addEventListener('input', this._onInput);
      }

      // Only validate when attached if the input already has a value.
      if (this._inputElementValue != '') {
        this._handleValueAndAutoValidate(this._inputElement);
      } else {
        this._handleValue(this._inputElement);
      }
    },

    _onAddonAttached: function(event) {
      if (!this._addons) {
        this._addons = [];
      }
      var target = event.target;
      if (this._addons.indexOf(target) === -1) {
        this._addons.push(target);
        if (this.isAttached) {
          this._handleValue(this._inputElement);
        }
      }
    },

    _onFocus: function() {
      this._setFocused(true);
    },

    _onBlur: function() {
      this._setFocused(false);
      this._handleValueAndAutoValidate(this._inputElement);
    },

    _onInput: function(event) {
      this._handleValueAndAutoValidate(event.target);
    },

    _onValueChanged: function(event) {
      this._handleValueAndAutoValidate(event.target);
    },

    _handleValue: function(inputElement) {
      var value = this._inputElementValue;

      // type="number" hack needed because this.value is empty until it's valid
      if (value || value === 0 || (inputElement.type === 'number' && !inputElement.checkValidity())) {
        this._inputHasContent = true;
      } else {
        this._inputHasContent = false;
      }

      this.updateAddons({
        inputElement: inputElement,
        value: value,
        invalid: this.invalid
      });
    },

    _handleValueAndAutoValidate: function(inputElement) {
      if (this.autoValidate) {
        var valid;
        if (inputElement.validate) {
          valid = inputElement.validate(this._inputElementValue);
        } else {
          valid = inputElement.checkValidity();
        }
        this.invalid = !valid;
      }

      // Call this last to notify the add-ons.
      this._handleValue(inputElement);
    },

    _onIronInputValidate: function(event) {
      this.invalid = this._inputElement.invalid;
    },

    _invalidChanged: function() {
      if (this._addons) {
        this.updateAddons({invalid: this.invalid});
      }
    },

    /**
     * Call this to update the state of add-ons.
     * @param {Object} state Add-on state.
     */
    updateAddons: function(state) {
      for (var addon, index = 0; addon = this._addons[index]; index++) {
        addon.update(state);
      }
    },

    _computeInputContentClass: function(noLabelFloat, alwaysFloatLabel, focused, invalid, _inputHasContent) {
      var cls = 'input-content';
      if (!noLabelFloat) {
        var label = this.querySelector('label');

        if (alwaysFloatLabel || _inputHasContent) {
          cls += ' label-is-floating';
          // If the label is floating, ignore any offsets that may have been
          // applied from a prefix element.
          this.$.labelAndInputContainer.style.position = 'static';

          if (invalid) {
            cls += ' is-invalid';
          } else if (focused) {
            cls += " label-is-highlighted";
          }
        } else {
          // When the label is not floating, it should overlap the input element.
          if (label) {
            this.$.labelAndInputContainer.style.position = 'relative';
          }
        }
      } else {
        if (_inputHasContent) {
          cls += ' label-is-hidden';
        }
      }
      return cls;
    },

    _computeUnderlineClass: function(focused, invalid) {
      var cls = 'underline';
      if (invalid) {
        cls += ' is-invalid';
      } else if (focused) {
        cls += ' is-highlighted'
      }
      return cls;
    },

    _computeAddOnContentClass: function(focused, invalid) {
      var cls = 'add-on-content';
      if (invalid) {
        cls += ' is-invalid';
      } else if (focused) {
        cls += ' is-highlighted'
      }
      return cls;
    }
  });
</script>


<dom-module id="paper-input-error" assetpath="bower_components/paper-input/">
  <template>
    <style>
      :host {
        display: inline-block;
        visibility: hidden;

        color: var(--paper-input-container-invalid-color, --error-color);

        @apply(--paper-font-caption);
        @apply(--paper-input-error);
        position: absolute;
        left:0;
        right:0;
      }

      :host([invalid]) {
        visibility: visible;
      };
    </style>

    <content></content>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'paper-input-error',

    behaviors: [
      Polymer.PaperInputAddonBehavior
    ],

    properties: {
      /**
       * True if the error is showing.
       */
      invalid: {
        readOnly: true,
        reflectToAttribute: true,
        type: Boolean
      }
    },

    /**
     * This overrides the update function in PaperInputAddonBehavior.
     * @param {{
     *   inputElement: (Element|undefined),
     *   value: (string|undefined),
     *   invalid: boolean
     * }} state -
     *     inputElement: The input element.
     *     value: The input value.
     *     invalid: True if the input value is invalid.
     */
    update: function(state) {
      this._setInvalid(state.invalid);
    }
  });
</script>


<dom-module id="paper-input" assetpath="bower_components/paper-input/">
  <template>
    <style>
      :host {
        display: block;
      }

      input::-webkit-input-placeholder {
        color: var(--paper-input-container-color, --secondary-text-color);
      }

      input:-moz-placeholder {
        color: var(--paper-input-container-color, --secondary-text-color);
      }

      input::-moz-placeholder {
        color: var(--paper-input-container-color, --secondary-text-color);
      }

      input:-ms-input-placeholder {
        color: var(--paper-input-container-color, --secondary-text-color);
      }
    </style>

    <paper-input-container no-label-float="[[noLabelFloat]]" always-float-label="[[_computeAlwaysFloatLabel(alwaysFloatLabel,placeholder)]]" auto-validate$="[[autoValidate]]" disabled$="[[disabled]]" invalid="[[invalid]]">

      <content select="[prefix]"></content>

      <label hidden$="[[!label]]">[[label]]</label>

      <input is="iron-input" id="input" aria-labelledby$="[[_ariaLabelledBy]]" aria-describedby$="[[_ariaDescribedBy]]" disabled$="[[disabled]]" title$="[[title]]" bind-value="{{value}}" invalid="{{invalid}}" prevent-invalid-input="[[preventInvalidInput]]" allowed-pattern="[[allowedPattern]]" validator="[[validator]]" type$="[[type]]" pattern$="[[pattern]]" required$="[[required]]" autocomplete$="[[autocomplete]]" autofocus$="[[autofocus]]" inputmode$="[[inputmode]]" minlength$="[[minlength]]" maxlength$="[[maxlength]]" min$="[[min]]" max$="[[max]]" step$="[[step]]" name$="[[name]]" placeholder$="[[placeholder]]" readonly$="[[readonly]]" list$="[[list]]" size$="[[size]]" autocapitalize$="[[autocapitalize]]" autocorrect$="[[autocorrect]]" on-change="_onChange" tabindex$="[[tabindex]]" autosave$="[[autosave]]" results$="[[results]]" accept$="[[accept]]" multiple$="[[multiple]]">

      <content select="[suffix]"></content>

      <template is="dom-if" if="[[errorMessage]]">
        <paper-input-error>[[errorMessage]]</paper-input-error>
      </template>

      <template is="dom-if" if="[[charCounter]]">
        <paper-input-char-counter></paper-input-char-counter>
      </template>

    </paper-input-container>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'paper-input',

    behaviors: [
      Polymer.IronFormElementBehavior,
      Polymer.PaperInputBehavior
    ]
  });
</script>


<dom-module id="paper-progress" assetpath="bower_components/paper-progress/">
  <template>
    <style>
      :host {
        display: block;
        width: 200px;
        position: relative;
        overflow: hidden;
      }

      #progressContainer {
        position: relative;
      }

      #progressContainer,
      /* the stripe for the indeterminate animation*/
      .indeterminate::after {
        height: var(--paper-progress-height, 4px);
      }

      #primaryProgress,
      #secondaryProgress,
      .indeterminate::after {
        @apply(--layout-fit);
      }

      #progressContainer,
      .indeterminate::after {
        background: var(--paper-progress-container-color, --google-grey-300);
      }

      :host(.transiting) #primaryProgress,
      :host(.transiting) #secondaryProgress {
        -webkit-transition-property: -webkit-transform;
        transition-property: transform;

        /* Duration */
        -webkit-transition-duration: var(--paper-progress-transition-duration, 0.08s);
        transition-duration: var(--paper-progress-transition-duration, 0.08s);

        /* Timing function */
        -webkit-transition-timing-function: var(--paper-progress-transition-timing-function, ease);
        transition-timing-function: var(--paper-progress-transition-timing-function, ease);

        /* Delay */
        -webkit-transition-delay: var(--paper-progress-transition-delay, 0s);
        transition-delay: var(--paper-progress-transition-delay, 0s);
      }

      #primaryProgress,
      #secondaryProgress {
        @apply(--layout-fit);
        -webkit-transform-origin: left center;
        transform-origin: left center;
        -webkit-transform: scaleX(0);
        transform: scaleX(0);
        will-change: transform;
      }

      #primaryProgress {
        background: var(--paper-progress-active-color, --google-green-500);
      }

      #secondaryProgress {
        background: var(--paper-progress-secondary-color, --google-green-100);
      }

      :host([disabled]) #primaryProgress {
        background: var(--paper-progress-disabled-active-color, --google-grey-500);
      }

      :host([disabled]) #secondaryProgress {
        background: var(--paper-progress-disabled-secondary-color, --google-grey-300);
      }

      :host(:not([disabled])) #primaryProgress.indeterminate {
        -webkit-transform-origin: right center;
        transform-origin: right center;
        -webkit-animation: indeterminate-bar 2s linear infinite;
        animation: indeterminate-bar 2s linear infinite;
      }

      :host(:not([disabled])) #primaryProgress.indeterminate::after {
        content: "";
        -webkit-transform-origin: center center;
        transform-origin: center center;

        -webkit-animation: indeterminate-splitter 2s linear infinite;
        animation: indeterminate-splitter 2s linear infinite;
      }

      @-webkit-keyframes indeterminate-bar {
        0% {
          -webkit-transform: scaleX(1) translateX(-100%);
        }
        50% {
          -webkit-transform: scaleX(1) translateX(0%);
        }
        75% {
          -webkit-transform: scaleX(1) translateX(0%);
          -webkit-animation-timing-function: cubic-bezier(.28,.62,.37,.91);
        }
        100% {
          -webkit-transform: scaleX(0) translateX(0%);
        }
      }

      @-webkit-keyframes indeterminate-splitter {
        0% {
          -webkit-transform: scaleX(.75) translateX(-125%);
        }
        30% {
          -webkit-transform: scaleX(.75) translateX(-125%);
          -webkit-animation-timing-function: cubic-bezier(.42,0,.6,.8);
        }
        90% {
          -webkit-transform: scaleX(.75) translateX(125%);
        }
        100% {
          -webkit-transform: scaleX(.75) translateX(125%);
        }
      }

      @keyframes indeterminate-bar {
        0% {
          transform: scaleX(1) translateX(-100%);
        }
        50% {
          transform: scaleX(1) translateX(0%);
        }
        75% {
          transform: scaleX(1) translateX(0%);
          animation-timing-function: cubic-bezier(.28,.62,.37,.91);
        }
        100% {
          transform: scaleX(0) translateX(0%);
        }
      }

      @keyframes indeterminate-splitter {
        0% {
          transform: scaleX(.75) translateX(-125%);
        }
        30% {
          transform: scaleX(.75) translateX(-125%);
          animation-timing-function: cubic-bezier(.42,0,.6,.8);
        }
        90% {
          transform: scaleX(.75) translateX(125%);
        }
        100% {
          transform: scaleX(.75) translateX(125%);
        }
      }
    </style>

    <div id="progressContainer">
      <div id="secondaryProgress" hidden$="[[_hideSecondaryProgress(secondaryRatio)]]"></div>
      <div id="primaryProgress"></div>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'paper-progress',

    behaviors: [
      Polymer.IronRangeBehavior
    ],

    properties: {
      /**
       * The number that represents the current secondary progress.
       */
      secondaryProgress: {
        type: Number,
        value: 0
      },

      /**
       * The secondary ratio
       */
      secondaryRatio: {
        type: Number,
        value: 0,
        readOnly: true
      },

      /**
       * Use an indeterminate progress indicator.
       */
      indeterminate: {
        type: Boolean,
        value: false,
        observer: '_toggleIndeterminate'
      },

      /**
       * True if the progress is disabled.
       */
      disabled: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: '_disabledChanged'
      }
    },

    observers: [
      '_progressChanged(secondaryProgress, value, min, max)'
    ],

    hostAttributes: {
      role: 'progressbar'
    },

    _toggleIndeterminate: function(indeterminate) {
      // If we use attribute/class binding, the animation sometimes doesn't translate properly
      // on Safari 7.1. So instead, we toggle the class here in the update method.
      this.toggleClass('indeterminate', indeterminate, this.$.primaryProgress);
    },

    _transformProgress: function(progress, ratio) {
      var transform = 'scaleX(' + (ratio / 100) + ')';
      progress.style.transform = progress.style.webkitTransform = transform;
    },

    _mainRatioChanged: function(ratio) {
      this._transformProgress(this.$.primaryProgress, ratio);
    },

    _progressChanged: function(secondaryProgress, value, min, max) {
      secondaryProgress = this._clampValue(secondaryProgress);
      value = this._clampValue(value);

      var secondaryRatio = this._calcRatio(secondaryProgress) * 100;
      var mainRatio = this._calcRatio(value) * 100;

      this._setSecondaryRatio(secondaryRatio);
      this._transformProgress(this.$.secondaryProgress, secondaryRatio);
      this._transformProgress(this.$.primaryProgress, mainRatio);

      this.secondaryProgress = secondaryProgress;

      this.setAttribute('aria-valuenow', value);
      this.setAttribute('aria-valuemin', min);
      this.setAttribute('aria-valuemax', max);
    },

    _disabledChanged: function(disabled) {
      this.setAttribute('aria-disabled', disabled ? 'true' : 'false');
    },

    _hideSecondaryProgress: function(secondaryRatio) {
      return secondaryRatio === 0;
    }
  });
</script>


<dom-module id="paper-slider" assetpath="bower_components/paper-slider/">
  <template strip-whitespace="">
    <style>
      :host {
        @apply(--layout);
        @apply(--layout-justified);
        @apply(--layout-center);
        width: 200px;
        cursor: default;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
        --paper-progress-active-color: var(--paper-slider-active-color, --google-blue-700);
        --paper-progress-secondary-color: var(--paper-slider-secondary-color, --google-blue-300);
        --paper-progress-disabled-active-color: var(--paper-slider-disabled-active-color, --paper-grey-400);
        --paper-progress-disabled-secondary-color: var(--paper-slider-disabled-secondary-color, --paper-grey-400);
      }

      /* focus shows the ripple */
      :host(:focus) {
        outline: none;
      }

      #sliderContainer {
        position: relative;
        width: 100%;
        height: calc(30px + var(--paper-slider-height, 2px));
        margin-left: calc(15px + var(--paper-slider-height, 2px)/2);
        margin-right: calc(15px + var(--paper-slider-height, 2px)/2);
      }

      #sliderContainer:focus {
        outline: 0;
      }

      #sliderContainer.editable {
        margin-top: 12px;
        margin-bottom: 12px;
      }

      .bar-container {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        overflow: hidden;
      }

      .ring > .bar-container {
        left: calc(5px + var(--paper-slider-height, 2px)/2);
        transition: left 0.18s ease;
      }

      .ring.expand.dragging > .bar-container {
        transition: none;
      }

      .ring.expand:not(.pin) > .bar-container {
        left: calc(8px + var(--paper-slider-height, 2px)/2);
      }

      #sliderBar {
        padding: 15px 0;
        width: 100%;
        background-color: var(--paper-slider-bar-color, transparent);
        --paper-progress-container-color: var(--paper-grey-400);
        --paper-progress-height: var(--paper-slider-height, 2px);
      }

      .slider-markers {
        position: absolute;
        top: calc(14px + var(--paper-slider-height,2px)/2);
        height: var(--paper-slider-height, 2px);
        left: 0;
        right: -1px;
        box-sizing: border-box;
        pointer-events: none;
        @apply(--layout-horizontal);
      }

      .slider-marker {
        @apply(--layout-flex);
      }
      .slider-markers::after,
      .slider-marker::after {
        content: "";
        display: block;
        margin-left: -1px;
        width: 2px;
        height: 2px;
        border-radius: 50%;
        background-color: black;
      }

      #sliderKnob {
        position: absolute;
        left: 0;
        top: 0;
        margin-left: calc(-15px - var(--paper-slider-height, 2px)/2);
        width: calc(30px + var(--paper-slider-height, 2px));
        height: calc(30px + var(--paper-slider-height, 2px));
      }

      .transiting > #sliderKnob {
        transition: left 0.08s ease;
      }

      #sliderKnob:focus {
        outline: none;
      }

      #sliderKnob.dragging {
        transition: none;
      }

      .snaps > #sliderKnob.dragging {
        transition: -webkit-transform 0.08s ease;
        transition: transform 0.08s ease;
      }

      #sliderKnobInner {
        margin: 10px;
        width: calc(100% - 20px);
        height: calc(100% - 20px);
        background-color: var(--paper-slider-knob-color, --google-blue-700);
        border: 2px solid var(--paper-slider-knob-color, --google-blue-700);
        border-radius: 50%;

        -moz-box-sizing: border-box;
        box-sizing: border-box;

        transition-property: -webkit-transform, background-color, border;
        transition-property: transform, background-color, border;
        transition-duration: 0.18s;
        transition-timing-function: ease;
      }

      .expand:not(.pin) > #sliderKnob > #sliderKnobInner {
        -webkit-transform: scale(1.5);
        transform: scale(1.5);
      }

      .ring > #sliderKnob > #sliderKnobInner {
        background-color: var(--paper-slider-knob-start-color, transparent);
        border: 2px solid var(--paper-slider-knob-start-border-color, --paper-grey-400);
      }

      #sliderKnobInner::before {
        background-color: var(--paper-slider-pin-color, --google-blue-700);
      }

      .pin > #sliderKnob > #sliderKnobInner::before {
        content: "";
        position: absolute;
        top: 0;
        left: 50%;
        margin-left: -13px;
        width: 26px;
        height: 26px;
        border-radius: 50% 50% 50% 0;

        -webkit-transform: rotate(-45deg) scale(0) translate(0);
        transform: rotate(-45deg) scale(0) translate(0);
      }

      #sliderKnobInner::before,
      #sliderKnobInner::after {
        transition: -webkit-transform .18s ease, background-color .18s ease;
        transition: transform .18s ease, background-color .18s ease;
      }

      .pin.ring > #sliderKnob > #sliderKnobInner::before {
        background-color: var(--paper-slider-pin-start-color, --paper-grey-400);
      }

      .pin.expand > #sliderKnob > #sliderKnobInner::before {
        -webkit-transform: rotate(-45deg) scale(1) translate(17px, -17px);
        transform: rotate(-45deg) scale(1) translate(17px, -17px);
      }

      .pin > #sliderKnob > #sliderKnobInner::after {
        content: attr(value);
        position: absolute;
        top: 0;
        left: 50%;
        margin-left: -16px;
        width: 32px;
        height: 26px;
        text-align: center;
        color: var(--paper-slider-font-color, #fff);
        font-size: 10px;

        -webkit-transform: scale(0) translate(0);
        transform: scale(0) translate(0);
      }

      .pin.expand > #sliderKnob > #sliderKnobInner::after {
        -webkit-transform: scale(1) translate(0, -17px);
        transform: scale(1) translate(0, -17px);
      }

      /* paper-input */
      .slider-input {
        width: 50px;
        overflow: hidden;
        --paper-input-container-input: {
          text-align: center;
        };
        @apply(--paper-slider-input);
      }

      /* disabled state */
      #sliderContainer.disabled {
        pointer-events: none;
      }

      .disabled > #sliderKnob > #sliderKnobInner {
        background-color: var(--paper-slider-disabled-knob-color, --paper-grey-400);
        border: 2px solid var(--paper-slider-disabled-knob-color, --paper-grey-400);
        -webkit-transform: scale3d(0.75, 0.75, 1);
        transform: scale3d(0.75, 0.75, 1);
      }

      .disabled.ring > #sliderKnob > #sliderKnobInner {
        background-color: var(--paper-slider-knob-start-color, transparent);
        border: 2px solid var(--paper-slider-knob-start-border-color, --paper-grey-400);
      }

      paper-ripple {
        color: var(--paper-slider-knob-color, --google-blue-700);
      }
    </style>

    <div id="sliderContainer" class$="[[_getClassNames(disabled, pin, snaps, immediateValue, min, expand, dragging, transiting, editable)]]">

      <div class="bar-container">
        <paper-progress disabled$="[[disabled]]" id="sliderBar" aria-hidden="true" min="[[min]]" max="[[max]]" step="[[step]]" value="[[immediateValue]]" secondary-progress="[[secondaryProgress]]" on-down="_bardown" on-up="_resetKnob" on-track="_onTrack">
        </paper-progress>
      </div>

      <template is="dom-if" if="[[snaps]]">
        <div class="slider-markers">
          <template is="dom-repeat" items="[[markers]]">
            <div class="slider-marker"></div>
          </template>
        </div>
      </template>

      <div id="sliderKnob" on-down="_knobdown" on-up="_resetKnob" on-track="_onTrack" on-transitionend="_knobTransitionEnd">
          <div id="sliderKnobInner" value$="[[immediateValue]]"></div>
      </div>
    </div>

    <template is="dom-if" if="[[editable]]">
      <paper-input id="input" type="number" step="[[step]]" min="[[min]]" max="[[max]]" class="slider-input" disabled$="[[disabled]]" value="[[immediateValue]]" on-change="_changeValue" on-keydown="_inputKeyDown" no-label-float="">
      </paper-input>
    </template>
  </template>

  <script>
    Polymer({
      is: 'paper-slider',

      behaviors: [
        Polymer.IronA11yKeysBehavior,
        Polymer.IronFormElementBehavior,
        Polymer.PaperInkyFocusBehavior,
        Polymer.IronRangeBehavior
      ],

      properties: {
        /**
         * If true, the slider thumb snaps to tick marks evenly spaced based
         * on the `step` property value.
         */
        snaps: {
          type: Boolean,
          value: false,
          notify: true
        },

        /**
         * If true, a pin with numeric value label is shown when the slider thumb
         * is pressed. Use for settings for which users need to know the exact
         * value of the setting.
         */
        pin: {
          type: Boolean,
          value: false,
          notify: true
        },

        /**
         * The number that represents the current secondary progress.
         */
        secondaryProgress: {
          type: Number,
          value: 0,
          notify: true,
          observer: '_secondaryProgressChanged'
        },

        /**
         * If true, an input is shown and user can use it to set the slider value.
         */
        editable: {
          type: Boolean,
          value: false
        },

        /**
         * The immediate value of the slider.  This value is updated while the user
         * is dragging the slider.
         */
        immediateValue: {
          type: Number,
          value: 0,
          readOnly: true,
          notify: true
        },

        /**
         * The maximum number of markers
         */
        maxMarkers: {
          type: Number,
          value: 0,
          notify: true,
          observer: '_maxMarkersChanged'
        },

        /**
         * If true, the knob is expanded
         */
        expand: {
          type: Boolean,
          value: false,
          readOnly: true
        },

        /**
         * True when the user is dragging the slider.
         */
        dragging: {
          type: Boolean,
          value: false,
          readOnly: true
        },

        transiting: {
          type: Boolean,
          value: false,
          readOnly: true
        },

        markers: {
          type: Array,
          readOnly: true,
          value: []
        },
      },

      observers: [
        '_updateKnob(value, min, max, snaps, step)',
        '_valueChanged(value)',
        '_immediateValueChanged(immediateValue)'
      ],

      hostAttributes: {
        role: 'slider',
        tabindex: 0
      },

      keyBindings: {
        'left down pagedown home': '_decrementKey',
        'right up pageup end': '_incrementKey'
      },

      ready: function() {
        // issue polymer/polymer#1305
        this.async(function() {
          this._updateKnob(this.value);
        }, 1);
      },

      /**
       * Increases value by `step` but not above `max`.
       * @method increment
       */
      increment: function() {
        this.value = this._clampValue(this.value + this.step);
      },

      /**
       * Decreases value by `step` but not below `min`.
       * @method decrement
       */
      decrement: function() {
        this.value = this._clampValue(this.value - this.step);
      },

      _updateKnob: function(value, min, max, snaps, step) {
        this.setAttribute('aria-valuemin', min);
        this.setAttribute('aria-valuemax', max);
        this.setAttribute('aria-valuenow', value);

        this._positionKnob(this._calcRatio(value));
      },

      _valueChanged: function() {
        this.fire('value-change');
      },

      _immediateValueChanged: function() {
        if (this.dragging) {
          this.fire('immediate-value-change');
        } else {
          this.value = this.immediateValue;
        }
      },

      _secondaryProgressChanged: function() {
        this.secondaryProgress = this._clampValue(this.secondaryProgress);
      },

      _expandKnob: function() {
        this._setExpand(true);
      },

      _resetKnob: function() {
        this.cancelDebouncer('expandKnob');
        this._setExpand(false);
      },

      _positionKnob: function(ratio) {
        this._setImmediateValue(this._calcStep(this._calcKnobPosition(ratio)));
        this._setRatio(this._calcRatio(this.immediateValue));

        this.$.sliderKnob.style.left = (this.ratio * 100) + '%';
        if (this.dragging) {
          this._knobstartx = this.ratio * this._w;
          this.translate3d(0, 0, 0, this.$.sliderKnob);
        }
      },

      _calcKnobPosition: function(ratio) {
        return (this.max - this.min) * ratio + this.min;
      },

      _onTrack: function(event) {
        event.stopPropagation();
        switch (event.detail.state) {
          case 'start':
            this._trackStart(event);
            break;
          case 'track':
            this._trackX(event);
            break;
          case 'end':
            this._trackEnd();
            break;
        }
      },

      _trackStart: function(event) {
        this._w = this.$.sliderBar.offsetWidth;
        this._x = this.ratio * this._w;
        this._startx = this._x;
        this._knobstartx = this._startx;
        this._minx = - this._startx;
        this._maxx = this._w - this._startx;
        this.$.sliderKnob.classList.add('dragging');
        this._setDragging(true);
      },

      _trackX: function(e) {
        if (!this.dragging) {
          this._trackStart(e);
        }

        var dx = Math.min(this._maxx, Math.max(this._minx, e.detail.dx));
        this._x = this._startx + dx;

        var immediateValue = this._calcStep(this._calcKnobPosition(this._x / this._w));
        this._setImmediateValue(immediateValue);

        // update knob's position
        var translateX = ((this._calcRatio(this.immediateValue) * this._w) - this._knobstartx);
        this.translate3d(translateX + 'px', 0, 0, this.$.sliderKnob);
      },

      _trackEnd: function() {
        var s = this.$.sliderKnob.style;

        this.$.sliderKnob.classList.remove('dragging');
        this._setDragging(false);
        this._resetKnob();
        this.value = this.immediateValue;

        s.transform = s.webkitTransform = '';

        this.fire('change');
      },

      _knobdown: function(event) {
        this._expandKnob();

        // cancel selection
        event.preventDefault();

        // set the focus manually because we will called prevent default
        this.focus();
      },

      _bardown: function(event) {
        this._w = this.$.sliderBar.offsetWidth;
        var rect = this.$.sliderBar.getBoundingClientRect();
        var ratio = (event.detail.x - rect.left) / this._w;
        var prevRatio = this.ratio;

        this._setTransiting(true);

        this._positionKnob(ratio);

        this.debounce('expandKnob', this._expandKnob, 60);

        // if the ratio doesn't change, sliderKnob's animation won't start
        // and `_knobTransitionEnd` won't be called
        // Therefore, we need to manually update the `transiting` state

        if (prevRatio === this.ratio) {
          this._setTransiting(false);
        }

        this.async(function() {
          this.fire('change');
        });

        // cancel selection
        event.preventDefault();

        // set the focus manually because we will called prevent default
        this.focus();
      },

      _knobTransitionEnd: function(event) {
        if (event.target === this.$.sliderKnob) {
          this._setTransiting(false);
        }
      },

      _maxMarkersChanged: function(maxMarkers) {
        if (!this.snaps) {
          this._setMarkers([]);
        }
        var steps = Math.round((this.max - this.min) / this.step);
        if (steps > maxMarkers) {
          steps = maxMarkers;
        }
        this._setMarkers(new Array(steps));
      },

      _mergeClasses: function(classes) {
        return Object.keys(classes).filter(
          function(className) {
            return classes[className];
          }).join(' ');
      },

      _getClassNames: function() {
        return this._mergeClasses({
          disabled: this.disabled,
          pin: this.pin,
          snaps: this.snaps,
          ring: this.immediateValue <= this.min,
          expand: this.expand,
          dragging: this.dragging,
          transiting: this.transiting,
          editable: this.editable
        });
      },

      _incrementKey: function(event) {
        if (!this.disabled) {
          if (event.detail.key === 'end') {
            this.value = this.max;
          } else {
            this.increment();
          }
          this.fire('change');
        }
      },

      _decrementKey: function(event) {
        if (!this.disabled) {
          if (event.detail.key === 'home') {
            this.value = this.min;
          } else {
            this.decrement();
          }
          this.fire('change');
        }
      },

      _changeValue: function(event) {
        this.value = event.target.value;
        this.fire('change');
      },

      _inputKeyDown: function(event) {
        event.stopPropagation();
      },

      // create the element ripple inside the `sliderKnob`
      _createRipple: function() {
        this._rippleContainer = this.$.sliderKnob;
        return Polymer.PaperInkyFocusBehaviorImpl._createRipple.call(this);
      },

      // Hide the ripple when user is not interacting with keyboard.
      // This behavior is different from other ripple-y controls, but is
      // according to spec: https://www.google.com/design/spec/components/sliders.html
      _focusedChanged: function(receivedFocusFromKeyboard) {
        if (receivedFocusFromKeyboard) {
          this.ensureRipple();
        }
        if (this.hasRipple()) {
          // note, ripple must be un-hidden prior to setting `holdDown`
          if (receivedFocusFromKeyboard) {
            this._ripple.style.display = '';
          } else {
            this._ripple.style.display = 'none';
          }
          this._ripple.holdDown = receivedFocusFromKeyboard;
        }
      }
    });

    /**
     * Fired when the slider's value changes.
     *
     * @event value-change
     */

    /**
     * Fired when the slider's immediateValue changes.
     *
     * @event immediate-value-change
     */

    /**
     * Fired when the slider's value changes due to user interaction.
     *
     * Changes to the slider's value due to changes in an underlying
     * bound variable will not trigger this event.
     *
     * @event change
     */
  </script>
</dom-module>
<style is="custom-style">

  :root {

    --shadow-transition: {
      transition: box-shadow 0.28s cubic-bezier(0.4, 0, 0.2, 1);
    };

    --shadow-none: {
      box-shadow: none;
    };

    /* from http://codepen.io/shyndman/pen/c5394ddf2e8b2a5c9185904b57421cdb */

    --shadow-elevation-2dp: {
      box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14),
                  0 1px 5px 0 rgba(0, 0, 0, 0.12),
                  0 3px 1px -2px rgba(0, 0, 0, 0.2);
    };

    --shadow-elevation-3dp: {
      box-shadow: 0 3px 4px 0 rgba(0, 0, 0, 0.14),
                  0 1px 8px 0 rgba(0, 0, 0, 0.12),
                  0 3px 3px -2px rgba(0, 0, 0, 0.4);
    };

    --shadow-elevation-4dp: {
      box-shadow: 0 4px 5px 0 rgba(0, 0, 0, 0.14),
                  0 1px 10px 0 rgba(0, 0, 0, 0.12),
                  0 2px 4px -1px rgba(0, 0, 0, 0.4);
    };

    --shadow-elevation-6dp: {
      box-shadow: 0 6px 10px 0 rgba(0, 0, 0, 0.14),
                  0 1px 18px 0 rgba(0, 0, 0, 0.12),
                  0 3px 5px -1px rgba(0, 0, 0, 0.4);
    };

    --shadow-elevation-8dp: {
      box-shadow: 0 8px 10px 1px rgba(0, 0, 0, 0.14),
                  0 3px 14px 2px rgba(0, 0, 0, 0.12),
                  0 5px 5px -3px rgba(0, 0, 0, 0.4);
    };

    --shadow-elevation-12dp: {
      box-shadow: 0 12px 16px 1px rgba(0, 0, 0, 0.14),
                  0 4px 22px 3px rgba(0, 0, 0, 0.12),
                  0 6px 7px -4px rgba(0, 0, 0, 0.4);
    };

    --shadow-elevation-16dp: {
      box-shadow: 0 16px 24px 2px rgba(0, 0, 0, 0.14),
                  0  6px 30px 5px rgba(0, 0, 0, 0.12),
                  0  8px 10px -5px rgba(0, 0, 0, 0.4);
    };

  }

</style>
<dom-module id="paper-material-shared-styles" assetpath="bower_components/paper-material/">
  <template>
    <style>
      :host {
        display: block;
        position: relative;
      }

      :host([elevation="1"]) {
        @apply(--shadow-elevation-2dp);
      }

      :host([elevation="2"]) {
        @apply(--shadow-elevation-4dp);
      }

      :host([elevation="3"]) {
        @apply(--shadow-elevation-6dp);
      }

      :host([elevation="4"]) {
        @apply(--shadow-elevation-8dp);
      }

      :host([elevation="5"]) {
        @apply(--shadow-elevation-16dp);
      }
    </style>
  </template>
</dom-module>


<dom-module id="paper-material" assetpath="bower_components/paper-material/">
  <template>
    <style include="paper-material-shared-styles"></style>
    <style>
      :host([animated]) {
        @apply(--shadow-transition);
      }
    </style>

    <content></content>
  </template>
</dom-module>
<script>
  Polymer({
    is: 'paper-material',

    properties: {
      /**
       * The z-depth of this element, from 0-5. Setting to 0 will remove the
       * shadow, and each increasing number greater than 0 will be "deeper"
       * than the last.
       *
       * @attribute elevation
       * @type number
       * @default 1
       */
      elevation: {
        type: Number,
        reflectToAttribute: true,
        value: 1
      },

      /**
       * Set this to true to animate the shadow when setting a new
       * `elevation` value.
       *
       * @attribute animated
       * @type boolean
       * @default false
       */
      animated: {
        type: Boolean,
        reflectToAttribute: true,
        value: false
      }
    }
  });
</script>
<script>

  /** @polymerBehavior Polymer.PaperButtonBehavior */
  Polymer.PaperButtonBehaviorImpl = {

    properties: {

      /**
       * The z-depth of this element, from 0-5. Setting to 0 will remove the
       * shadow, and each increasing number greater than 0 will be "deeper"
       * than the last.
       *
       * @attribute elevation
       * @type number
       * @default 1
       */
      elevation: {
        type: Number,
        reflectToAttribute: true,
        readOnly: true
      }

    },

    observers: [
      '_calculateElevation(focused, disabled, active, pressed, receivedFocusFromKeyboard)',
      '_computeKeyboardClass(receivedFocusFromKeyboard)'
    ],

    hostAttributes: {
      role: 'button',
      tabindex: '0',
      animated: true
    },

    _calculateElevation: function() {
      var e = 1;
      if (this.disabled) {
        e = 0;
      } else if (this.active || this.pressed) {
        e = 4;
      } else if (this.receivedFocusFromKeyboard) {
        e = 3;
      }
      this._setElevation(e);
    },

    _computeKeyboardClass: function(receivedFocusFromKeyboard) {
      this.toggleClass('keyboard-focus', receivedFocusFromKeyboard);
    },

    /**
     * In addition to `IronButtonState` behavior, when space key goes down,
     * create a ripple down effect.
     *
     * @param {!KeyboardEvent} event .
     */
    _spaceKeyDownHandler: function(event) {
      Polymer.IronButtonStateImpl._spaceKeyDownHandler.call(this, event);
      // Ensure that there is at most one ripple when the space key is held down.
      if (this.hasRipple() && this.getRipple().ripples.length < 1) {
        this._ripple.uiDownAction();
      }
    },

    /**
     * In addition to `IronButtonState` behavior, when space key goes up,
     * create a ripple up effect.
     *
     * @param {!KeyboardEvent} event .
     */
    _spaceKeyUpHandler: function(event) {
      Polymer.IronButtonStateImpl._spaceKeyUpHandler.call(this, event);
      if (this.hasRipple()) {
        this._ripple.uiUpAction();
      }
    }

  };

  /** @polymerBehavior */
  Polymer.PaperButtonBehavior = [
    Polymer.IronButtonState,
    Polymer.IronControlState,
    Polymer.PaperRippleBehavior,
    Polymer.PaperButtonBehaviorImpl
  ];

</script>


<dom-module id="paper-button" assetpath="bower_components/paper-button/">
  <template strip-whitespace="">

    <style include="paper-material">
      :host {
        display: inline-block;
        position: relative;
        box-sizing: border-box;
        min-width: 5.14em;
        margin: 0 0.29em;
        background: transparent;
        text-align: center;
        font: inherit;
        text-transform: uppercase;
        outline-width: 0;
        border-radius: 3px;
        -moz-user-select: none;
        -ms-user-select: none;
        -webkit-user-select: none;
        user-select: none;
        cursor: pointer;
        z-index: 0;
        padding: 0.7em 0.57em;

        @apply(--paper-button);
      }

      :host([raised].keyboard-focus) {
        font-weight: bold;
        @apply(--paper-button-raised-keyboard-focus);
      }

      :host(:not([raised]).keyboard-focus) {
        font-weight: bold;
        @apply(--paper-button-flat-keyboard-focus);
      }

      :host([disabled]) {
        background: #eaeaea;
        color: #a8a8a8;
        cursor: auto;
        pointer-events: none;

        @apply(--paper-button-disabled);
      }

      paper-ripple {
        color: var(--paper-button-ink-color);
      }

      :host > ::content * {
        text-transform: inherit;
      }
    </style>
    <content></content>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'paper-button',

    behaviors: [
      Polymer.PaperButtonBehavior
    ],

    properties: {
      /**
       * If true, the button should be styled with a shadow.
       */
      raised: {
        type: Boolean,
        reflectToAttribute: true,
        value: false,
        observer: '_calculateElevation'
      }
    },

    _calculateElevation: function() {
      if (!this.raised) {
        this._setElevation(0);
      } else {
        Polymer.PaperButtonBehaviorImpl._calculateElevation.apply(this);
      }
    }
    /**

    Fired when the animation finishes.
    This is useful if you want to wait until
    the ripple animation finishes to perform some action.

    @event transitionend
    @param {{node: Object}} detail Contains the animated node.
    */
  });
</script>
<script>

  /**
   * Use `Polymer.IronCheckedElementBehavior` to implement a custom element
   * that has a `checked` property, which can be used for validation if the
   * element is also `required`. Element instances implementing this behavior
   * will also be registered for use in an `iron-form` element.
   *
   * @demo demo/index.html
   * @polymerBehavior Polymer.IronCheckedElementBehavior
   */
  Polymer.IronCheckedElementBehaviorImpl = {

    properties: {
      /**
       * Fired when the checked state changes.
       *
       * @event iron-change
       */

      /**
       * Gets or sets the state, `true` is checked and `false` is unchecked.
       */
      checked: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        notify: true,
        observer: '_checkedChanged'
      },

      /**
       * If true, the button toggles the active state with each tap or press
       * of the spacebar.
       */
      toggles: {
        type: Boolean,
        value: true,
        reflectToAttribute: true
      },

      /* Overriden from Polymer.IronFormElementBehavior */
      value: {
        type: String,
        value: 'on',
        observer: '_valueChanged'
      }
    },

    observers: [
      '_requiredChanged(required)'
    ],

    created: function() {
      // Used by `iron-form` to handle the case that an element with this behavior
      // doesn't have a role of 'checkbox' or 'radio', but should still only be
      // included when the form is serialized if `this.checked === true`.
      this._hasIronCheckedElementBehavior = true;
    },

    /**
     * Returns false if the element is required and not checked, and true otherwise.
     * @param {*=} _value Ignored.
     * @return {boolean} true if `required` is false, or if `required` and `checked` are both true.
     */
    _getValidity: function(_value) {
      return this.disabled || !this.required || (this.required && this.checked);
    },

    /**
     * Update the aria-required label when `required` is changed.
     */
    _requiredChanged: function() {
      if (this.required) {
        this.setAttribute('aria-required', 'true');
      } else {
        this.removeAttribute('aria-required');
      }
    },

    /**
     * Fire `iron-changed` when the checked state changes.
     */
    _checkedChanged: function() {
      this.active = this.checked;
      this.fire('iron-change');
    },

    /**
     * Reset value to 'on' if it is set to `undefined`.
     */
    _valueChanged: function() {
      if (this.value === undefined || this.value === null) {
        this.value = 'on';
      }
    }
  };

  /** @polymerBehavior Polymer.IronCheckedElementBehavior */
  Polymer.IronCheckedElementBehavior = [
    Polymer.IronFormElementBehavior,
    Polymer.IronValidatableBehavior,
    Polymer.IronCheckedElementBehaviorImpl
  ];

</script>
<script>

  /**
   * Use `Polymer.PaperCheckedElementBehavior` to implement a custom element
   * that has a `checked` property similar to `Polymer.IronCheckedElementBehavior`
   * and is compatible with having a ripple effect.
   * @polymerBehavior Polymer.PaperCheckedElementBehavior
   */
  Polymer.PaperCheckedElementBehaviorImpl = {

    /**
     * Synchronizes the element's checked state with its ripple effect.
     */
    _checkedChanged: function() {
      Polymer.IronCheckedElementBehaviorImpl._checkedChanged.call(this);
      if (this.hasRipple()) {
        if (this.checked) {
          this._ripple.setAttribute('checked', '');
        } else {
          this._ripple.removeAttribute('checked');
        }
      }
    },

    /**
     * Synchronizes the element's `active` and `checked` state.
     */
    _buttonStateChanged: function() {
      Polymer.PaperRippleBehavior._buttonStateChanged.call(this);
      if (this.disabled) {
        return;
      }
      if (this.isAttached) {
        this.checked = this.active;
      }
    }

  };

  /** @polymerBehavior Polymer.PaperCheckedElementBehavior */
  Polymer.PaperCheckedElementBehavior = [
    Polymer.PaperInkyFocusBehavior,
    Polymer.IronCheckedElementBehavior,
    Polymer.PaperCheckedElementBehaviorImpl
  ];

</script>


<dom-module id="paper-toggle-button" assetpath="bower_components/paper-toggle-button/">
  <template strip-whitespace="">

    <style>
      :host {
        display: inline-block;
        @apply(--layout-horizontal);
        @apply(--layout-center);
        @apply(--paper-font-common-base);
      }

      :host([disabled]) {
        pointer-events: none;
      }

      :host(:focus) {
        outline:none;
      }

      .toggle-bar {
        position: absolute;
        height: 100%;
        width: 100%;
        border-radius: 8px;
        pointer-events: none;
        opacity: 0.4;
        transition: background-color linear .08s;
        background-color: var(--paper-toggle-button-unchecked-bar-color, #000000);

        @apply(--paper-toggle-button-unchecked-bar);
      }

      .toggle-button {
        position: absolute;
        top: -3px;
        left: 0;
        height: 20px;
        width: 20px;
        border-radius: 50%;
        box-shadow: 0 1px 5px 0 rgba(0, 0, 0, 0.6);
        transition: -webkit-transform linear .08s, background-color linear .08s;
        transition: transform linear .08s, background-color linear .08s;
        will-change: transform;
        background-color: var(--paper-toggle-button-unchecked-button-color, --paper-grey-50);

        @apply(--paper-toggle-button-unchecked-button);
      }

      .toggle-button.dragging {
        -webkit-transition: none;
        transition: none;
      }

      :host([checked]:not([disabled])) .toggle-bar {
        opacity: 0.5;
        background-color: var(--paper-toggle-button-checked-bar-color, --primary-color);

        @apply(--paper-toggle-button-checked-bar);
      }

      :host([disabled]) .toggle-bar {
        background-color: #000;
        opacity: 0.12;
      }

      :host([checked]) .toggle-button {
        -webkit-transform: translate(16px, 0);
        transform: translate(16px, 0);
      }

      :host([checked]:not([disabled])) .toggle-button {
        background-color: var(--paper-toggle-button-checked-button-color, --primary-color);

        @apply(--paper-toggle-button-checked-button);
      }

      :host([disabled]) .toggle-button {
        background-color: #bdbdbd;
        opacity: 1;
      }

      .toggle-ink {
        position: absolute;
        top: -14px;
        left: -14px;
        right: auto;
        bottom: auto;
        width: 48px;
        height: 48px;
        opacity: 0.5;
        pointer-events: none;
        color: var(--paper-toggle-button-unchecked-ink-color, --primary-text-color);
      }

      :host([checked]) .toggle-ink {
        color: var(--paper-toggle-button-checked-ink-color, --primary-color);
      }

      .toggle-container {
        display: inline-block;
        position: relative;
        width: 36px;
        height: 14px;
        /* The toggle button has an absolute position of -3px; The extra 1px
        /* accounts for the toggle button shadow box. */
        margin: 4px 1px;
      }

      .toggle-label {
        position: relative;
        display: inline-block;
        vertical-align: middle;
        padding-left: var(--paper-toggle-button-label-spacing, 8px);
        pointer-events: none;
        color: var(--paper-toggle-button-label-color, --primary-text-color);
      }
    </style>

    <div class="toggle-container">
      <div id="toggleBar" class="toggle-bar"></div>
      <div id="toggleButton" class="toggle-button"></div>
    </div>

    <div class="toggle-label"><content></content></div>

  </template>

  <script>
    Polymer({
      is: 'paper-toggle-button',

      behaviors: [
        Polymer.PaperCheckedElementBehavior
      ],

      hostAttributes: {
        role: 'button',
        'aria-pressed': 'false',
        tabindex: 0
      },

      properties: {
        /**
         * Fired when the checked state changes due to user interaction.
         *
         * @event change
         */
        /**
         * Fired when the checked state changes.
         *
         * @event iron-change
         */
      },

      listeners: {
        track: '_ontrack'
      },

      _ontrack: function(event) {
        var track = event.detail;
        if (track.state === 'start') {
          this._trackStart(track);
        } else if (track.state === 'track') {
          this._trackMove(track);
        } else if (track.state === 'end') {
          this._trackEnd(track);
        }
      },

      _trackStart: function(track) {
        this._width = this.$.toggleBar.offsetWidth / 2;
        /*
         * keep an track-only check state to keep the dragging behavior smooth
         * while toggling activations
         */
        this._trackChecked = this.checked;
        this.$.toggleButton.classList.add('dragging');
      },

      _trackMove: function(track) {
        var dx = track.dx;
        this._x = Math.min(this._width,
            Math.max(0, this._trackChecked ? this._width + dx : dx));
        this.translate3d(this._x + 'px', 0, 0, this.$.toggleButton);
        this._userActivate(this._x > (this._width / 2));
      },

      _trackEnd: function(track) {
        this.$.toggleButton.classList.remove('dragging');
        this.transform('', this.$.toggleButton);
      },

      // customize the element's ripple
      _createRipple: function() {
        this._rippleContainer = this.$.toggleButton;
        var ripple = Polymer.PaperRippleBehavior._createRipple();
        ripple.id = 'ink';
        ripple.setAttribute('recenters', '');
        ripple.classList.add('circle', 'toggle-ink');
        return ripple;
      }

    });
  </script>
</dom-module>


<dom-module id="paper-toolbar" assetpath="bower_components/paper-toolbar/">
  <template>
    <style>
      :host {
        /* technical */
        display: block;
        position: relative;
        box-sizing: border-box;
        -moz-box-sizing: border-box;

        /* size */
        height: var(--paper-toolbar-height, 64px);

        background: var(--paper-toolbar-background, --primary-color);
        color: var(--paper-toolbar-color, --dark-theme-text-color);

        @apply(--paper-toolbar);
      }

      :host(.animate) {
        /* transition */
        transition: var(--paper-toolbar-transition, height 0.18s ease-in);
      }

      :host(.medium-tall) {
        height: calc(var(--paper-toolbar-height, 64px) * 2);
        @apply(--paper-toolbar-medium);
      }

      :host(.tall) {
        height: calc(var(--paper-toolbar-height, 64px) * 3);
        @apply(--paper-toolbar-tall);
      }

      .toolbar-tools {
        position: relative;
        height: var(--paper-toolbar-height, 64px);
        padding: 0 16px;
        pointer-events: none;
        @apply(--layout-horizontal);
        @apply(--layout-center);
        @apply(--paper-toolbar-content);
      }

      /*
       * TODO: Where should media query breakpoints live so they can be shared between elements?
       */

      @media (max-width: 600px) {
        :host {
          height: var(--paper-toolbar-sm-height, 56px);
        }

        :host(.medium-tall) {
          height: calc(var(--paper-toolbar-sm-height, 56px) * 2);
        }

        :host(.tall) {
          height: calc(var(--paper-toolbar-sm-height, 56px) * 3);
        }

        .toolbar-tools {
          height: var(--paper-toolbar-sm-height, 56px);
        }
      }

      #topBar {
        position: relative;
      }

      /* middle bar */
      #middleBar {
        position: absolute;
        top: 0;
        right: 0;
        left: 0;
      }

      :host(.tall) #middleBar,
      :host(.medium-tall) #middleBar {
        -webkit-transform: translateY(100%);
        transform: translateY(100%);
      }

      /* bottom bar */
      #bottomBar {
        position: absolute;
        right: 0;
        bottom: 0;
        left: 0;
      }

      /*
       * make elements (e.g. buttons) respond to mouse/touch events
       *
       * `.toolbar-tools` disables touch events so multiple toolbars can stack and not
       * absorb events. All children must have pointer events re-enabled to work as
       * expected.
       */
      .toolbar-tools > ::content > *:not([disabled]) {
        pointer-events: auto;
      }

      .toolbar-tools > ::content .title {
        @apply(--paper-font-common-base);

        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        font-size: 20px;
        font-weight: 400;
        line-height: 1;
        pointer-events: none;

        @apply(--layout-flex);
        @apply(--paper-toolbar-title);
      }

      /**
       * TODO: Refactor these selectors
       * Work in progress.
       */
      .toolbar-tools > ::content paper-icon-button[icon=menu] {
        margin-right: 24px;
      }

      .toolbar-tools > ::content > .title,
      .toolbar-tools > ::content[select=".middle"] > .title,
      .toolbar-tools > ::content[select=".bottom"] > .title {
        margin-left: 56px;
      }

      .toolbar-tools > ::content > paper-icon-button + .title,
      .toolbar-tools > ::content[select=".middle"] paper-icon-button + .title,
      .toolbar-tools > ::content[select=".bottom"] paper-icon-button + .title {
        margin-left: 0;
      }

      .toolbar-tools > ::content > .fit {
        position: absolute;
        top: auto;
        right: 0;
        bottom: 0;
        left: 0;
        width: auto;
        margin: 0;
      }

      /* TODO(noms): Until we have a better solution for classes that don't use
       * /deep/ create our own.
       */
      .start-justified {
        @apply(--layout-start-justified);
      }

      .center-justified {
        @apply(--layout-center-justified);
      }

      .end-justified {
        @apply(--layout-end-justified);
      }

      .around-justified {
        @apply(--layout-around-justified);
      }

      .justified {
        @apply(--layout-justified);
      }
    </style>

    <div id="topBar" class$="toolbar-tools [[_computeBarExtraClasses(justify)]]">
      <content select=":not(.middle):not(.bottom)"></content>
    </div>

    <div id="middleBar" class$="toolbar-tools [[_computeBarExtraClasses(middleJustify)]]">
      <content select=".middle"></content>
    </div>

    <div id="bottomBar" class$="toolbar-tools [[_computeBarExtraClasses(bottomJustify)]]">
      <content select=".bottom"></content>
    </div>
  </template>

  <script>
    Polymer({
      is: 'paper-toolbar',

      hostAttributes: {
        'role': 'toolbar'
      },

      properties: {
        /**
         * Controls how the items are aligned horizontally when they are placed
         * at the bottom.
         * Options are `start`, `center`, `end`, `justified` and `around`.
         */
        bottomJustify: {
          type: String,
          value: ''
        },

        /**
         * Controls how the items are aligned horizontally.
         * Options are `start`, `center`, `end`, `justified` and `around`.
         */
        justify: {
          type: String,
          value: ''
        },

        /**
         * Controls how the items are aligned horizontally when they are placed
         * in the middle.
         * Options are `start`, `center`, `end`, `justified` and `around`.
         */
        middleJustify: {
          type: String,
          value: ''
        }

      },

      attached: function() {
        this._observer = this._observe(this);
        this._updateAriaLabelledBy();
      },

      detached: function() {
        if (this._observer) {
          this._observer.disconnect();
        }
      },

      _observe: function(node) {
        var observer = new MutationObserver(function() {
          this._updateAriaLabelledBy();
        }.bind(this));
        observer.observe(node, {
          childList: true,
          subtree: true
        });
        return observer;
      },

      _updateAriaLabelledBy: function() {
        var labelledBy = [];
        var contents = Polymer.dom(this.root).querySelectorAll('content');
        for (var content, index = 0; content = contents[index]; index++) {
          var nodes = Polymer.dom(content).getDistributedNodes();
          for (var node, jndex = 0; node = nodes[jndex]; jndex++) {
            if (node.classList && node.classList.contains('title')) {
              if (node.id) {
                labelledBy.push(node.id);
              } else {
                var id = 'paper-toolbar-label-' + Math.floor(Math.random() * 10000);
                node.id = id;
                labelledBy.push(id);
              }
            }
          }
        }
        if (labelledBy.length > 0) {
          this.setAttribute('aria-labelledby', labelledBy.join(' '));
        }
      },

      _computeBarExtraClasses: function(barJustify) {
        if (!barJustify) return '';

        return barJustify + (barJustify === 'justified' ? '' : '-justified');
      }
    });
  </script>
</dom-module>
<script>

/*
`iron-a11y-keys` provides a cross-browser interface for processing 
keyboard commands. The interface adheres to [WAI-ARIA best 
practices](http://www.w3.org/TR/wai-aria-practices/#kbd_general_binding). 
It uses an expressive syntax to filter key presses.

## Basic usage

The sample code below is a portion of a custom element. The goal is to call
the `onEnter` method whenever the `paper-input` element is in focus and 
the `Enter` key is pressed.

    <iron-a11y-keys id="a11y" target="[[target]]" keys="enter"
                        on-keys-pressed="onEnter"></iron-a11y-keys>
    <paper-input id="input"
                 placeholder="Type something. Press enter. Check console."
                 value="{{userInput::input}}"></paper-input>

The custom element declares an `iron-a11y-keys` element that is bound to a 
property called `target`. The `target` property
needs to evaluate to the `paper-input` node. `iron-a11y-keys` registers 
an event handler for the target node using Polymer's [annotated event handler
syntax](https://www.polymer-project.org/1.0/docs/devguide/events.html#annotated-listeners). `{{userInput::input}}` sets the `userInput` property to the 
user's input on each keystroke. 

The last step is to link the two elements within the custom element's 
registration.

    ...
    properties: {
      userInput: {
        type: String,
        notify: true,
      },
      target: {
        type: Object,
        value: function() {
          return this.$.input;
        }
      },
    },
    onEnter: function() {
      console.log(this.userInput);
    }
    ...

## The `keys` attribute

The `keys` attribute expresses what combination of keys triggers the event.

The attribute accepts a space-separated, plus-sign-concatenated 
set of modifier keys and some common keyboard keys.

The common keys are: `a-z`, `0-9` (top row and number pad), `*` (shift 8 and 
number pad), `F1-F12`, `Page Up`, `Page Down`, `Left Arrow`, `Right Arrow`,
`Down Arrow`, `Up Arrow`, `Home`, `End`, `Escape`, `Space`, `Tab`, `Enter`.

The modifier keys are: `Shift`, `Control`, `Alt`.

All keys are expected to be lowercase and shortened. E.g.
`Left Arrow` is `left`, `Page Down` is `pagedown`, `Control` is `ctrl`, 
`F1` is `f1`, `Escape` is `esc`, etc.

### Grammar

Below is the [EBNF](http://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form) 
Grammar of the `keys` attribute.

    modifier = "shift" | "ctrl" | "alt";
    ascii = ? /[a-z0-9]/ ? ;
    fnkey = ? f1 through f12 ? ;
    arrow = "up" | "down" | "left" | "right" ;
    key = "tab" | "esc" | "space" | "*" | "pageup" | "pagedown" | 
          "home" | "end" | arrow | ascii | fnkey;
    keycombo = { modifier, "+" }, key ;
    keys = keycombo, { " ", keycombo } ;

### Example

Given the following value for `keys`: 

`ctrl+shift+f7 up pagedown esc space alt+m`

The event is fired if any of the following key combinations are fired: 
`Control` and `Shift` and `F7` keys, `Up Arrow` key, `Page Down` key, 
`Escape` key, `Space` key, `Alt` and `M` keys.

### WAI-ARIA Slider Example

The following is an example of the set of keys that fulfills WAI-ARIA's 
"slider" role [best
practices](http://www.w3.org/TR/wai-aria-practices/#slider):

    <iron-a11y-keys target="[[target]]" keys="left pagedown down" 
                    on-keys-pressed="decrement"></iron-a11y-keys>
    <iron-a11y-keys target=""[[target]] keys="right pageup up" 
                    on-keys-pressed="increment"></iron-a11y-keys>
    <iron-a11y-keys target="[[target]]" keys="home" 
                    on-keys-pressed="setMin"></iron-a11y-keys>
    <iron-a11y-keys target=""[[target]] keys="end" 
                    on-keys-pressed="setMax"></iron-a11y-keys>

The `target` properties must evaluate to a node. See the basic usage 
example above.

Each of the values for the `on-keys-pressed` attributes must evalute
to methods. The `increment` method should move the slider a set amount 
toward the maximum value. `decrement` should move the slider a set amount 
toward the minimum value. `setMin` should move the slider to the minimum 
value. `setMax` should move the slider to the maximum value.

@demo demo/index.html
*/


  Polymer({
    is: 'iron-a11y-keys',

    behaviors: [
      Polymer.IronA11yKeysBehavior
    ],

    properties: {
      /** @type {?Node} */
      target: {
        type: Object,
        observer: '_targetChanged'
      },

      keys: {
        type: String,
        reflectToAttribute: true,
        observer: '_keysChanged'
      }
    },

    attached: function() {
      if (!this.target) {
        this.target = this.parentNode;
      }
    },

    _targetChanged: function(target) {
      this.keyEventTarget = target;
    },

    _keysChanged: function() {
      this.removeOwnKeyBindings();
      this.addOwnKeyBinding(this.keys, '_fireKeysPressed');
    },

    _fireKeysPressed: function(event) {
      this.fire('keys-pressed', event.detail, {});
    }
  });
</script>


<dom-module id="iron-a11y-announcer" assetpath="bower_components/iron-a11y-announcer/">
  <style>
    :host {
      display: inline-block;
      position: fixed;
      clip: rect(0px,0px,0px,0px);
    }
  </style>

  <template>
    <div aria-live$="[[mode]]">[[_text]]</div>
  </template>

  <script>

    (function() {
      'use strict';

      Polymer.IronA11yAnnouncer = Polymer({
        is: 'iron-a11y-announcer',

        properties: {

          /**
           * The value of mode is used to set the `aria-live` attribute
           * for the element that will be announced. Valid values are: `off`,
           * `polite` and `assertive`.
           */
          mode: {
            type: String,
            value: 'polite'
          },

          _text: {
            type: String,
            value: ''
          }
        },

        created: function() {
          if (!Polymer.IronA11yAnnouncer.instance) {
            Polymer.IronA11yAnnouncer.instance = this;
          }

          document.body.addEventListener('iron-announce', this._onIronAnnounce.bind(this));
        },

        /**
         * Cause a text string to be announced by screen readers.
         *
         * @param {string} text The text that should be announced.
         */
        announce: function(text) {
          this._text = '';
          this.async(function() {
            this._text = text;
          }, 100);
        },

        _onIronAnnounce: function(event) {
          if (event.detail && event.detail.text) {
            this.announce(event.detail.text);
          }
        }
      });

      Polymer.IronA11yAnnouncer.instance = null;

      Polymer.IronA11yAnnouncer.requestAvailability = function() {
        if (!Polymer.IronA11yAnnouncer.instance) {
          Polymer.IronA11yAnnouncer.instance = document.createElement('iron-a11y-announcer');
        }

        document.body.appendChild(Polymer.IronA11yAnnouncer.instance);
      };
    })();

  </script>
</dom-module>
<script>

/**
Polymer.IronFitBehavior fits an element in another element using `max-height` and `max-width`, and
optionally centers it in the window or another element.

The element will only be sized and/or positioned if it has not already been sized and/or positioned
by CSS.

CSS properties               | Action
-----------------------------|-------------------------------------------
`position` set               | Element is not centered horizontally or vertically
`top` or `bottom` set        | Element is not vertically centered
`left` or `right` set        | Element is not horizontally centered
`max-height` or `height` set | Element respects `max-height` or `height`
`max-width` or `width` set   | Element respects `max-width` or `width`

@demo demo/index.html
@polymerBehavior
*/

  Polymer.IronFitBehavior = {

    properties: {

      /**
       * The element that will receive a `max-height`/`width`. By default it is the same as `this`,
       * but it can be set to a child element. This is useful, for example, for implementing a
       * scrolling region inside the element.
       * @type {!Element}
       */
      sizingTarget: {
        type: Object,
        value: function() {
          return this;
        }
      },

      /**
       * The element to fit `this` into.
       */
      fitInto: {
        type: Object,
        value: window
      },

      /**
       * Set to true to auto-fit on attach.
       */
      autoFitOnAttach: {
        type: Boolean,
        value: false
      },

      /** @type {?Object} */
      _fitInfo: {
        type: Object
      }

    },

    get _fitWidth() {
      var fitWidth;
      if (this.fitInto === window) {
        fitWidth = this.fitInto.innerWidth;
      } else {
        fitWidth = this.fitInto.getBoundingClientRect().width;
      }
      return fitWidth;
    },

    get _fitHeight() {
      var fitHeight;
      if (this.fitInto === window) {
        fitHeight = this.fitInto.innerHeight;
      } else {
        fitHeight = this.fitInto.getBoundingClientRect().height;
      }
      return fitHeight;
    },

    get _fitLeft() {
      var fitLeft;
      if (this.fitInto === window) {
        fitLeft = 0;
      } else {
        fitLeft = this.fitInto.getBoundingClientRect().left;
      }
      return fitLeft;
    },

    get _fitTop() {
      var fitTop;
      if (this.fitInto === window) {
        fitTop = 0;
      } else {
        fitTop = this.fitInto.getBoundingClientRect().top;
      }
      return fitTop;
    },

    attached: function() {
      if (this.autoFitOnAttach) {
        if (window.getComputedStyle(this).display === 'none') {
          setTimeout(function() {
            this.fit();
          }.bind(this));
        } else {
          this.fit();
        }
      }
    },

    /**
     * Fits and optionally centers the element into the window, or `fitInfo` if specified.
     */
    fit: function() {
      this._discoverInfo();
      this.constrain();
      this.center();
    },

    /**
     * Memoize information needed to position and size the target element.
     */
    _discoverInfo: function() {
      if (this._fitInfo) {
        return;
      }
      var target = window.getComputedStyle(this);
      var sizer = window.getComputedStyle(this.sizingTarget);
      this._fitInfo = {
        inlineStyle: {
          top: this.style.top || '',
          left: this.style.left || ''
        },
        positionedBy: {
          vertically: target.top !== 'auto' ? 'top' : (target.bottom !== 'auto' ?
            'bottom' : null),
          horizontally: target.left !== 'auto' ? 'left' : (target.right !== 'auto' ?
            'right' : null),
          css: target.position
        },
        sizedBy: {
          height: sizer.maxHeight !== 'none',
          width: sizer.maxWidth !== 'none'
        },
        margin: {
          top: parseInt(target.marginTop, 10) || 0,
          right: parseInt(target.marginRight, 10) || 0,
          bottom: parseInt(target.marginBottom, 10) || 0,
          left: parseInt(target.marginLeft, 10) || 0
        }
      };
    },

    /**
     * Resets the target element's position and size constraints, and clear
     * the memoized data.
     */
    resetFit: function() {
      if (!this._fitInfo || !this._fitInfo.sizedBy.width) {
        this.sizingTarget.style.maxWidth = '';
      }
      if (!this._fitInfo || !this._fitInfo.sizedBy.height) {
        this.sizingTarget.style.maxHeight = '';
      }
      this.style.top = this._fitInfo ? this._fitInfo.inlineStyle.top : '';
      this.style.left = this._fitInfo ? this._fitInfo.inlineStyle.left : '';
      if (this._fitInfo) {
        this.style.position = this._fitInfo.positionedBy.css;
      }
      this._fitInfo = null;
    },

    /**
     * Equivalent to calling `resetFit()` and `fit()`. Useful to call this after the element,
     * the window, or the `fitInfo` element has been resized.
     */
    refit: function() {
      this.resetFit();
      this.fit();
    },

    /**
     * Constrains the size of the element to the window or `fitInfo` by setting `max-height`
     * and/or `max-width`.
     */
    constrain: function() {
      var info = this._fitInfo;
      // position at (0px, 0px) if not already positioned, so we can measure the natural size.
      if (!this._fitInfo.positionedBy.vertically) {
        this.style.top = '0px';
      }
      if (!this._fitInfo.positionedBy.horizontally) {
        this.style.left = '0px';
      }
      if (!this._fitInfo.positionedBy.vertically || !this._fitInfo.positionedBy.horizontally) {
        // need position:fixed to properly size the element
        this.style.position = 'fixed';
      }
      // need border-box for margin/padding
      this.sizingTarget.style.boxSizing = 'border-box';
      // constrain the width and height if not already set
      var rect = this.getBoundingClientRect();
      if (!info.sizedBy.height) {
        this._sizeDimension(rect, info.positionedBy.vertically, 'top', 'bottom', 'Height');
      }
      if (!info.sizedBy.width) {
        this._sizeDimension(rect, info.positionedBy.horizontally, 'left', 'right', 'Width');
      }
    },

    _sizeDimension: function(rect, positionedBy, start, end, extent) {
      var info = this._fitInfo;
      var max = extent === 'Width' ? this._fitWidth : this._fitHeight;
      var flip = (positionedBy === end);
      var offset = flip ? max - rect[end] : rect[start];
      var margin = info.margin[flip ? start : end];
      var offsetExtent = 'offset' + extent;
      var sizingOffset = this[offsetExtent] - this.sizingTarget[offsetExtent];
      this.sizingTarget.style['max' + extent] = (max - margin - offset - sizingOffset) + 'px';
    },

    /**
     * Centers horizontally and vertically if not already positioned. This also sets
     * `position:fixed`.
     */
    center: function() {
      var positionedBy = this._fitInfo.positionedBy;
      if (positionedBy.vertically && positionedBy.horizontally) {
        // Already positioned.
        return;
      }
      // Need position:fixed to center
      this.style.position = 'fixed';
      // Take into account the offset caused by parents that create stacking
      // contexts (e.g. with transform: translate3d). Translate to 0,0 and
      // measure the bounding rect.
      if (!positionedBy.vertically) {
        this.style.top = '0px';
      }
      if (!positionedBy.horizontally) {
        this.style.left = '0px';
      }
      // It will take in consideration margins and transforms
      var rect = this.getBoundingClientRect();
      if (!positionedBy.vertically) {
        var top = this._fitTop - rect.top + (this._fitHeight - rect.height) / 2;
        this.style.top = top + 'px';
      }
      if (!positionedBy.horizontally) {
        var left = this._fitLeft - rect.left + (this._fitWidth - rect.width) / 2;
        this.style.left = left + 'px';
      }
    }

  };

</script>
<script>
  /**
   * `IronResizableBehavior` is a behavior that can be used in Polymer elements to
   * coordinate the flow of resize events between "resizers" (elements that control the
   * size or hidden state of their children) and "resizables" (elements that need to be
   * notified when they are resized or un-hidden by their parents in order to take
   * action on their new measurements).
   * 
   * Elements that perform measurement should add the `IronResizableBehavior` behavior to
   * their element definition and listen for the `iron-resize` event on themselves.
   * This event will be fired when they become showing after having been hidden,
   * when they are resized explicitly by another resizable, or when the window has been
   * resized.
   * 
   * Note, the `iron-resize` event is non-bubbling.
   *
   * @polymerBehavior Polymer.IronResizableBehavior
   * @demo demo/index.html
   **/
  Polymer.IronResizableBehavior = {
    properties: {
      /**
       * The closest ancestor element that implements `IronResizableBehavior`.
       */
      _parentResizable: {
        type: Object,
        observer: '_parentResizableChanged'
      },

      /**
       * True if this element is currently notifying its descedant elements of
       * resize.
       */
      _notifyingDescendant: {
        type: Boolean,
        value: false
      }
    },

    listeners: {
      'iron-request-resize-notifications': '_onIronRequestResizeNotifications'
    },

    created: function() {
      // We don't really need property effects on these, and also we want them
      // to be created before the `_parentResizable` observer fires:
      this._interestedResizables = [];
      this._boundNotifyResize = this.notifyResize.bind(this);
    },

    attached: function() {
      this.fire('iron-request-resize-notifications', null, {
        node: this,
        bubbles: true,
        cancelable: true
      });

      if (!this._parentResizable) {
        window.addEventListener('resize', this._boundNotifyResize);
        this.notifyResize();
      }
    },

    detached: function() {
      if (this._parentResizable) {
        this._parentResizable.stopResizeNotificationsFor(this);
      } else {
        window.removeEventListener('resize', this._boundNotifyResize);
      }

      this._parentResizable = null;
    },

    /**
     * Can be called to manually notify a resizable and its descendant
     * resizables of a resize change.
     */
    notifyResize: function() {
      if (!this.isAttached) {
        return;
      }

      this._interestedResizables.forEach(function(resizable) {
        if (this.resizerShouldNotify(resizable)) {
          this._notifyDescendant(resizable);
        }
      }, this);

      this._fireResize();
    },

    /**
     * Used to assign the closest resizable ancestor to this resizable
     * if the ancestor detects a request for notifications.
     */
    assignParentResizable: function(parentResizable) {
      this._parentResizable = parentResizable;
    },

    /**
     * Used to remove a resizable descendant from the list of descendants
     * that should be notified of a resize change.
     */
    stopResizeNotificationsFor: function(target) {
      var index = this._interestedResizables.indexOf(target);

      if (index > -1) {
        this._interestedResizables.splice(index, 1);
        this.unlisten(target, 'iron-resize', '_onDescendantIronResize');
      }
    },

    /**
     * This method can be overridden to filter nested elements that should or
     * should not be notified by the current element. Return true if an element
     * should be notified, or false if it should not be notified.
     *
     * @param {HTMLElement} element A candidate descendant element that
     * implements `IronResizableBehavior`.
     * @return {boolean} True if the `element` should be notified of resize.
     */
    resizerShouldNotify: function(element) { return true; },

    _onDescendantIronResize: function(event) {
      if (this._notifyingDescendant) {
        event.stopPropagation();
        return;
      }

      // NOTE(cdata): In ShadowDOM, event retargetting makes echoing of the
      // otherwise non-bubbling event "just work." We do it manually here for
      // the case where Polymer is not using shadow roots for whatever reason:
      if (!Polymer.Settings.useShadow) {
        this._fireResize();
      }
    },

    _fireResize: function() {
      this.fire('iron-resize', null, {
        node: this,
        bubbles: false
      });
    },

    _onIronRequestResizeNotifications: function(event) {
      var target = event.path ? event.path[0] : event.target;

      if (target === this) {
        return;
      }

      if (this._interestedResizables.indexOf(target) === -1) {
        this._interestedResizables.push(target);
        this.listen(target, 'iron-resize', '_onDescendantIronResize');
      }

      target.assignParentResizable(this);
      this._notifyDescendant(target);

      event.stopPropagation();
    },

    _parentResizableChanged: function(parentResizable) {
      if (parentResizable) {
        window.removeEventListener('resize', this._boundNotifyResize);
      }
    },

    _notifyDescendant: function(descendant) {
      // NOTE(cdata): In IE10, attached is fired on children first, so it's
      // important not to notify them if the parent is not attached yet (or
      // else they will get redundantly notified when the parent attaches).
      if (!this.isAttached) {
        return;
      }

      this._notifyingDescendant = true;
      descendant.notifyResize();
      this._notifyingDescendant = false;
    }
  };
</script>

<script>

  /**
   * @struct
   * @constructor
   * @private
   */
  Polymer.IronOverlayManagerClass = function() {
    /**
     * Used to keep track of the opened overlays.
     * @private {Array<Element>}
     */
    this._overlays = [];

    /**
     * iframes have a default z-index of 100,
     * so this default should be at least that.
     * @private {number}
     */
    this._minimumZ = 101;

    /**
     * Memoized backdrop element.
     * @private {Element|null}
     */
    this._backdropElement = null;

    // Listen to mousedown or touchstart to be sure to be the first to capture
    // clicks outside the overlay.
    var clickEvent = ('ontouchstart' in window) ? 'touchstart' : 'mousedown';
    document.addEventListener(clickEvent, this._onCaptureClick.bind(this), true);
    document.addEventListener('focus', this._onCaptureFocus.bind(this), true);
    document.addEventListener('keydown', this._onCaptureKeyDown.bind(this), true);
  };

  Polymer.IronOverlayManagerClass.prototype = {

    constructor: Polymer.IronOverlayManagerClass,

    /**
     * The shared backdrop element.
     * @type {Element} backdropElement
     */
    get backdropElement() {
      if (!this._backdropElement) {
        this._backdropElement = document.createElement('iron-overlay-backdrop');
      }
      return this._backdropElement;
    },

    /**
     * The deepest active element.
     * @type {Element} activeElement the active element
     */
    get deepActiveElement() {
      // document.activeElement can be null
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement
      // In case of null, default it to document.body.
      var active = document.activeElement || document.body;
      while (active.root && Polymer.dom(active.root).activeElement) {
        active = Polymer.dom(active.root).activeElement;
      }
      return active;
    },

    /**
     * Brings the overlay at the specified index to the front.
     * @param {number} i
     * @private
     */
    _bringOverlayAtIndexToFront: function(i) {
      var overlay = this._overlays[i];
      var lastI = this._overlays.length - 1;
      // Ensure always-on-top overlay stays on top.
      if (!overlay.alwaysOnTop && this._overlays[lastI].alwaysOnTop) {
        lastI--;
      }
      // If already the top element, return.
      if (!overlay || i >= lastI) {
        return;
      }
      // Update z-index to be on top.
      var minimumZ = Math.max(this.currentOverlayZ(), this._minimumZ);
      if (this._getZ(overlay) <= minimumZ) {
        this._applyOverlayZ(overlay, minimumZ);
      }

      // Shift other overlays behind the new on top.
      while (i < lastI) {
        this._overlays[i] = this._overlays[i + 1];
        i++;
      }
      this._overlays[lastI] = overlay;
    },

    /**
     * Adds the overlay and updates its z-index if it's opened, or removes it if it's closed.
     * Also updates the backdrop z-index.
     * @param {Element} overlay
     */
    addOrRemoveOverlay: function(overlay) {
      if (overlay.opened) {
        this.addOverlay(overlay);
      } else {
        this.removeOverlay(overlay);
      }
      this.trackBackdrop();
    },

    /**
     * Tracks overlays for z-index and focus management.
     * Ensures the last added overlay with always-on-top remains on top.
     * @param {Element} overlay
     */
    addOverlay: function(overlay) {
      var i = this._overlays.indexOf(overlay);
      if (i >= 0) {
        this._bringOverlayAtIndexToFront(i);
        return;
      }
      var insertionIndex = this._overlays.length;
      var currentOverlay = this._overlays[insertionIndex - 1];
      var minimumZ = Math.max(this._getZ(currentOverlay), this._minimumZ);
      var newZ = this._getZ(overlay);

      // Ensure always-on-top overlay stays on top.
      if (currentOverlay && currentOverlay.alwaysOnTop && !overlay.alwaysOnTop) {
        // This bumps the z-index of +2.
        this._applyOverlayZ(currentOverlay, minimumZ);
        insertionIndex--;
        // Update minimumZ to match previous overlay's z-index.
        var previousOverlay = this._overlays[insertionIndex - 1];
        minimumZ = Math.max(this._getZ(previousOverlay), this._minimumZ);
      }

      // Update z-index and insert overlay.
      if (newZ <= minimumZ) {
        this._applyOverlayZ(overlay, minimumZ);
      }
      this._overlays.splice(insertionIndex, 0, overlay);

      // Get focused node.
      var element = this.deepActiveElement;
      overlay.restoreFocusNode = this._overlayParent(element) ? null : element;
    },

    /**
     * @param {Element} overlay
     */
    removeOverlay: function(overlay) {
      var i = this._overlays.indexOf(overlay);
      if (i === -1) {
        return;
      }
      this._overlays.splice(i, 1);

      var node = overlay.restoreFocusOnClose ? overlay.restoreFocusNode : null;
      overlay.restoreFocusNode = null;
      // Focus back only if still contained in document.body
      if (node && Polymer.dom(document.body).deepContains(node)) {
        node.focus();
      }
    },

    /**
     * Returns the current overlay.
     * @return {Element|undefined}
     */
    currentOverlay: function() {
      var i = this._overlays.length - 1;
      return this._overlays[i];
    },

    /**
     * Returns the current overlay z-index.
     * @return {number}
     */
    currentOverlayZ: function() {
      return this._getZ(this.currentOverlay());
    },

    /**
     * Ensures that the minimum z-index of new overlays is at least `minimumZ`.
     * This does not effect the z-index of any existing overlays.
     * @param {number} minimumZ
     */
    ensureMinimumZ: function(minimumZ) {
      this._minimumZ = Math.max(this._minimumZ, minimumZ);
    },

    focusOverlay: function() {
      var current = /** @type {?} */ (this.currentOverlay());
      // We have to be careful to focus the next overlay _after_ any current
      // transitions are complete (due to the state being toggled prior to the
      // transition). Otherwise, we risk infinite recursion when a transitioning
      // (closed) overlay becomes the current overlay.
      //
      // NOTE: We make the assumption that any overlay that completes a transition
      // will call into focusOverlay to kick the process back off. Currently:
      // transitionend -> _applyFocus -> focusOverlay.
      if (current && !current.transitioning) {
        current._applyFocus();
      }
    },

    /**
     * Updates the backdrop z-index.
     */
    trackBackdrop: function() {
      this.backdropElement.style.zIndex = this.backdropZ();
    },

    /**
     * @return {Array<Element>}
     */
    getBackdrops: function() {
      var backdrops = [];
      for (var i = 0; i < this._overlays.length; i++) {
        if (this._overlays[i].withBackdrop) {
          backdrops.push(this._overlays[i]);
        }
      }
      return backdrops;
    },

    /**
     * Returns the z-index for the backdrop.
     * @return {number}
     */
    backdropZ: function() {
      return this._getZ(this._overlayWithBackdrop()) - 1;
    },

    /**
     * Returns the first opened overlay that has a backdrop.
     * @return {Element|undefined}
     * @private
     */
    _overlayWithBackdrop: function() {
      for (var i = 0; i < this._overlays.length; i++) {
        if (this._overlays[i].withBackdrop) {
          return this._overlays[i];
        }
      }
    },

    /**
     * Calculates the minimum z-index for the overlay.
     * @param {Element=} overlay
     * @private
     */
    _getZ: function(overlay) {
      var z = this._minimumZ;
      if (overlay) {
        var z1 = Number(overlay.style.zIndex || window.getComputedStyle(overlay).zIndex);
        // Check if is a number
        // Number.isNaN not supported in IE 10+
        if (z1 === z1) {
          z = z1;
        }
      }
      return z;
    },

    /**
     * @param {Element} element
     * @param {number|string} z
     * @private
     */
    _setZ: function(element, z) {
      element.style.zIndex = z;
    },

    /**
     * @param {Element} overlay
     * @param {number} aboveZ
     * @private
     */
    _applyOverlayZ: function(overlay, aboveZ) {
      this._setZ(overlay, aboveZ + 2);
    },

    /**
     * Returns the overlay containing the provided node. If the node is an overlay,
     * it returns the node.
     * @param {Element=} node
     * @return {Element|undefined}
     * @private
     */
    _overlayParent: function(node) {
      while (node && node !== document.body) {
        // Check if it is an overlay.
        if (node._manager === this) {
          return node;
        }
        // Use logical parentNode, or native ShadowRoot host.
        node = Polymer.dom(node).parentNode || node.host;
      }
    },

    /**
     * Returns the deepest overlay in the path.
     * @param {Array<Element>=} path
     * @return {Element|undefined}
     * @private
     */
    _overlayInPath: function(path) {
      path = path || [];
      for (var i = 0; i < path.length; i++) {
        if (path[i]._manager === this) {
          return path[i];
        }
      }
    },

    /**
     * Ensures the click event is delegated to the right overlay.
     * @param {!Event} event
     * @private
     */
    _onCaptureClick: function(event) {
      var overlay = /** @type {?} */ (this.currentOverlay());
      // Check if clicked outside of top overlay.
      if (overlay && this._overlayInPath(Polymer.dom(event).path) !== overlay) {
        overlay._onCaptureClick(event);
      }
    },

    /**
     * Ensures the focus event is delegated to the right overlay.
     * @param {!Event} event
     * @private
     */
    _onCaptureFocus: function(event) {
      var overlay = /** @type {?} */ (this.currentOverlay());
      if (overlay) {
        overlay._onCaptureFocus(event);
      }
    },

    /**
     * Ensures TAB and ESC keyboard events are delegated to the right overlay.
     * @param {!Event} event
     * @private
     */
    _onCaptureKeyDown: function(event) {
      var overlay = /** @type {?} */ (this.currentOverlay());
      if (overlay) {
        if (Polymer.IronA11yKeysBehavior.keyboardEventMatchesKeys(event, 'esc')) {
          overlay._onCaptureEsc(event);
        } else if (Polymer.IronA11yKeysBehavior.keyboardEventMatchesKeys(event, 'tab')) {
          overlay._onCaptureTab(event);
        }
      }
    }
  };

  Polymer.IronOverlayManager = new Polymer.IronOverlayManagerClass();
</script>


<dom-module id="iron-overlay-backdrop" assetpath="bower_components/iron-overlay-behavior/">

  <style>

    :host {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: var(--iron-overlay-backdrop-background-color, #000);
      opacity: 0;
      transition: opacity 0.2s;
      pointer-events: none;

      @apply(--iron-overlay-backdrop);
    }

    :host([opened]) {
      opacity: var(--iron-overlay-backdrop-opacity, 0.6);
      pointer-events: auto;

      @apply(--iron-overlay-backdrop-opened);
    }

  </style>

  <template>
    <content></content>
  </template>

</dom-module>

<script>

(function() {

  Polymer({

    is: 'iron-overlay-backdrop',

    properties: {

      /**
       * Returns true if the backdrop is opened.
       */
      opened: {
        readOnly: true,
        reflectToAttribute: true,
        type: Boolean,
        value: false
      },

      _manager: {
        type: Object,
        value: Polymer.IronOverlayManager
      }

    },

    listeners: {
      'transitionend' : '_onTransitionend'
    },

    /**
     * Appends the backdrop to document body and sets its `z-index` to be below the latest overlay.
     */
    prepare: function() {
      if (!this.parentNode) {
        Polymer.dom(document.body).appendChild(this);
      }
    },

    /**
     * Shows the backdrop if needed.
     */
    open: function() {
      // only need to make the backdrop visible if this is called by the first overlay with a backdrop
      if (this._manager.getBackdrops().length < 2) {
        this._setOpened(true);
      }
    },

    /**
     * Hides the backdrop if needed.
     */
    close: function() {
      // close only if no element with backdrop is left
      if (this._manager.getBackdrops().length === 0) {
        // Read style before setting opened.
        var cs = getComputedStyle(this);
        var noAnimation = (cs.transitionDuration === '0s' || cs.opacity == 0);
        this._setOpened(false);
        // In case of no animations, complete
        if (noAnimation) {
          this.complete();
        }
      }
    },

    /**
     * Removes the backdrop from document body if needed.
     */
    complete: function() {
      // only remove the backdrop if there are no more overlays with backdrops
      if (this._manager.getBackdrops().length === 0 && this.parentNode) {
        Polymer.dom(this.parentNode).removeChild(this);
      }
    },

    _onTransitionend: function (event) {
      if (event && event.target === this) {
        this.complete();
      }
    }

  });

})();

</script>
<script>
// IIFE to help scripts concatenation.
(function() {
'use strict';

/**
Use `Polymer.IronOverlayBehavior` to implement an element that can be hidden or shown, and displays
on top of other content. It includes an optional backdrop, and can be used to implement a variety
of UI controls including dialogs and drop downs. Multiple overlays may be displayed at once.

### Closing and canceling

A dialog may be hidden by closing or canceling. The difference between close and cancel is user
intent. Closing generally implies that the user acknowledged the content on the overlay. By default,
it will cancel whenever the user taps outside it or presses the escape key. This behavior is
configurable with the `no-cancel-on-esc-key` and the `no-cancel-on-outside-click` properties.
`close()` should be called explicitly by the implementer when the user interacts with a control
in the overlay element. When the dialog is canceled, the overlay fires an 'iron-overlay-canceled'
event. Call `preventDefault` on this event to prevent the overlay from closing.

### Positioning

By default the element is sized and positioned to fit and centered inside the window. You can
position and size it manually using CSS. See `Polymer.IronFitBehavior`.

### Backdrop

Set the `with-backdrop` attribute to display a backdrop behind the overlay. The backdrop is
appended to `<body>` and is of type `<iron-overlay-backdrop>`. See its doc page for styling
options.

### Limitations

The element is styled to appear on top of other content by setting its `z-index` property. You
must ensure no element has a stacking context with a higher `z-index` than its parent stacking
context. You should place this element as a child of `<body>` whenever possible.

@demo demo/index.html
@polymerBehavior Polymer.IronOverlayBehavior
*/

  Polymer.IronOverlayBehaviorImpl = {

    properties: {

      /**
       * True if the overlay is currently displayed.
       */
      opened: {
        observer: '_openedChanged',
        type: Boolean,
        value: false,
        notify: true
      },

      /**
       * True if the overlay was canceled when it was last closed.
       */
      canceled: {
        observer: '_canceledChanged',
        readOnly: true,
        type: Boolean,
        value: false
      },

      /**
       * Set to true to display a backdrop behind the overlay.
       */
      withBackdrop: {
        observer: '_withBackdropChanged',
        type: Boolean
      },

      /**
       * Set to true to disable auto-focusing the overlay or child nodes with
       * the `autofocus` attribute` when the overlay is opened.
       */
      noAutoFocus: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to disable canceling the overlay with the ESC key.
       */
      noCancelOnEscKey: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to disable canceling the overlay by clicking outside it.
       */
      noCancelOnOutsideClick: {
        type: Boolean,
        value: false
      },

      /**
       * Returns the reason this dialog was last closed.
       */
      closingReason: {
        // was a getter before, but needs to be a property so other
        // behaviors can override this.
        type: Object
      },

      /**
       * Set to true to enable restoring of focus when overlay is closed.
       */
      restoreFocusOnClose: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to keep overlay always on top.
       */
      alwaysOnTop: {
        type: Boolean
      },

      /**
       * Shortcut to access to the overlay manager.
       * @private
       * @type {Polymer.IronOverlayManagerClass}
       */
      _manager: {
        type: Object,
        value: Polymer.IronOverlayManager
      },

      /**
       * The node being focused.
       * @type {?Node}
       */
      _focusedChild: {
        type: Object
      }

    },

    listeners: {
      'iron-resize': '_onIronResize'
    },

    /**
     * The backdrop element.
     * @type {Element}
     */
    get backdropElement() {
      return this._manager.backdropElement;
    },

    /**
     * Returns the node to give focus to.
     * @type {Node}
     */
    get _focusNode() {
      return this._focusedChild || Polymer.dom(this).querySelector('[autofocus]') || this;
    },

    /**
     * Array of nodes that can receive focus (overlay included), ordered by `tabindex`.
     * This is used to retrieve which is the first and last focusable nodes in order
     * to wrap the focus for overlays `with-backdrop`.
     *
     * If you know what is your content (specifically the first and last focusable children),
     * you can override this method to return only `[firstFocusable, lastFocusable];`
     * @type {Array<Node>}
     * @protected
     */
    get _focusableNodes() {
      // Elements that can be focused even if they have [disabled] attribute.
      var FOCUSABLE_WITH_DISABLED = [
        'a[href]',
        'area[href]',
        'iframe',
        '[tabindex]',
        '[contentEditable=true]'
      ];

      // Elements that cannot be focused if they have [disabled] attribute.
      var FOCUSABLE_WITHOUT_DISABLED = [
        'input',
        'select',
        'textarea',
        'button'
      ];

      // Discard elements with tabindex=-1 (makes them not focusable).
      var selector = FOCUSABLE_WITH_DISABLED.join(':not([tabindex="-1"]),') +
        ':not([tabindex="-1"]),' +
        FOCUSABLE_WITHOUT_DISABLED.join(':not([disabled]):not([tabindex="-1"]),') +
        ':not([disabled]):not([tabindex="-1"])';

      var focusables = Polymer.dom(this).querySelectorAll(selector);
      if (this.tabIndex >= 0) {
        // Insert at the beginning because we might have all elements with tabIndex = 0,
        // and the overlay should be the first of the list.
        focusables.splice(0, 0, this);
      }
      // Sort by tabindex.
      return focusables.sort(function (a, b) {
        if (a.tabIndex === b.tabIndex) {
          return 0;
        }
        if (a.tabIndex === 0 || a.tabIndex > b.tabIndex) {
          return 1;
        }
        return -1;
      });
    },

    ready: function() {
      // Used to skip calls to notifyResize and refit while the overlay is animating.
      this.__isAnimating = false;
      // with-backdrop needs tabindex to be set in order to trap the focus.
      // If it is not set, IronOverlayBehavior will set it, and remove it if with-backdrop = false.
      this.__shouldRemoveTabIndex = false;
      // Used for wrapping the focus on TAB / Shift+TAB.
      this.__firstFocusableNode = this.__lastFocusableNode = null;
      // Used for requestAnimationFrame when opened changes.
      this.__openChangedAsync = null;
      // Used for requestAnimationFrame when iron-resize is fired.
      this.__onIronResizeAsync = null;
      this._ensureSetup();
    },

    attached: function() {
      // Call _openedChanged here so that position can be computed correctly.
      if (this.opened) {
        this._openedChanged();
      }
      this._observer = Polymer.dom(this).observeNodes(this._onNodesChange);
    },

    detached: function() {
      Polymer.dom(this).unobserveNodes(this._observer);
      this._observer = null;
      this.opened = false;
      if (this.withBackdrop) {
        // Allow user interactions right away.
        this.backdropElement.close();
      }
    },

    /**
     * Toggle the opened state of the overlay.
     */
    toggle: function() {
      this._setCanceled(false);
      this.opened = !this.opened;
    },

    /**
     * Open the overlay.
     */
    open: function() {
      this._setCanceled(false);
      this.opened = true;
    },

    /**
     * Close the overlay.
     */
    close: function() {
      this._setCanceled(false);
      this.opened = false;
    },

    /**
     * Cancels the overlay.
     * @param {Event=} event The original event
     */
    cancel: function(event) {
      var cancelEvent = this.fire('iron-overlay-canceled', event, {cancelable: true});
      if (cancelEvent.defaultPrevented) {
        return;
      }

      this._setCanceled(true);
      this.opened = false;
    },

    _ensureSetup: function() {
      if (this._overlaySetup) {
        return;
      }
      this._overlaySetup = true;
      this.style.outline = 'none';
      this.style.display = 'none';
    },

    _openedChanged: function() {
      if (this.opened) {
        this.removeAttribute('aria-hidden');
      } else {
        this.setAttribute('aria-hidden', 'true');
      }

      // wait to call after ready only if we're initially open
      if (!this._overlaySetup) {
        return;
      }

      this._manager.addOrRemoveOverlay(this);

      this.__isAnimating = true;

      // requestAnimationFrame for non-blocking rendering
      if (this.__openChangedAsync) {
        cancelAnimationFrame(this.__openChangedAsync);
      }
      if (this.opened) {
        if (this.withBackdrop) {
          this.backdropElement.prepare();
        }
        this.__openChangedAsync = requestAnimationFrame(function() {
          this.__openChangedAsync = null;
          this._prepareRenderOpened();
          this._renderOpened();
        }.bind(this));
      } else {
        this._renderClosed();
      }
    },

    _canceledChanged: function() {
      this.closingReason = this.closingReason || {};
      this.closingReason.canceled = this.canceled;
    },

    _withBackdropChanged: function() {
      // If tabindex is already set, no need to override it.
      if (this.withBackdrop && !this.hasAttribute('tabindex')) {
        this.setAttribute('tabindex', '-1');
        this.__shouldRemoveTabIndex = true;
      } else if (this.__shouldRemoveTabIndex) {
        this.removeAttribute('tabindex');
        this.__shouldRemoveTabIndex = false;
      }
      if (this.opened) {
        this._manager.trackBackdrop();
        if (this.withBackdrop) {
          this.backdropElement.prepare();
          // Give time to be added to document.
          this.async(function(){
            this.backdropElement.open();
          }, 1);
        } else {
          this.backdropElement.close();
        }
      }
    },

    /**
     * tasks which must occur before opening; e.g. making the element visible.
     * @protected
     */
    _prepareRenderOpened: function() {

      // Needed to calculate the size of the overlay so that transitions on its size
      // will have the correct starting points.
      this._preparePositioning();
      this.refit();
      this._finishPositioning();

      // Safari will apply the focus to the autofocus element when displayed for the first time,
      // so we blur it. Later, _applyFocus will set the focus if necessary.
      if (this.noAutoFocus && document.activeElement === this._focusNode) {
        this._focusNode.blur();
      }
    },

    /**
     * Tasks which cause the overlay to actually open; typically play an animation.
     * @protected
     */
    _renderOpened: function() {
      if (this.withBackdrop) {
        this.backdropElement.open();
      }
      this._finishRenderOpened();
    },

    /**
     * Tasks which cause the overlay to actually close; typically play an animation.
     * @protected
     */
    _renderClosed: function() {
      if (this.withBackdrop) {
        this.backdropElement.close();
      }
      this._finishRenderClosed();
    },

    /**
     * Tasks to be performed at the end of open action. Will fire `iron-overlay-opened`.
     * @protected
     */
    _finishRenderOpened: function() {
      // Focus the child node with [autofocus]
      this._applyFocus();

      this.notifyResize();
      this.__isAnimating = false;
      this.fire('iron-overlay-opened');
    },

    /**
     * Tasks to be performed at the end of close action. Will fire `iron-overlay-closed`.
     * @protected
     */
    _finishRenderClosed: function() {
      // Hide the overlay and remove the backdrop.
      this.style.display = 'none';
      // Reset z-index only at the end of the animation.
      this.style.zIndex = '';

      this._applyFocus();

      this.notifyResize();
      this.__isAnimating = false;
      this.fire('iron-overlay-closed', this.closingReason);
    },

    _preparePositioning: function() {
      this.style.transition = this.style.webkitTransition = 'none';
      this.style.transform = this.style.webkitTransform = 'none';
      this.style.display = '';
    },

    _finishPositioning: function() {
      // First, make it invisible & reactivate animations.
      this.style.display = 'none';
      // Force reflow before re-enabling animations so that they don't start.
      // Set scrollTop to itself so that Closure Compiler doesn't remove this.
      this.scrollTop = this.scrollTop;
      this.style.transition = this.style.webkitTransition = '';
      this.style.transform = this.style.webkitTransform = '';
      // Now that animations are enabled, make it visible again
      this.style.display = '';
      // Force reflow, so that following animations are properly started.
      // Set scrollTop to itself so that Closure Compiler doesn't remove this.
      this.scrollTop = this.scrollTop;
    },

    /**
     * Applies focus according to the opened state.
     * @protected
     */
    _applyFocus: function() {
      if (this.opened) {
        if (!this.noAutoFocus) {
          this._focusNode.focus();
        }
      } else {
        this._focusNode.blur();
        this._focusedChild = null;
        this._manager.focusOverlay();
      }
    },

    /**
     * Cancels (closes) the overlay. Call when click happens outside the overlay.
     * @param {!Event} event
     * @protected
     */
    _onCaptureClick: function(event) {
      if (!this.noCancelOnOutsideClick) {
        this.cancel(event);
      }
    },

    /**
     * Keeps track of the focused child. If withBackdrop, traps focus within overlay.
     * @param {!Event} event
     * @protected
     */
    _onCaptureFocus: function (event) {
      if (!this.withBackdrop) {
        return;
      }
      var path = Polymer.dom(event).path;
      if (path.indexOf(this) === -1) {
        event.stopPropagation();
        this._applyFocus();
      } else {
        this._focusedChild = path[0];
      }
    },

    /**
     * Handles the ESC key event and cancels (closes) the overlay.
     * @param {!Event} event
     * @protected
     */
    _onCaptureEsc: function(event) {
      if (!this.noCancelOnEscKey) {
        this.cancel(event);
      }
    },

    /**
     * Handles TAB key events to track focus changes.
     * Will wrap focus for overlays withBackdrop.
     * @param {!Event} event
     * @protected
     */
    _onCaptureTab: function(event) {
      // TAB wraps from last to first focusable.
      // Shift + TAB wraps from first to last focusable.
      var shift = event.shiftKey;
      var nodeToCheck = shift ? this.__firstFocusableNode : this.__lastFocusableNode;
      var nodeToSet = shift ? this.__lastFocusableNode : this.__firstFocusableNode;
      if (this.withBackdrop && this._focusedChild === nodeToCheck) {
        // We set here the _focusedChild so that _onCaptureFocus will handle the
        // wrapping of the focus (the next event after tab is focus).
        this._focusedChild = nodeToSet;
      }
    },

    /**
     * Refits if the overlay is opened and not animating.
     * @protected
     */
    _onIronResize: function() {
      if (this.__onIronResizeAsync) {
        cancelAnimationFrame(this.__onIronResizeAsync);
        this.__onIronResizeAsync = null;
      }
      if (this.opened && !this.__isAnimating) {
        this.__onIronResizeAsync = requestAnimationFrame(function() {
          this.__onIronResizeAsync = null;
          this.refit();
        }.bind(this));
      }
    },

    /**
     * Will call notifyResize if overlay is opened.
     * Can be overridden in order to avoid multiple observers on the same node.
     * @protected
     */
    _onNodesChange: function() {
      if (this.opened && !this.__isAnimating) {
        this.notifyResize();
      }
      // Store it so we don't query too much.
      var focusableNodes = this._focusableNodes;
      this.__firstFocusableNode = focusableNodes[0];
      this.__lastFocusableNode = focusableNodes[focusableNodes.length - 1];
    }
  };

  /** @polymerBehavior */
  Polymer.IronOverlayBehavior = [Polymer.IronFitBehavior, Polymer.IronResizableBehavior, Polymer.IronOverlayBehaviorImpl];

  /**
  * Fired after the `iron-overlay` opens.
  * @event iron-overlay-opened
  */

  /**
  * Fired when the `iron-overlay` is canceled, but before it is closed.
  * Cancel the event to prevent the `iron-overlay` from closing.
  * @event iron-overlay-canceled
  * @param {Event} event The closing of the `iron-overlay` can be prevented
  * by calling `event.preventDefault()`. The `event.detail` is the original event that originated
  * the canceling (e.g. ESC keyboard event or click event outside the `iron-overlay`).
  */

  /**
  * Fired after the `iron-overlay` closes.
  * @event iron-overlay-closed
  * @param {{canceled: (boolean|undefined)}} closingReason Contains `canceled` (whether the overlay was canceled).
  */

})();
</script>


<dom-module id="paper-toast" assetpath="bower_components/paper-toast/">
  <template>
    <style>
      :host {
        display: block;
        position: fixed;
        background-color: var(--paper-toast-background-color, #323232);
        color: var(--paper-toast-color, #f1f1f1);
        min-height: 48px;
        min-width: 288px;
        padding: 16px 24px;
        box-sizing: border-box;
        box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26);
        border-radius: 2px;
        left: 0;
        bottom: 0;
        margin: 12px;
        font-size: 14px;
        cursor: default;
        -webkit-transition: -webkit-transform 0.3s, opacity 0.3s;
        transition: transform 0.3s, opacity 0.3s;
        opacity: 0;
        -webkit-transform: translateY(100px);
        transform: translateY(100px);
        @apply(--paper-font-common-base);
      }

      :host(.capsule) {
        border-radius: 24px;
      }

      :host(.fit-bottom) {
        width: 100%;
        min-width: 0;
        border-radius: 0;
        margin: 0;
      }

      :host(.paper-toast-open) {
        opacity: 1;
        -webkit-transform: translateY(0px);
        transform: translateY(0px);
      }
    </style>

    <span id="label">{{text}}</span>
    <content></content>
  </template>

  <script>
    (function() {
      // Keeps track of the toast currently opened.
      var currentToast = null;

      Polymer({
        is: 'paper-toast',

        behaviors: [
          Polymer.IronOverlayBehavior
        ],

        properties: {
          /**
           * The duration in milliseconds to show the toast.
           * Set to `0`, a negative number, or `Infinity`, to disable the
           * toast auto-closing.
           */
          duration: {
            type: Number,
            value: 3000
          },

          /**
           * The text to display in the toast.
           */
          text: {
            type: String,
            value: ''
          },

          /**
           * Overridden from `IronOverlayBehavior`.
           * Set to false to enable closing of the toast by clicking outside it.
           */
          noCancelOnOutsideClick: {
            type: Boolean,
            value: true
          },

          /**
           * Overridden from `IronOverlayBehavior`.
           * Set to true to disable auto-focusing the toast or child nodes with
           * the `autofocus` attribute` when the overlay is opened.
           */
          noAutoFocus: {
            type: Boolean,
            value: true
          }
        },

        listeners: {
          'transitionend': '__onTransitionEnd'
        },

        /**
         * Read-only. Deprecated. Use `opened` from `IronOverlayBehavior`.
         * @property visible
         * @deprecated
         */
        get visible() {
          console.warn('`visible` is deprecated, use `opened` instead');
          return this.opened;
        },

        /**
         * Read-only. Can auto-close if duration is a positive finite number.
         * @property _canAutoClose
         */
        get _canAutoClose() {
          return this.duration > 0 && this.duration !== Infinity;
        },

        created: function() {
          this._autoClose = null;
          Polymer.IronA11yAnnouncer.requestAvailability();
        },

        /**
         * Show the toast. Without arguments, this is the same as `open()` from `IronOverlayBehavior`.
         * @param {(Object|string)=} properties Properties to be set before opening the toast.
         * e.g. `toast.show('hello')` or `toast.show({text: 'hello', duration: 3000})`
         */
        show: function(properties) {
          if (typeof properties == 'string') {
            properties = { text: properties };
          }
          for (var property in properties) {
            if (property.indexOf('_') === 0) {
              console.warn('The property "' + property + '" is private and was not set.');
            } else if (property in this) {
              this[property] = properties[property];
            } else {
              console.warn('The property "' + property + '" is not valid.');
            }
          }
          this.open();
        },

        /**
         * Hide the toast. Same as `close()` from `IronOverlayBehavior`.
         */
        hide: function() {
          this.close();
        },

        /**
         * Overridden from `IronFitBehavior`.
         * Positions the toast at the bottom left of fitInto.
         */
        center: function () {
          if (this.fitInto === window) {
            this.style.bottom = this.style.left = '';
          } else {
            var rect = this.fitInto.getBoundingClientRect();
            this.style.left = rect.left + 'px';
            this.style.bottom = (window.innerHeight - rect.bottom) + 'px';
          }
        },

        /**
         * Called on transitions of the toast, indicating a finished animation
         * @private
         */
        __onTransitionEnd: function(e) {
          // there are different transitions that are happening when opening and
          // closing the toast. The last one so far is for `opacity`.
          // This marks the end of the transition, so we check for this to determine if this
          // is the correct event.
          if (e && e.target === this && e.propertyName === 'opacity') {
            if (this.opened) {
              this._finishRenderOpened();
            } else {
              this._finishRenderClosed();
            }
          }
        },

        /**
         * Overridden from `IronOverlayBehavior`.
         * Called when the value of `opened` changes.
         */
        _openedChanged: function() {
          if (this._autoClose !== null) {
            this.cancelAsync(this._autoClose);
            this._autoClose = null;
          }
          if (this.opened) {
            if (currentToast && currentToast !== this) {
              currentToast.close();
            }
            currentToast = this;
            this.fire('iron-announce', {
              text: this.text
            });
            if (this._canAutoClose) {
              this._autoClose = this.async(this.close, this.duration);
            }
          } else if (currentToast === this) {
            currentToast = null;
          }
          Polymer.IronOverlayBehaviorImpl._openedChanged.apply(this, arguments);
        },

        /**
         * Overridden from `IronOverlayBehavior`.
         */
        _renderOpened: function() {
          this.classList.add('paper-toast-open');
        },

        /**
         * Overridden from `IronOverlayBehavior`.
         */
        _renderClosed: function() {
          this.classList.remove('paper-toast-open');
        },

        /**
         * Overridden from `IronOverlayBehavior`.
         * iron-fit-behavior will set the inline style position: static, which
         * causes the toast to be rendered incorrectly when opened by default.
         */
        _onIronResize: function() {
          Polymer.IronOverlayBehaviorImpl._onIronResize.apply(this, arguments);
          if (this.opened) {
            // Make sure there is no inline style for position.
            this.style.position = '';
          }
        }

        /**
         * Fired when `paper-toast` is opened.
         *
         * @event 'iron-announce'
         * @param {{text: string}} detail Contains text that will be announced.
         */
      });
    })();
  </script>
</dom-module>
<script>
  /**
   * The `iron-iconset-svg` element allows users to define their own icon sets
   * that contain svg icons. The svg icon elements should be children of the
   * `iron-iconset-svg` element. Multiple icons should be given distinct id's.
   *
   * Using svg elements to create icons has a few advantages over traditional
   * bitmap graphics like jpg or png. Icons that use svg are vector based so
   * they are resolution independent and should look good on any device. They
   * are stylable via css. Icons can be themed, colorized, and even animated.
   *
   * Example:
   *
   *     <iron-iconset-svg name="my-svg-icons" size="24">
   *       <svg>
   *         <defs>
   *           <g id="shape">
   *             <rect x="12" y="0" width="12" height="24" />
   *             <circle cx="12" cy="12" r="12" />
   *           </g>
   *         </defs>
   *       </svg>
   *     </iron-iconset-svg>
   *
   * This will automatically register the icon set "my-svg-icons" to the iconset
   * database.  To use these icons from within another element, make a
   * `iron-iconset` element and call the `byId` method
   * to retrieve a given iconset. To apply a particular icon inside an
   * element use the `applyIcon` method. For example:
   *
   *     iconset.applyIcon(iconNode, 'car');
   *
   * @element iron-iconset-svg
   * @demo demo/index.html
   * @implements {Polymer.Iconset}
   */
  Polymer({
    is: 'iron-iconset-svg',

    properties: {

      /**
       * The name of the iconset.
       */
      name: {
        type: String,
        observer: '_nameChanged'
      },

      /**
       * The size of an individual icon. Note that icons must be square.
       */
      size: {
        type: Number,
        value: 24
      }

    },

    attached: function() {
      this.style.display = 'none';
    },

    /**
     * Construct an array of all icon names in this iconset.
     *
     * @return {!Array} Array of icon names.
     */
    getIconNames: function() {
      this._icons = this._createIconMap();
      return Object.keys(this._icons).map(function(n) {
        return this.name + ':' + n;
      }, this);
    },

    /**
     * Applies an icon to the given element.
     *
     * An svg icon is prepended to the element's shadowRoot if it exists,
     * otherwise to the element itself.
     *
     * @method applyIcon
     * @param {Element} element Element to which the icon is applied.
     * @param {string} iconName Name of the icon to apply.
     * @return {?Element} The svg element which renders the icon.
     */
    applyIcon: function(element, iconName) {
      // insert svg element into shadow root, if it exists
      element = element.root || element;
      // Remove old svg element
      this.removeIcon(element);
      // install new svg element
      var svg = this._cloneIcon(iconName);
      if (svg) {
        var pde = Polymer.dom(element);
        pde.insertBefore(svg, pde.childNodes[0]);
        return element._svgIcon = svg;
      }
      return null;
    },

    /**
     * Remove an icon from the given element by undoing the changes effected
     * by `applyIcon`.
     *
     * @param {Element} element The element from which the icon is removed.
     */
    removeIcon: function(element) {
      // Remove old svg element
      if (element._svgIcon) {
        Polymer.dom(element).removeChild(element._svgIcon);
        element._svgIcon = null;
      }
    },

    /**
     *
     * When name is changed, register iconset metadata
     *
     */
    _nameChanged: function() {
      new Polymer.IronMeta({type: 'iconset', key: this.name, value: this});
      this.async(function() {
        this.fire('iron-iconset-added', this, {node: window});
      });
    },

    /**
     * Create a map of child SVG elements by id.
     *
     * @return {!Object} Map of id's to SVG elements.
     */
    _createIconMap: function() {
      // Objects chained to Object.prototype (`{}`) have members. Specifically,
      // on FF there is a `watch` method that confuses the icon map, so we
      // need to use a null-based object here.
      var icons = Object.create(null);
      Polymer.dom(this).querySelectorAll('[id]')
        .forEach(function(icon) {
          icons[icon.id] = icon;
        });
      return icons;
    },

    /**
     * Produce installable clone of the SVG element matching `id` in this
     * iconset, or `undefined` if there is no matching element.
     *
     * @return {Element} Returns an installable clone of the SVG element
     * matching `id`.
     */
    _cloneIcon: function(id) {
      // create the icon map on-demand, since the iconset itself has no discrete
      // signal to know when it's children are fully parsed
      this._icons = this._icons || this._createIconMap();
      return this._prepareSvgClone(this._icons[id], this.size);
    },

    /**
     * @param {Element} sourceSvg
     * @param {number} size
     * @return {Element}
     */
    _prepareSvgClone: function(sourceSvg, size) {
      if (sourceSvg) {
        var content = sourceSvg.cloneNode(true),
            svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'),
            viewBox = content.getAttribute('viewBox') || '0 0 ' + size + ' ' + size;
        svg.setAttribute('viewBox', viewBox);
        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
        // TODO(dfreedm): `pointer-events: none` works around https://crbug.com/370136
        // TODO(sjmiles): inline style may not be ideal, but avoids requiring a shadow-root
        svg.style.cssText = 'pointer-events: none; display: block; width: 100%; height: 100%;';
        svg.appendChild(content).removeAttribute('id');
        return svg;
      }
      return null;
    }

  });
</script>
<iron-iconset-svg size="24" name="waveform">
<svg><defs>
<g id="access-time"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67z"></path></g>
<g id="format-line-spacing"><path d="M6 7h2.5L5 3.5 1.5 7H4v10H1.5L5 20.5 8.5 17H6V7zm4-2v2h12V5H10zm0 14h12v-2H10v2zm0-6h12v-2H10v2z"></path></g>
<g id="keyboard"><path d="M20 5H4c-1.1 0-1.99.9-1.99 2L2 17c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm-9 3h2v2h-2V8zm0 3h2v2h-2v-2zM8 8h2v2H8V8zm0 3h2v2H8v-2zm-1 2H5v-2h2v2zm0-3H5V8h2v2zm9 7H8v-2h8v2zm0-4h-2v-2h2v2zm0-3h-2V8h2v2zm3 3h-2v-2h2v2zm0-3h-2V8h2v2z"></path></g>
<g id="cached"><path d="M19 8l-4 4h3c0 3.31-2.69 6-6 6-1.01 0-1.97-.25-2.8-.7l-1.46 1.46C8.97 19.54 10.43 20 12 20c4.42 0 8-3.58 8-8h3l-4-4zM6 12c0-3.31 2.69-6 6-6 1.01 0 1.97.25 2.8.7l1.46-1.46C15.03 4.46 13.57 4 12 4c-4.42 0-8 3.58-8 8H1l4 4 4-4H6z"></path></g>
<g id="gesture"><path d="M4.59 6.89c.7-.71 1.4-1.35 1.71-1.22.5.2 0 1.03-.3 1.52-.25.42-2.86 3.89-2.86 6.31 0 1.28.48 2.34 1.34 2.98.75.56 1.74.73 2.64.46 1.07-.31 1.95-1.4 3.06-2.77 1.21-1.49 2.83-3.44 4.08-3.44 1.63 0 1.65 1.01 1.76 1.79-3.78.64-5.38 3.67-5.38 5.37 0 1.7 1.44 3.09 3.21 3.09 1.63 0 4.29-1.33 4.69-6.1H21v-2.5h-2.47c-.15-1.65-1.09-4.2-4.03-4.2-2.25 0-4.18 1.91-4.94 2.84-.58.73-2.06 2.48-2.29 2.72-.25.3-.68.84-1.11.84-.45 0-.72-.83-.36-1.92.35-1.09 1.4-2.86 1.85-3.52.78-1.14 1.3-1.92 1.3-3.28C8.95 3.69 7.31 3 6.44 3 5.12 3 3.97 4 3.72 4.25c-.36.36-.66.66-.88.93l1.75 1.71zm9.29 11.66c-.31 0-.74-.26-.74-.72 0-.6.73-2.2 2.87-2.76-.3 2.69-1.43 3.48-2.13 3.48z"></path></g>
<g id="help-outline"><path d="M11 18h2v-2h-2v2zm1-16C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5 0-2.21-1.79-4-4-4z"></path></g>
<g id="menu"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></g>
<g id="redo"><path d="M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7l-3.6 3.6z"></path></g>
<g id="undo"><path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"></path></g>
<g id="view-list"><path d="M4 14h4v-4H4v4zm0 5h4v-4H4v4zM4 9h4V5H4v4zm5 5h12v-4H9v4zm0 5h12v-4H9v4zM9 5v4h12V5H9z"></path></g>
</defs></svg>
</iron-iconset-svg><script>

// adapted from:
// http://web-animations.github.io/web-animations-demos/#animate_css
Polymer({
	is: 'shake-animation',
	behaviors: [
		Polymer.NeonAnimationBehavior
	],
	configure: function(config){
		this._effect = new KeyframeEffect(config.node, [
          {transform: 'translate3d(0, 0, 0)', offset: 0}, 
          {transform: 'translate3d(-10px, 0, 0)', offset: 0.1}, 
          {transform: 'translate3d(10px, 0, 0)', offset: 0.2}, 
          {transform: 'translate3d(-10px, 0, 0)', offset: 0.3}, 
          {transform: 'translate3d(10px, 0, 0)', offset: 0.4}, 
          {transform: 'translate3d(-10px, 0, 0)', offset: 0.5}, 
          {transform: 'translate3d(10px, 0, 0)', offset: 0.6}, 
          {transform: 'translate3d(-10px, 0, 0)', offset: 0.7}, 
          {transform: 'translate3d(10px, 0, 0)', offset: 0.8}, 
          {transform: 'translate3d(-10px, 0, 0)', offset: 0.9}, 
          {transform: 'translate3d(0, 0, 0)', offset: 1}
		], {
			duration: 1000,  //note that we ignore any customized timing in config
			iterations: 1
		}); 
		return this._effect;
	}
})

</script><dom-module id="cross-hair" assetpath="/">
<style type="text/css">
:host {
position: absolute;
top: 0px;
left: 0px;
height: 100%;
width: 100%;
overflow: hidden;
}
</style>
<template><svg></svg></template>
<script>
"use strict";

Polymer({
	is: 'cross-hair',
	properties:{
		x: {
			type: Number,
			value: 0,
			notify: true
		},
		y: {
			type: Number,
			value: 0,
			notify: true
		},
		w: {
			type: Number,
			value: 0,
			notify: true
		},
		left:{
			type: Number,
			value: 0,
			notify: true
		},
		top: {
			type: Number,
			value: 0,
			notify: true
		},
		r: {
			type: Number,
			value: 6,
			notify: true
		},
		show_bars: {
			type: Number,
			value: 1,  //1=horizontal, 2=vertical 3=both (only 1 is implemented)
			notify: true
		},
	},
	observers: [
		'_update_svg(x, y, w, left, top, r, show_bars)'
	],
	_update_svg: function(x, y , w, left, top, r, show_bars){
		this.debounce('update', function(){
			let width = show_bars & 1 ? w : x+r+2;
			let height = y+r+2;
			let x_minus_r = x-r;
			let x_plus_r = x+r;

			let bars_1 = "";
			if(show_bars & 1){
				 bars_1 = `<line x1='0'    y1='${y}' x2='${x_minus_r}' y2='${y}' stroke='black' stroke-width='1'/>
						   <line x1='${w}' y1='${y}' x2='${x_plus_r}'  y2='${y}' stroke='black' stroke-width='1'/>
						   <line x1='0'    y1='${y}' x2='${x_minus_r}' y2='${y}' stroke='white' stroke-dasharray='2,2' stroke-width='1'/>
						   <line x1='${w}' y1='${y}' x2='${x_plus_r}'  y2='${y}' stroke='white' stroke-dasharray='2,2' stroke-width='1'/>`
			}

			// TODO: add show_bars & 2

			let svg = `<svg style='pointer-events:none;position:absolute;left:${left}px;top:${top}px;width:${width};height:${height}px;'
						 xmlns='http://www.w3.org/2000/svg' version='1.1'>
								<circle cx='${x}' cy='${y}' r='${r}' stroke='black' stroke-width='1' fill='none'/>
							    <circle cx='${x}' cy='${y}' r='${r}' stroke='white' stroke-dasharray='2,2' stroke-width='1' fill='none'/>
							    ${bars_1}</svg>`;
			Polymer.dom(this.root).innerHTML = svg;
			Polymer.dom.flush();
		});
	}
});
</script>
</dom-module><dom-module id="managed-canvas" assetpath="/">
<template></template>
<script>
"use strict";

Polymer({
    is:'managed-canvas',
    properties: {
        ckey: {
            type: String,
            value: "",
            observer: '_update'
        },
        fix_height: {
            type: Number,
            value: 0,
            observer: '_update_canv_style'
        },
        stretch_height: {
            type: Boolean,
            value: false,
            observer: '_update_canv_style'
        },flip_horizontal: {
            type: Boolean,
            notify: true,
            value: false,
            observer: '_update_canv_style'
        }
    }, listeners: {
        'mousemove': '_onmousemove',
        'mousedown': '_onmousedown',
        'mouseup': '_onmouseup'
    }, _update: function(ckey){
        this.style.display = '';
        if(ckey && ckey.canvas){
            // an actual canvas, so remove any existing one and slot in this one  
            if(this._canv_el && this._canv_el === Polymer.dom(this.root).firstChild){
                Polymer.dom(this.root).removeChild(this._canv_el);
            }
            Polymer.dom(this.root).appendChild(ckey.canvas);
            this._canvas_is_from_ckey = true; // so we cant overwrite its contents in future
            this._canv_el = ckey.canvas;
            this._update_canv_style();

        } else if(ckey && ckey.buffer){
            // buffer and dims

            if(this._canvas_is_from_ckey || !this._canv_el){
                // can't overwrite the old canvas (or there never was one), so make a new one

                // remove the old one (if it's still in our local dom)
                if(this._canv_el && this._canv_el === Polymer.dom(this.root).firstChild){
                    Polymer.dom(this.root).removeChild(this._canv_el);
                }

                this._canv_el = document.createElement('canvas');
                Polymer.dom(this.root).appendChild(this._canv_el);
                this._canvas_is_from_ckey = false; // so in future you can overwrite the data if you want
            }

            this._canv_el.width = ckey.dims[0];
            this._canv_el.height = ckey.dims[1];
            let ctx = this._canv_el.getContext('2d');
            let im_data = ctx.createImageData(ckey.dims[0], ckey.dims[1]);
            im_data.data.set(new Uint8ClampedArray(ckey.buffer));
            ctx.putImageData(im_data, 0, 0);
            this._update_canv_style();

        } else {
            // null canvas .. 
            this.style.display = 'none';
        }
       
    }, _update_canv_style: function(){
        if(this.fix_height && this.stretch_height){
            console.warn('managed-canvas cannot stretch and fix height')
        }
        let el_canv = this._canv_el;
        if(!el_canv){
            return;
        }
        el_canv.style.margin = "";
        el_canv.style.left = "";
        el_canv.style.right = "";
        el_canv.style.position = "";

        if(this.stretch_height){
            // this does what is needed for now, but it's not pretty...
            el_canv.style.height = "100%";
            el_canv.style.margin = "0 auto";
            el_canv.style.left = "0";
            el_canv.style.right = "0";
            el_canv.style.position = "absolute";
        } else if (this.fix_height){
            el_canv.style.height = this.fix_height + "px";
        } else {
            el_canv.style.height = "";
        }
        el_canv.style.imageRendering = "pixelated";  
        this.transform(this.flip_horizontal ? 'scaleX(-1)' : '', el_canv);

    }, _onmousemove: function(e){
        this._fire_pointer_event(e, 'canvas-mousemove');
    }, _onmouseup: function(e){
        this._fire_pointer_event(e, 'canvas-mouseup');
    }, _onmousedown: function(e){
        this._fire_pointer_event(e, 'canvas-mousedown');
    }, _fire_pointer_event: function(e, name){
        // TODO: might be nice to cache the metrics rather than recomputing from scratch each time
        let canv_el = this._canv_el;
        if(!canv_el){
            return;
        }
        let rect = canv_el.getBoundingClientRect();
        e.offset_x = e.clientX-rect.left;
        e.offset_y = e.clientY-rect.top;
        e.canvas_width = rect.width;
        e.canvas_height = rect.height;
        e.canvas_point = [
            0 | (e.offset_y/rect.height*canv_el.height), 
            0 | (e.offset_x/rect.width*canv_el.width)
        ];
        this.fire(name, e);
    }
});

</script>
</dom-module>



<dom-module id="canvas-with-axes" assetpath="/">
<style>
:host{
display: inline-block;
position: relative;
}
.x_axis_label{
position: absolute;
display: inline-block;
bottom: 2px;
right: 2px;
font-size: 10px;
}
.y_axis_label{
position: absolute;
display: inline-block;
left: 2px;
top: 2px;
font-size: 10px;
}
</style>
<template>
    <managed-canvas ckey="[[ckey]]" fix_height="[[fix_height]]" id="the_canvas" flip_horizontal="[[flip_horizontal]]"></managed-canvas>
    <div class="x_axis_label" style$="[[_show(ckey)]]">[[x_label]]</div>
    <div class="y_axis_label" style$="[[_show(ckey)]]">[[y_label]]</div>
</template>

<script>
Polymer({
    is: 'canvas-with-axes',
    properties: {
        fix_height: {
            type: Number,
            notify: true
        },
        ckey: {
            type: Object,
            notify: true
        },
        x_label: {
            type: String,
            notify: true
        },
        y_label: {
            type: String,
            notify: true
        }, 
        flip_horizontal: {
            type: Boolean,
            notify: true,
            value: false
        }
    }, _show: function(v){
        return v ? '' : 'display: none;';
    }
})
</script>

</dom-module><script>
var Palettes = Palettes || {};

// all pallets are given as Uint8 arrays, except *_css and *_css_text, which are strings

Palettes.flag =  function(){
    var data = new Uint8Array(256*4);
    for(var i=0;i<256;i++){
        data[i*4+3] = 255; //alpha to full opaque
    }
    data[0*4+0] = 190;    data[0*4+1] = 190;    data[0*4+2] = 190; //was 220 for all three
    data[1*4+2] = 200;
    data[2*4+0] = 80;   data[2*4+1] = 255;
    data[3*4+0] = 255;
    data[4*4+0] = 245;  data[4*4+2] = 255;
    data[5*4+1] = 75;   data[5*4+1] = 200;  data[5*4+2] = 255;
    data[6*4+1] = 185;
    data[7*4+0] = 255;  data[7*4+1] = 185;  data[7*4+2] = 50;
    data[8*4+1] = 150;  data[8*4+2] = 175;
    data[9*4+0] = 150;  data[9*4+2] = 175;
    data[10*4+0] = 170; data[10*4+1] = 170;
    data[11*4+0] = 200;
    data[12*4+0] = 255; data[12*4+1] = 255;
    data[13*4+0] = 140; data[13*4+1] = 140; data[13*4+2] = 140;
    data[14*4+1] = 255; data[14*4+2] = 235;
    data[15*4+0] = 255; data[15*4+2] = 160;
    data[16*4+0] = 175; data[16*4+1] = 75; data[16*4+2] = 75;
    data[17*4+0] = 255; data[17*4+1] = 155; data[17*4+2] = 175;
    data[18*4+0] = 190; data[18*4+1] = 190; data[18*4+2] = 160;
    data[19*4+0] = 255; data[19*4+1] = 255; data[19*4+2] = 75;
    data[20*4+0] = 154; data[20*4+1] = 205; data[20*4+2] = 50;
    data[21*4+0] = 255; data[21*4+1] = 99; data[21*4+2] = 71;
    data[22*4+1] = 255; data[22*4+2] = 127;
    data[23*4+0] = 255; data[23*4+1] = 140;
    data[24*4+0] = 32; data[24*4+1] = 178; data[24*4+2] = 170;
    data[25*4+0] = 255; data[25*4+1] = 69; 
    data[26*4+0] = 240; data[26*4+1] = 230; data[26*4+2] = 140;
    data[27*4+0] = 100; data[27*4+1] = 149; data[27*4+2] = 237;
    data[28*4+0] = 255; data[28*4+1] = 218; data[28*4+2] = 185;
    data[29*4+0] = 153; data[29*4+1] = 50; data[29*4+2] = 204;
    data[30*4+0] = 250; data[30*4+1] = 128; data[30*4+2] = 114;
    return data;
}();

Palettes.flag8 = Palettes.flag;
Palettes.flag32 = new Uint32Array(Palettes.flag.buffer);

Palettes.flag_css = function(){
    var ret = [];
    for(var i=0;i<Palettes.flag.length;i+=4){
        ret.push('rgb(' + Palettes.flag[i] +"," + Palettes.flag[i+1] +","+ Palettes.flag[i+2]+")") //maybe a bit inefficient but it's only 256 values so whatever
    }
    return ret;
}();

Palettes.flag_css_text = function(){
    var black_list = [0,2,3,4,5,6,7,10,12,13,14,15,17,18,19,20,21,22,23,25,26,27,28,30]; //these group numbers are black, all others are white
    var ret = [];
    for(var i=0;i<Palettes.flag.length/4;i++){
        ret.push( black_list.indexOf(i) == -1 ? '#FFF' : '#000');
    }
    return ret;
}();

Palettes.time = function(){
    var data = new Uint8Array(256*4);
    for(var i=0;i<256;i++){
        data[i*4 +0] = 255-i;  //decreasing red
        data[i*4 +1] = i; //increasing green
        data[i*4 +3] = 255; //set alpha to opaque
    }
    return data;
}();


</script><dom-module id="tile-element" assetpath="/">
<style>
:host {
display: inline-table;
position: relative;
transform: rotateY(0);
-webkit-transform: rotateY(0);
min-width: 98px;
min-height: 128px;
left: 0px;
top: 0px;
border: 1px solid #CCC;
line-height: 0px;
text-align: right;
}
:host(.noborder){
border: none;
}
.over{
position: absolute;
top: 0px;
left: 0px;
right: 0px;
bottom: 0px;
pointer-events: none;
}
.caption{
padding-top: 2px;
line-height: 12px;
text-align: center;
background-color:rgba(255,255,255,0.85);
box-shadow: -3px 0px 6px #ddc;
}
.sticker{
line-height: 12px;
width: 20px;
height: 17px;
border: 1px solid #000;
text-align: center;
font-size: 0.8em;
padding-top: 3px;
position: absolute;
right: 2px;
top: 2px;
z-index: 10;
}
.side{
position: absolute;
right: 0px;
top: 0px;
bottom: 0px;
width: 60px;
}
.blind{
position: absolute;
left: 0px;
right: 0px;
top: 0px;
bottom: 0px;
z-index: 100;
background: rgba(0,0,0,0.5);
display: none;
}
.dir-rm{
height:78px;
}
.speed-rm{
}
.tc{
height:50px;
}
.caption_inner{
border-bottom: 1px solid #000;
padding-bottom: 1px;
padding-top: 1px;
}
.caption_inner:last-of-type{
border-bottom: 0px;    
}
.caption_inner-label{
font-weight: bold;
font-size: 0.8em;
}
.grabber{
position: absolute;
top: 0px;
left: 0px;
right: 0px;
bottom: 0px;
}
.grabber:hover{
@apply(--grabber-hover);
}
.canvas_part_1{
display: table-cell;
vertical-align: bottom;
}
.canvas_part_2{
display: table-cell;
vertical-align: bottom;
text-align: right;    
}
.side{
display: flex;
flex-direction: column; 
}
.flex{
flex:2;
}
@-webkit-keyframes fadeout{
0%     { opacity: 1;  }
33%   { opacity: 1;   }
50%   { opacity: 0;   }
83%   { opacity: 0;   }
100%   { opacity: 1;   }
}
.placeholder{
position: absolute;
height: 100%;
width: 100%;
z-index: -1;
text-align: center;
}
.placeholder_text{
display: inline-block;
position: relative;
top: 45%;
font-size: 20px;
}
:host(.active.moving){
opacity: 0.5;
border-width: 10px;
margin: -9px;
border-color: #000;
background-color: #888;
pointer-events: none;
z-index: 100;
box-shadow: initial;
}
.placeholder{
display: none;
}
:host(.active.moving) .placeholder{
display: block;
}
:host(.active){
box-shadow: 0px 0px 5px 3px #fc0;
background-color: #eee;
}
.over {
display: none;
}
:host(.active) .over{
display: block;
pointer-events: none;
}
:host(.active.moving) .over{
display: none;
}
:host(.active.moving.proximate){
background-color: initial;
opacity: 1;
}

:host(.active.moving.proximate) .sticker{
right: 26px;
}

:host(.active.moving.proximate) .sticker,
:host(.active.moving.proximate) managed-canvas {
-webkit-animation: fadeout 1.5s linear infinite;
}

:host(.disabled) .blind{
display: block;
};
:host(.disabled){
pointer-events: none;
}
:host(.active.splitting){
/* cursor: none; */ /* TODO: this doesn't seem to update until after you mouseup, and anyway we actually do want the mouse when the mouse is up */;
}
</style>

<template>
    <div class="placeholder" id="placeholder">
        <div class="placeholder_text">[group [[group_num]]]</div> 
    </div>
    <div class="canvas_part_1">
        <managed-canvas ckey="[[group_model.waves]]" on-canvas-mousedown="_mousedown_splitter" fix_height="128"></managed-canvas>
        <template is="dom-if" if="[[splitter_metrics]]">
            <cross-hair r="6" show_bars="1" x="[[splitter_metrics.x]]" y="[[splitter_metrics.y]]" w="[[splitter_metrics.w]]"></cross-hair>
        </template>
        <managed-canvas ckey="[[group_model.rm.spa]]" fix_height="[[spa_rm_height]]"></managed-canvas>
    </div>
    <div class="canvas_part_2">
        <div>
            <managed-canvas ckey="[[group_model.rm.dir]]"></managed-canvas>
            <managed-canvas ckey="[[group_model.rm.speed]]"></managed-canvas>
        </div>
        <managed-canvas ckey="[[group_model.tac]]"></managed-canvas>
    </div>
    <div id="sticker" class="sticker" style$="[[_sticker_style(group_num)]]">[[group_num]]</div>
    <div id="over" class="over">
        <div class="side">
            <div class="flex"></div>
            <div class="caption">
                <div style$="[[_show(group_model.rm.spa_max)]]" class="caption_inner">
                    [[group_model.rm.spa_max]]Hz
                    <div class="caption_inner-label">spa max</div>
                </div>
                <div style$="[[_show(group_model.rm.dir_max)]]" class="caption_inner">
                    [[group_model.rm.dir_max]]Hz
                    <div class="caption_inner-label">dir max</div>
                </div>
                <div class="caption_inner">[[group_model.n_spikes]]
                    <div class="caption_inner-label">n spikes</div>
                </div>
            </div>
        </div>
    </div>
    <div id="blind" class="blind"></div>
    <div class="grabber" hidden$="{{!grabber_mode}}" on-mouseup="_grab"></div>
</template>


<script>
    "use strict";
        
    Polymer({
        is:'tile-element',
        behaviors: [
            Polymer.NeonAnimationRunnerBehavior, 
            Polymer.ShortcutNotifyTargetBehavior(['group_model'])
        ], properties: {
            group_num: {
                type: Number,
                notify: true,
                value: -1,
                notify: true
            },
            group_model: {
                type: Object,
                notify: true,
                value: function(){return {};},
                notify: true
            },
            moving: {
                type: Boolean,
                value: false,
                notify: true
            },
            active: {
                type: Boolean,
                value: false,
                notify: true
            },
            proximate: {
                type: Boolean,
                value: false,
                notify: true
            },
            disabled: {
                type: Boolean,
                value: false,
                notify: true
            },
            spa_rm_height:{
                type: Number,
                value: 120,
                notify: true
            },
            animationConfig: { // for use with NeonAnimationRunnerBehavior
                value: function(){
                    return { shake: {name: 'shake-animation', node: this} };
                }
            },
            grabber_mode: {
                type: Boolean,
                value: false,
                notify: true
            },
            splitter_metrics: {
                type: Object,
                value: null,
                notify: true
            }
        },
        observers: [
            '_update_state(active, moving, proximate, disabled, splitter_metrics)',
        ], _show: function(val){ // for use in binding as style$='display:_show(val)', truthy vals are shown, falsey are hidden
            return val !== null && val !== "" && val >= 0 ? '' : 'display:none;';
        }, _sticker_style: function(group_num){
            return "background-color:" + Palettes.flag_css[group_num] + "; color:" + Palettes.flag_css_text[group_num] + ";";
        }, _update_state: function(active, moving, proximate, disabled, splitter_metrics){
            // TODO: the various states may be entirely separable now (it was much, much worse in the past!)
            if(disabled && moving){
                throw "cannot disable tile while moving";
            }
                
            if(disabled){
                this.set('active', false); // may have been true. TODO: really?
            } 

            if(proximate && !moving){
                console.warn("tile for group " + this.group_num + " cannot be proximate unless it is moving");
            }

            moving ? this.classList.add('moving') : this.classList.remove('moving');
            proximate ? this.classList.add('proximate') : this.classList.remove('proximate');
            splitter_metrics ? this.classList.add('splitting') : this.classList.remove('splitting');
            disabled ? this.classList.add('disabled') : this.classList.remove('disabled');
            active ? this.classList.add('active') : this.classList.remove('active');

        }, shake: function(){
            this.cancelAnimation();
            this.playAnimation('shake');
        }, translate_xy: function(x,y){
            if(x || y){
                this.transform('translate(' + x + 'px,' + y + 'px)');
                this.transform('translate(' + -x + 'px,' + -y + 'px)', this.$.placeholder)
            } else {
                this.transform('');
                this.transform('',this.$.placeholder);
            }
        }, _grab: function(){
            // do a sufficiently-deep clone of the group model
            // TODO: this could perhaps be turned into a fucntion in cut-object
            // rather than doing it here
            let group = {
                waves: {canvas: Utils.clone_canvas(this.group_model.waves.canvas)}, 
                tac: this.group_model.tac,
                rm: {
                  spa: this.group_model.rm.spa,
                  dir: this.group_model.rm.dir,
                  speed: this.group_model.rm.speed  
                }
            };
            let rect = this.getBoundingClientRect();
            this.fire('grab_group', {
                src_client_x: rect.left,
                src_client_y: rect.top,
                group: group,
                group_num: this.group_num
            });
        }, _mousedown_splitter: function(e){
            if(e.detail.button === 0){
                return; // left click either irrelevant or handled by tile-wall itself
            }

            let detail = {
                state: '',
                group: this.group_model,
                point: e.detail.canvas_point,
                x: e.detail.offset_x,
                y: e.detail.offset_y,
                w: e.detail.canvas_width
            };

            e.detail.stopPropagation(); // a bit hacky, but prevents raw mouse-down event from propagating to tile-wall
            detail.state = this.splitter_metrics ? 'move' : 'start';
            this.fire('splitter', detail);
            this._splitter_el = e.target;

            this.listen(this._splitter_el, 'canvas-mousemove', '_mousemove_splitter');
            this.listen(this._splitter_el, 'canvas-mouseup', '_mousemove_splitter'); // this just goes to mousemove, and then ...
            this.listen(document, 'mouseup', '_mouseup_splitter'); // we actually process the up on the document

        }, _mouseup_splitter: function(e){
            this.unlisten(document, 'mouseup', '_mouseup_splitter');
            this.unlisten(this._splitter_el, 'canvas-mousemove', '_mousemove_splitter');
            this.unlisten(this._splitter_el, 'canvas-mouseup', '_mousemove_splitter');
            this.fire('splitter', {
                state: 'update',
                group: this.group_model,
                point: null,
                x: null,
                y: null,
                w: null
            });
        }, _mousemove_splitter: function(e){
            this.fire('splitter', {
                state: 'move',
                group: this.group_model,
                point: e.detail.canvas_point,
                x: e.detail.offset_x,
                y: e.detail.offset_y,
                w: e.detail.canvas_width
            });
        }
    });
</script>

  
</dom-module><script>

var Utils = {}

Utils.parse_splices = function(splices, give_moved){
    // I really don't understand what you get from an array.splices observer.
    // Here we takes the "splices" object provided, and guarantee to return
    // an object with two arrays of items called added and removed.
    // if give_moodified is truthy, then we provide a third array, modified
    // giving an array of objects which had their index changed

    var added_keys, removed_keys, moved_keys;

    // Firstly, get the list of added and removed *keys*
    if(!splices || !splices.keySplices || splices.keySplices.length === 0){
        // nothing
        added_keys = [];
        removed_keys = [];
    } else if (splices.keySplices.length === 1){
        // assume that if there's only one element in the array then it's already properly de-deduped
        added_keys = splices.keySplices[0].added;
        removed_keys = splices.keySplices[0].removed;
    } else {
        // multiple splices..I'm not sure how to interpret the indexSplices,
        // but the keySplices is easier.
        added_keys = new Set(), removed_keys = new Set();
        for (let s of splices.keySplices) {
            for (let key of s.removed) {
                if(added_keys.has(key)){
                    added_keys.delete(key);
                } else {
                    removed_keys.add(key);
                }
            }
            for (let key of s.added) {
                if(removed_keys.has(key)){
                    removed_keys.delete(key);
                } else {
                    added_keys.add(key);
                }
            }
        }
    }

   
    // Now convert the keys to objects...
    var added = [], removed = [], moved = [];

    if(added_keys.length || added_keys.size){
        let coll = Polymer.Collection.get(splices.indexSplices[0].object);
        for(let key of added_keys){
            let item = coll.getItem(key);
            (item !== undefined) && added.push(item);
        }        
    }

    if(removed_keys.length || removed_keys.size){
        // we can't use getItem for removed items, because they're no longer in the
        // collection.

        // note that this bit depends on the polymer patch which sets _pkey
        let discarded_items = new Map();
        for(let s of splices.indexSplices){
            for(let item of s.removed)if(item){
                discarded_items.set(item._pkey, item);  
            }
        }
        for(let key of removed_keys){
            let item = discarded_items.get(key);
            (item !== undefined) && removed.push(item);
        }
    }

    if(give_moved){
        console.warn("parse_splices give_moved=true not implemented yet.");
        moved = [];
    }

    return {
        added: added,
        removed: removed,
        moved: moved
    };


}


Utils.deep_clone = function(obj){
    // this doesn't bother realing with self-referential things, but it
    // does tolerate things that wouldn't work with JSON.parse(JSON.stringify)
    // in particular typed arrays (which are *not* cloned, but end up in both
    // src and dest), files, and dom elements likewise.

    if (!obj) {
        return obj;
    } else if(obj.constructor === Object || obj.constructor === Array){
        let dest = new obj.constructor();
        for(let key in obj)if(Object.hasOwnProperty.call(obj, key)){
            dest[key] = Utils.deep_clone(obj[key]);
        }
        return dest;
    } else {
        return obj; // string, numbers, and other strange things
    }


}

Utils.get_key = function(arr, item){
    // don't use this in a tight loop..lift the get(arr) out of the loop.
    return Polymer.Collection.get(arr).getKey(item); 
}

Utils.is_equal_simple = function(a, b){
    // very simple....
    if((a && !b) || (!a && b)){
        return false;
    }
    for(let aa in a){
        if(b[aa] !== a[aa]){
            return false;
        }
    }
    for(let bb in b){
        if(b[bb] !== a[bb]){
            return false;
        }
    }
    return true;
};

//Escape a user specified string for use in regex search.
// Taken from http://stackoverflow.com/a/3561711
Utils.regex_escape= function(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
};


//Takes an Array of strings and returns a regex which can be used for finding items in the set given in the list
// with the longest possible match returned. e.g.
// regex_from_list(["hello","world","hello world"]).exec("this hello world life") will match on "hello world".
Utils.regex_from_list = function(a){
    if(!a.length)
        return null;
    return RegExp(a.sort(function(a,b){
                                    return b.length-a.length;
                             }).map(Utils.regex_escape).join("|"));
};


// setImmediate (on main thread), but we just the same impementation as worker-builder
// taken/adapted from https://github.com/YuzuJS/setImmediate/blob/master/setImmediate.js
(function(){
    // exports window.setImmediate and window.clearImmediate
    var last_task_h=0;
    var tasks = {};
    window._immediate_channel = new MessageChannel();
    _immediate_channel.port1.onmessage = function(e) {
        var h = e.data;
        try {
            tasks[h] && tasks[h]();
        } finally {
            clearImmediate(h);
        }
    }
    window.setImmediate = function(cb) {
        tasks[++last_task_h] = cb;
        _immediate_channel.port2.postMessage(last_task_h);
        return last_task_h;
    }
    window.clearImmediate = function(h){
        delete tasks[h];
    }
})();



Utils.typed_array_manager = (function(){
    return {
        to_akey: function(arr){
            return {array: arr};
        },
        get_array_clone: function(akey){
            // note that the clone is not put in the store. It is
            // inteded to be used when dealing with workers, and needing to 
            // transfer an array in its intereity to another thread.
            return akey && akey.array && new akey.array.constructor(akey.array);
        }
    }; 

})();


Utils.file_manager = (function(){
    let counter = 0;
    return {
        to_fkey: function(file){
            return {
                file: file,
                id: ++counter // useful when disscussing things with workers
            };
        },
    };
})();



Utils.clone_canvas = function(old_canv){
    if(!old_canv){
        return;
    }
    let new_canv = document.createElement("canvas");
    new_canv.width = old_canv.width;
    new_canv.height = old_canv.height;
    new_canv.getContext('2d').drawImage(old_canv, 0, 0);
    new_canv.style.cssText = old_canv.style.cssText;
    return new_canv;
}

Utils.ckey_to_data_url = function(ckey, height, width){
    if(!ckey){
        return "";
    }

    let canv_el;
    if(ckey.canvas){
        // ckey is an actual canvas
        canv_el = ckey.canvas;
        let computed_width, computed_height;

        if(!height || !width){
            try{
                let s = getComputedStyle(canv_el);
                width = width || parseInt(s.width);
                height = height || parseInt(s.height);
            }catch(e){
                // TODO: might want the (width && !height) thing, as below
                width = width || canv_el.width; 
                height = height || canv_el.height;
            };            
        }
    } else {

        // ckey is just buffer and dims, so put data into a new canvas
        canv_el = document.createElement('canvas');
        canv_el.width = ckey.dims[0];
        canv_el.height = ckey.dims[1];
        ctx = canv_el.getContext('2d');
        let im_data = ctx.createImageData(ckey.dims[0], ckey.dims[1]);
        im_data.data.set(new Uint8ClampedArray(ckey.buffer));
        ctx.putImageData(im_data, 0, 0);
        if(width && !height){
            height = ckey.dims[1] * width/ckey.dims[0];
        } else if(height && !width){
            width = ckey.dims[0] * height/ckey.dims[1];
        } else {
            height = ckey.dims[1];
            width = ckey.dims[0];
        }
    }

    if(width !== canv_el.width || height !== canv_el.height){
        // resize to new canvas, so there's no room for recieving
        // application to screw it up
        let original_canv = canv_el;
        canv_el = document.createElement('canvas');
        canv_el.width = width;
        canv_el.height = height;
        canv_el.getContext('2d').drawImage(original_canv, 0, 0, original_canv.width, 
                                           original_canv.height, 0, 0, width, height);
    }

    let url = canv_el.toDataURL();

    return `<img src='${url}' width='${width}' height='${height}' />`;

}

</script><dom-module id="tile-wall" assetpath="/">
<style>
.blank_info {
display: inline-block;
position: absolute;
left: 50%;
top: 30%;
transform: translateX(-50%);
}
:host{
cursor: default;
overflow-y: auto !important;
padding: 2px;
}
::-webkit-scrollbar {
width: 10px;
height: 10px;
}
::-webkit-scrollbar-button {
width: 0;
height: 0;
display: none;
}
::-webkit-scrollbar-thumb {
background-color: rgba(0,0,0,0.2);
-webkit-box-shadow: inset 1px 1px 0 rgba(0,0,0,0.10),inset 0 -1px 0 rgba(0,0,0,0.07);
}
</style>
<template>

    <div class="blank_info" style$="{{_show(is_empty)}}">
        No group data to be shown. Select a trial-tetrode pair with files available.
    </div>

    <template is="dom-repeat" items="[[groups]]">
        <tile-element style$="[[_show(item)]]" group_num="[[index]]" group_model="[[item]]" spa_rm_height="[[options.spa_rm_height]]" active="{{_is_equal(item, active_group_a)}}" grabber_mode="[[grabber_mode]]" splitter_metrics="{{_metrics_if_splitting(item, splitter_state.*)}}" disabled="{{_disabled_if_not_splitting(item, splitter_state.*)}}" on-mouseenter="_mouseenter_tile" on-mouseleave="_mouseleave_tile" on-track="_track_tile" on-tap="_tap_tile"></tile-element>        
    </template>
</template>


<script>
    "use strict";
    Polymer({
        is:'tile-wall',
        properties: {
            groups: {
                type: Array,
                value: function(){return [];},
                notify: true    
            },
            options: {
                type: Object,
                value: {} // settings for plotting
            },
            active_group_a: {
                type: Object,
                value: null,
                notify: true
            },
            active_group_b: {
                type: Object,
                value: null,
                notify: true
            },
            is_empty: {
                type: Boolean,
                value: false,
                notify: true,
            },
            grabber_mode: {
                type: Boolean,
                value: false,
                notify: true
            }, 
            splitter_state: {
                type: Object,
                notify: true
            }
        },
        observers: [
            'groups_modified(groups.*)'
        ], listeners: {
            'mousedown': '_mousedown_splitter'
        }, groups_modified: function(change){

        }, _show: function(v){
            return v ? '' : 'display: none;';
        }, _mouseenter_tile: function(e){
            if(this.grabber_mode){
                return
            }
             if(this._track_state){
                if(e.target !== this._track_state.tile_el){
                    this.set('active_group_b', e.model.item);
                    this._track_state.other_tile_el = e.target;
                    this._track_state.tile_el.set('proximate', true);
                } 
             } else {
                this.set('active_group_a', e.model.item);
            }
        }, _mouseleave_tile: function(e){
            if(this.grabber_mode){
                return
            }
            if(this._track_state){
                this.set('active_group_b', null);
                this._track_state.other_tile_el = null;
                this._track_state.tile_el.set('proximate', false);
            } else {
                this.set('active_group_a', null);
            }
        }, _is_equal: function(a,b){
            return a===b;
        }, _track_tile: function(e){

            if(e.detail.state === "end"){
                if(!this._track_state){
                    return; 
                }
                this.unlisten(this, 'scroll', '_scroll');
                this.unlisten(this, 'mouseup', '_failed_track');
                this._track_state.tile_el.translate_xy(null);
                if(this.active_group_b){
                    this.fire('merge_groups', {
                        a: this.active_group_a.group_num,
                        b: this.active_group_b.group_num
                    });
                    this.set('active_group_b', null);
                    this._track_state.other_tile_el.shake(); // either this or...
                }
                this._track_state.tile_el.shake(); // ... this will remain in the tilewall after the merge
                this._track_state.tile_el.set('proximate', false);
                this._track_state.tile_el.set('moving', false);
                this._track_state = null;
                return;
            } 

            if (e.detail.state === "start"){
                // Polymer's track doesn't do everything we need it to,
                // so we basically reinvent it and do a bit more...
                let rect = e.target.getBoundingClientRect();
                this._track_state = {
                    start_scroll_top: this.scrollTop,
                    start_client_x: e.detail.x,
                    start_client_y: e.detail.y,
                    untransformed_client_x: rect.left,
                    untransformed_client_y: rect.top,
                    last_client_x: e.detail.x,
                    last_client_y: e.detail.y,
                    tile_el: e.target,
                    other_tile_el: null
                }
                this.listen(this, 'scroll', '_scroll');
                this.listen(this, 'mouseup', '_failed_track');
                e.target.set('moving', true);
            } else {
                this._track_state.last_client_x = e.detail.x;
                this._track_state.last_client_y = e.detail.y;
            }
            let state = this._track_state;

            let tx, ty;
            if(this._track_state.other_tile_el){
                // this is pretty ugly, but it does the job...
                let other_rect = state.other_tile_el.getBoundingClientRect();
                let border_fudge = state.tile_el.border_width - state.other_tile_el.border_width;
                tx = other_rect.left - state.untransformed_client_x;
                ty = other_rect.top - state.untransformed_client_y + (this.scrollTop - state.start_scroll_top);
            } else {
                tx = e.detail.x - state.start_client_x;
                ty = e.detail.y - state.start_client_y + (this.scrollTop - state.start_scroll_top);            
            }

            state.tile_el.translate_xy(tx, ty);

        }, _scroll: function(e){
            // attached during tracking
            e.detail = {
                state: 'scroll',
                x: this._track_state.last_client_x,
                y: this._track_state.last_client_y
            };
            this._track_tile(e);
        }, _failed_track: function(e){
            // attached during tracking as mouseup on tilewall itself
            if(!this._track_state){
                return; 
            }
            let my_event = {
                detail: {
                    state: 'end',
                    x: this._track_state.last_client_x,
                    y: this._track_state.last_client_y
                },
                target: this._track_state.tile_el
            };
            this._track_tile(my_event);
        }, _metrics_if_splitting: function(group, state){
            return (group === state.base.group_a || group === state.base.group_b) ? state.base.metrics : null;
        }, _disabled_if_not_splitting: function(group, state){
            return state.base.group_a && !(group === state.base.group_a || group === state.base.group_b);
        }, _mousedown_splitter: function(e){
            if(!this.splitter_state.metrics){
                return;
            }
            this.fire('splitter', {
                state: e.button === 0 ? 'finalize' : 'cancel'
            });
        }, _tap_tile: function(e){
            this.fire('tap_group', e.model.item);
        }
    });
</script>

  
</dom-module><dom-module id="iron-resize-notifier" assetpath="bower_components/iron-splitter/">
<template><content></content></template>
<script>
  Polymer({
    is: 'iron-resize-notifier',
    behaviors: [Polymer.IronResizableBehavior]
  })
</script>
</dom-module>

<dom-module id="iron-splitter" assetpath="bower_components/iron-splitter/">

<style>
:host {
display: block;
width: 12px;
background: #efefef url("bower_components/iron-splitter/handle.svg") no-repeat center;
box-shadow: inset 0 0 2px 1px #ccc;
cursor: col-resize;
flex-shrink: 0;
}

:host(.horizontal) {
width: auto;
height: 12px;
cursor: row-resize;
background-image: url("bower_components/iron-splitter/handle-h.svg");
}

:host(:hover, :active) {
background-color: #ddd;
}
</style>

<template></template>

<script>
Polymer({
  is: 'iron-splitter',
  behaviors: [
    Polymer.IronResizableBehavior
  ], properties: {
      allowOverflow: {
        type: Boolean,
        value: false,
        notify: true
      },
      direction: {
        type: String, // `left`, `right`, `up` or `down`
        value: 'left',
        notify: true,
        observer: '_directionChanged'
      },
      locked: {
        type: Boolean, // Locks the split bar so it can't be dragged.
        value: false,
        notify: true
      },
      size: {
        type: String,
        value: '',
        notify: true,
        observer: '_sizeChanged'
      },
      minSize: {
        type: String, // Minimum width to which the splitter target can be sized, e.g. `minSize="100px"`
        value: '', 
        notify: true
      },
      target: { 
        observer: '_targetChanged',
        readOnly: true
      }
  }, ready: function () {
    this._directionChanged();
    if (!this.allowOverflow) {
      this.set('parentNode.style.overflow', 'hidden');
      this.set('nextElementSibling.style.overflow', 'hidden');
      this.set('previousElementSibling.style.overflow', 'hidden');
    }
  }, _directionChanged: function () {
    this._is_next = this.direction === 'right' || this.direction === 'down';
    this._is_horizontal = this.direction === 'up' || this.direction === 'down';
    this._update();
    this.set('size', (parseInt(getComputedStyle(this.target)[this._dimension]) || 0 ) + "px");
  }, _update: function () {
    this._setTarget(this._is_next ? this.nextElementSibling : this.previousElementSibling);
    this._dimension = this._is_horizontal ? 'height' : 'width';
    let el = Polymer.dom(this).parentNode;

    // The maximum size is given by the height of the parent, minus all the unshrinkable
    // elements within the parent (for example the splitter itself is unshrinkable).
    // Note that this is a bit hacky.
    let max_size = el.getBoundingClientRect()[this._dimension];
    let range = document.createRange();
    el = el.firstChild;
    while(el){
      if(el === this.target){
         // we have control over the size of the target
      } else if (el.getBoundingClientRect){
        // regular nodes
        let style = getComputedStyle(el);
        let is_fixed_size = !parseFloat(style.flexShrink);
        let is_in_flow = !(style.position  === "absolute" || style.position === "fixed")
        if(is_fixed_size && is_in_flow){
           max_size -=  el.getBoundingClientRect()[this._dimension];
        }
      } else {
        // text nodes..
        range.selectNode(el);
        max_size -= range.getBoundingClientRect()[this._dimension];
        range.detach();
      }
      el = el.nextSibling;
    }
    this._max_size = max_size;
    Polymer.dom(this).classList.toggle('horizontal', this._is_horizontal);
  }, _targetChanged: function (_, old) {
      this.target && this.set('size', this.target.getBoundingClientRect()[this._dimension] + "px");
  }, _sizeChanged: function(new_val){
      this.target.style[this._dimension] =  new_val;

      // TODO: is this right?
      let el = Polymer.dom(this).parentNode.firstChild;
      while(el){
        (el !== this) && el.notifyResize && el.notifyResize();
        el = el.nextSibling;
      }
  }, _track: function (e) {
      if (this.locked) {
        return;
      }
      switch(e.detail.state) {
        case 'start':
          this._update();
          this.size_start = this.target.getBoundingClientRect()[this._dimension];
          break;
        case 'track':
          var d = e.detail[this._is_horizontal ? 'dy' : 'dx'];
          this.set('size', Math.min(this.size_start + (this._is_next ? -d : d), this._max_size) + 'px');
          break;
        case 'end':
          break;
      }
  }, _parent_resized: function(){
    this._update();
    this.set('size', Math.min(this.target.getBoundingClientRect()[this._dimension], this._max_size) + 'px');
  }, _preventSelection: function (e) {
    
  }, listeners: {
    'track': '_track',
    'down': '_preventSelection',
    'iron-resize': '_parent_resized'
  }
});
</script>
</dom-module>
<dom-module id="undo-stack-view" assetpath="/">

<style>
.redo,
.undo{
background: rgba(106, 119, 130, 0.08);  
margin-top: 2px;
}
.redo{
color: #1A64A5;
text-align: right;
}
:host{
max-height: 150px;
overflow: scroll;
cursor: default;
}
</style>

<template>
    <template is="dom-repeat" items="[[redo_stack]]">
        <div class="redo">([[item]])</div>
    </template>
    <template is="dom-repeat" items="{{_reversed_undo(undo_stack.splices)}}">
        <div class="undo">[[item]]</div>
    </template>
</template>


<script>
    "use strict";
    Polymer({
        is:'undo-stack-view',
        properties: {
            undo_stack: {
                type: Array,
                value: function(){return [];},
                notify: true
            },
            redo_stack: {
                type: Array,
                value: function(){return [];},
                notify: true
            }
        }, _reversed_undo: function(){
            let arr = this.undo_stack.slice(0);
            arr.reverse();
            return arr;
        }
    });
</script>

  
</dom-module><dom-module id="cut-object" assetpath="/">

<template>
    <iron-a11y-keys keys="z+only ctrl+z" on-keys-pressed="undo" target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="y+only ctrl+y" on-keys-pressed="redo" target="[[keyboard_target]]"></iron-a11y-keys>
</template>


<script>
    "use strict";

(function(){


    var bin_count = function(group_idx, max_len){
        var ret = new Uint32Array(max_len);
        for(var ii=0; ii<group_idx.length; ii++)
            ret[group_idx[ii]]++; // if group_idx is out of range it seems like no warning/error is raised, at least in chrome 49
        return ret;
    }

    var arg_split = function(groups, group_idx, group_n){
        // sort of like an arg sort followed by a split by value,
        // groups is an array of typed arrays, and group_idx is a
        // single typed_array, with each element specifiying an
        // index into the the groups array.  For each such element,
        // we record in the typed array within groups the index of
        // the element.  group_n is another typed array, which is
        // is of the same length as groups, it shoudld be zero-initialized
        // and we use it counting up the number of entries currently
        // placed into the corresponding typed array within groups.
        // note that each of the typed arrays wihtin groups should have
        // been sized in advance, probably using the bin_count function.
        for(var ii=0; ii<group_idx.length; ii++)
            groups[group_idx[ii]][group_n[group_idx[ii]]++] = ii;
    };

    var mask_split = function(a, mask){
        // splits a into two arrays, one for 0 elements in mask and one for 1 elements
        // note if mask contains other values the result will be nonsense.
        if(mask.length != a.length)
            throw "mask length mismatch";
        var counts = bin_count(mask, 2);
        var a0 = new Uint32Array(counts[0]);
        var a1 = new Uint32Array(counts[1]);
        var p0=0, p1=0;
        for(var ii=0;ii<mask.length; ii++){
            if(mask[ii])
                a1[p1++] = a[ii];
            else
                a0[p0++] = a[ii];
        }
        return [a0, a1];
    };

    var merge_sorted = function(x){
        // x is a list of arrays, each of which is internally sorted in ascending order.
        // We combine them into a sorted new array and create an accompanying array saying
        // for each element which of the source arrays was used.

        // we fill in the result in reverse, i.e. start at n-1 and go back to 0.
        let x_len = x.length;
        let n = 0;
        let p = new Uint32Array(x_len); // this will hold the index of the last used element in each array
        for(let [ii, xx] of x.entries()){
            n += xx.length;
            p[ii] = xx.length;
        }

        let dest = new Uint32Array(n);
        let src = new Uint8Array(n);
        for(let ii=n-1; ii>=0; ii--){
            // find the array with the next highest value
            let kk_choice, v=Number.MIN_SAFE_INTEGER;
            for(let kk=0; kk<x_len; kk++){
                if (p[kk] && x[kk][p[kk]-1] > v) {
                    kk_choice = kk;
                    v = x[kk][p[kk]-1];
                } 
            }

            // use it
            dest[ii] = v;
            src[ii] = kk_choice;
            p[kk_choice]--;
        }
        return [dest, src];
    }

    var merge_sorted_masked = function(x, m){
        // this is the same as merge_sorted, but each array now (may) have a mask
        // which is true where we want to pick and false where we should ignore entries

        // we fill in the result in reverse, i.e. start at n-1 and go back to 0.
        let x_len = x.length;
        let n = 0;
        let p = new Uint32Array(x_len); // this will hold the index of the (1+the_next_to_use) element in each array, i.e. 0=used all
        for(let [ii, xx] of x.entries()){
            let m_ii = m[ii];
            if(m_ii){
                // x[ii] is masked, so find out how many true elements there are and
                // record the index_of_final_true+1 in p[ii].
                p[ii] = 0;
                for(let jj=0; jj<m_ii.length; jj++){
                    m_ii[jj] && ( n++ && (p[ii] = jj+1));
                }
            } else {
                // no mask, so use full length of src
                n += xx.length;
                p[ii] = xx.length;
            }
        }

        let dest = new Uint32Array(n);
        let src = new Uint8Array(n);
        for(let ii=n-1; ii>=0; ii--){
            // find the array with the next highest value
            let kk_choice, v=Number.MIN_SAFE_INTEGER;
            for(let kk=0; kk<x_len; kk++){
                if (p[kk] && x[kk][p[kk]-1] > v) {
                    kk_choice = kk;
                    v = x[kk][p[kk]-1];
                } 
            }

            // use it
            dest[ii] = v;
            src[ii] = kk_choice;
            let m_choice = m[kk_choice];
            if(m_choice){
                // mask, so decrement until we are *about* to hit the next true element
                while(--p[kk_choice] && !m_choice[p[kk_choice] - 1]);
            } else {
                // no mask, so just decrement
                p[kk_choice]--; 
            }

        }
        return [dest, src];
    }

    var labeled_split = function(src, labels, dests_in){
        // this is the inverse of merge_sorted_masked...and it's even more complicated...
        //
        // labels is an array of the same length as src, saying where to put
        // each element. dests_in is a list of pre-existing arrays into which to
        // insert the values from src, maintaining ascending-order sort in each
        // dest array.  One or more of dests_in may be null, in which case we
        // simply accumalte the relevant values from src in a new array.
        // In addition to the augmented dests arrays, this returns an equally
        // long list giving a mask for each array (or null), giving true
        // for elements that were originally in src.

        let dest_len = dests_in.length;

        // work out the length of each array in dests_out
        let dests_out = [];
        let masks_out = [];
        let n = new Uint32Array(dest_len);
        for(let ii=0; ii<src.length; ii++){
            n[labels[ii]]++;
        }
        for(let [ii, dd] of dests_in.entries()){
            n[ii] += dd ? dd.length : 0;
            dests_out.push(new Uint32Array(n[ii]));
            masks_out.push(dd ? new Uint8Array(n[ii]) : null);
        }

        // unlike merge_sorted_masked we do this in the forward dircetion 
        // (becuase it's complicated enough already!)

        n.fill(0); // we repurpose it...
        let p_in = n;
        let p_out = new Uint32Array(dest_len);
        for(let ii=0; ii<src.length; ii++){
            let v = src[ii];
            let k = labels[ii];
            let dest_in = dests_in[k];
            let dest_out = dests_out[k];
            if(dest_in){
                // merge-sort into existing dest_in
                while(p_in[k] < dest_in.length && dest_in[p_in[k]]<v){
                    dest_out[p_out[k]++] = dest_in[p_in[k]++]; 
                    // mask is left as 0
                }
                masks_out[k][p_out[k]] = 1; 
                dest_out[p_out[k]++] = v;
            } else {
                // creating dest_out from scratch...
                dest_out[p_out[k]++] = v;                
            }
        }

        // use up any final values in dests_in..
        for(let ii=0; ii<dest_len; ii++){
            let dest_in = dests_in[ii];
            if(!dest_in){
                continue;
            }
            let dest_out = dests_out[ii];
            for(let p=p_in[ii]; p<dest_in.length; p++){
                dest_out[p_out[ii]++] = dest_in[p]; 
                // mask is left as 0
            }
        }
        return [dests_out, masks_out];
    }  

    var take_masked = function(x, m, take_true){
        // returns the elements of x where m is true, unless take_true if falsy in which
        // case it's the false elements of m that are taken from x.
        if(take_true){
            let n = 0;
            for(let ii=0; ii<x.length; ii++) {
                (m[ii]) && (n++); 
            }
            let res = new Uint32Array(n);
            for(let ii=0, p=0; ii<x.length; ii++) {
                (m[ii]) && (res[p++] = x[ii]);
            }
            return res;
        } else {
            let n = 0;
            for(let ii=0; ii<x.length; ii++) {
                (!m[ii]) && (n++); 
            }
            let res = new Uint32Array(n);
            for(let ii=0, p=0; ii<x.length; ii++) {
                (!m[ii]) && (res[p++] = x[ii]);
            }
            return res;
        }
    }

    var arange = function(n){
        var ret = new Uint32Array(n);
        for(var ii=0; ii<n; ii++)
            ret[ii] = ii;
        return ret;
    }

    var CutStackState = function(that){
        this.is = "stack";
        this.id = null; // a kind of invalid fkey
        this.undo_stack_descriptions = that.undo_stack_descriptions;
        this.redo_stack_descriptions = that.redo_stack_descriptions;
        this.groups = that.groups;
        this.undo_stack = that.undo_stack;
        this.redo_stack = that.redo_stack;
        this.painter_state = that.painter_state;
        return this;
    }

    CutStackState.prototype.get_blob_url = function(experiment_name){
        // This methods is called by file-organiser when dragging starts

        // build the 1d array that gives the group number for each spike...

        // I'm not sure if total n_spikes is already avialble somehwere, but hey...
        var n_spikes = 0;
        for(let gg of this.groups){
            n_spikes += gg && gg.n_spikes;
        }

        var the_cut = new Uint8Array(n_spikes);
        for(let ii=0; ii<this.groups.length; ii++){
            let gg = this.groups[ii];
            if(!gg){
                continue;
            }
            let inds = gg.akey.array;
            for(let jj=0; jj<inds.length; jj++){
                the_cut[inds[jj]] = ii;
            }
        }

        // and now construct the string
        let str = ['n_clusters: ' + this.groups.length,
                   'n_channels: 4',
                   'n_params: 0',
                   'times_used_in_Vt: 0 0 0 0'];

        for(let ii=0; ii<this.groups.length; ii++){
            str.push(' cluster: ' + ii + ' center: 0 0 0 0 0 0 0 0');
            str.push(' min:   0 0 0 0 0 0 0 0');
            str.push(' max:   0 0 0 0 0 0 0 99');
        }
        str.push('');
        str.push('Exact_cut_for: '+ experiment_name +' spikes: ' + n_spikes);
        str.push('');
        str = str.join('\n') + Array.prototype.join.call(the_cut, ' ');

        var b = new Blob([str], {type: 'text/plain'}); 
        return window.URL.createObjectURL(b);
    }

    Polymer({
        is:'cut-object',
        properties: {
            undo_stack_descriptions: {
                type: Array,
                value: function(){return [];},
                notify: true
            },
            redo_stack_descriptions: {
                type: Array,
                value: function(){return [];},
                notify: true
            },
            groups: {
                type: Array,
                value: function(){return [];},
                notify: true
            },
            painter_state: {
                type: Object,
                notify: true,
                value: function(){return {};}
            },
            cut_box: {
                type: Object,
                value: function(){return {};},
                notify: true,
                observer: '_use_cut_box'
            },
            keyboard_target: {
                type: Object,
                value: function(){return document.querySelector('body');}
            }
        }, _make_okey: function(inds, num){
            return {

                group_num: num,
                
                // The indices are immutable for the lifetime of this object
                akey: Utils.typed_array_manager.to_akey(inds),

                // The following properties are visualized by the tile element
                // and must thus be notified when changes are made.  Note that
                // for efficiency of notification, the rm is always changed in
                // its entirerity, i.e. a new object is assigned.
                n_spikes: inds.length,
                tac: "",
                waves: "",
                rm: { 
                    spa_max: "",
                    dir_max: "",
                    dir: null,
                    spa: null,
                    speed: null
                },

                // private properties for use by tac-plots module, never notified
                _tac_other: null,
                _tac_other_options: {},
                _tac_is_on_worker: false,

                // private properties for use by rm-plots module, never notified
                _rm_spa_other: null,
                _rm_spa_max_other: null,
                _rm_dir_other: null,
                _rm_dir_max_other: null,
                _rm_speed_other: null,
                _rm_other_options: {},
                _rm_is_on_worker: false,

                // property set by Polymer.Collection
                _pkey: null 
            };
        }, _use_cut_box: function(){
            if (this.cut_box && this.cut_box.is === "file"){
                // construct from file
                let akey = this.cut_box.akey.array;

                // find out how many indices for each group
                let group_n = bin_count(akey, 255);

                // zero-initialize an array of the required length for each group
                let groups = [];
                for(let ii=0; ii<group_n.length; ii++) if(group_n[ii]>0){
                    groups[ii] = new Uint32Array(group_n[ii]);
                }

                // store the indices for each group
                group_n.fill(0); // we repurpose this as a counter during arg_splitting
                arg_split(groups, akey, group_n);

                // now we are ready to create the this.groups array of okeys               
                let okeys = [];
                for(let [ii, gg] of groups.entries()){
                    if(gg){
                        okeys.push(this._make_okey(gg, ii));
                    }else{
                        okeys.push(null);
                    }
                }
                this.undo_stack = [{
                    action: 'load'
                }];

                this.set('groups', okeys); 
                this.set('undo_stack_descriptions', ['load from file']);
                this.set('redo_stack_descriptions', []);
                this.redo_stack = [];
                this.set('painter_state', {
                    dest: 1,
                    srcs: [0]
                });

            } else if (this.cut_box && this.cut_box.is === "stack"){
                // reinstate existing cut object
                this.set('groups', this.cut_box.groups);
                this.set('undo_stack_descriptions', this.cut_box.undo_stack_descriptions);
                this.set('redo_stack_descriptions', this.cut_box.redo_stack_descriptions);
                this.undo_stack = this.cut_box.undo_stack;
                this.redo_stack = this.cut_box.redo_stack;
                this.set('painter_state', this.cut_box.painter_state);

            } else if(this.cut_box && this.cut_box.is === "n"){
                // no cut_file, so just make a zero-group with inds 0:n 
                this.undo_stack = [{
                    action: 'create'
                }];
                this.set('undo_stack_descriptions', ['create blank cut']);
                this.set('redo_stack_descriptions', []);
                this.set('groups', [this._make_okey(arange(this.cut_box.n_spikes), 0)], 0);
                this.undo_stack = [];
                this.redo_stack = [];
                this.set('painter_state', {
                    dest: 1,
                    srcs: [0]
                });

            } else {
                // clear current state
                this.set('groups', []);
                this.set('undo_stack_descriptions', []);
                this.set('redo_stack_descriptions', []);
                this.undo_stack = [];
                this.redo_stack = [];
                this.set('painter_state', {
                    dest: 0,
                    srcs: [0]
                });
            }
        }, _fork_if_needed: function(){
            if(this.cut_box.is !== "stack"){
                // tell the file-organiser to construct a new "cut box" from the preservable state of this element.
                // note that the new "cut box" will be applied to this element as its cut_box, but this will not
                // cause any changes as all the values will be the same.

                // we could hold the reference directly, but it complciates matters when doing bulk updates of trials
                let new_cut = new CutStackState(this); 
                this.fire('fork', new_cut);
            }
        }, swap_groups: function(a, b){
            if(a==b) return;
            this._fork_if_needed();

            // make life easier, fix b>a
            if(a>b){
                var tmp = a;
                a = b;
                b = tmp;
            }
            if(!(this.groups[a] || this.groups[b])){
                return; // at least one of the groups should actually exist
            }
            this._do_swap(a, b);

            this.redo_stack.splice(0, this.redo_stack.length); // clear     
            this.undo_stack.push({
                action: 'swap',
                a: a,
                b: b
            });
            this.splice('redo_stack_descriptions', 0, this.redo_stack_descriptions.length); // clear
            this.push('undo_stack_descriptions', 'swap groups ' + a + " and " + b);
        }, _do_swap: function(a, b){
            // b must be greater than a

            // b could be off beyond the end of the array as it currently stands
            while(b>=this.groups.length){
                this.push('groups', null);
            }

            let group_a = this.groups[a];
            let group_b = this.groups[b];
            // update group_nums in preparation for announcing splice
            group_a && (group_a.group_num = b);
            group_b && (group_b.group_num = a);

            // TODO: check that this really is the correct way to do it
            // https://github.com/Polymer/polymer/issues/3377
            this.groups.splice(a, 1, group_b);
            this.groups.splice(b, 1, group_a); 
            this.notifySplices('groups',[
                {index: a, removed: [group_a], addedCount: 0, object: this.groups, type:'splice'},
                {index: b-1, removed: [group_b], addedCount: 0, object: this.groups, type:'splice'},
                {index: a, removed: [], addedCount: 1, object: this.groups, type:'splice'},
                {index: b, removed: [], addedCount: 1, object: this.groups, type:'splice'}
            ]); 
        }, split_group: function(a, mask){
            this._fork_if_needed();

            var new_arrs = mask_split(this.groups[a].akey.array, mask);
            // update group_nums in preparation for announcing splice
            for(let ii=a+1; ii<this.groups.length; ii++){
                this.groups[ii] && (this.groups[ii].group_num = ii+1);
            }
            this.splice('groups', a, 1, this._make_okey(new_arrs[0], a), this._make_okey(new_arrs[1], a+1));
            this.redo_stack.splice(0, this.redo_stack.length); // clear                   
            this.undo_stack.push({
                action: 'split',
                a: a
            });

            this.splice('redo_stack_descriptions', 0, this.redo_stack_descriptions.length); // clear
            this.push('undo_stack_descriptions', 'split group ' + a + ' in two');
        }, merge_groups: function(a, b){
            // the higher-numbered group is merged into the lower number
            this._fork_if_needed();

            // make life easier, fix b>a
            if(a>b){
                var tmp = a;
                a = b;
                b = tmp;
            }

            var packed = merge_sorted([this.groups[a].akey.array, 
                                       this.groups[b].akey.array])
            var inds = packed[0], mask = packed[1];

            this.splice('groups', b, 1, null);
            this.splice('groups', a, 1, this._make_okey(inds, a));

            this.redo_stack.splice(0, this.redo_stack.length); // clear
            this.undo_stack.push({
                action: 'merge',
                a: a,
                b: b,
                mask: mask
            });
            this.splice('redo_stack_descriptions', 0, this.redo_stack_descriptions.length); // clear
            this.push('undo_stack_descriptions', 'merge groups ' + a + ' and ' + b);
        }, transplant_groups: function(dest, src_masks){
            let src_nums = [];
            for(let num in src_masks){
                src_nums.push(num);
            }
            if(!src_nums.length){
                return;
            }

            this._fork_if_needed();

            while(dest >= this.groups.length){
                this.push('groups', null);
            }

            let delta = {
                action: 'transplant',
                dest: dest,
                src_masks: src_masks 
            }

            let valid = this._do_transplant(delta); // this applies the delta and inverts the data stored within it
            if(!valid){
                return;
            }
            this.undo_stack.push(delta);


            // TODO: sort src_nums
            this.push('undo_stack_descriptions', 'paint into group ' + dest + ' from group' +
                                                    (src_nums.length > 1? 's [' + src_nums.join(",")  +']' : ' ' + src_nums[0]));
            this.splice('redo_stack_descriptions', 0, this.redo_stack_descriptions.length); // clear
            this.redo_stack.splice(0, this.redo_stack.length); // clear

        }, _do_transplant: function(delta){
            let dest_group = this.groups[delta.dest];
            // we need to do a merge-sort on all the masked srcs and dest indicies

            // we prepare two lists, one of indices and one of masks for those indices.
            // we also splice out the src groups and replace with their diminished verions
            let x = [(dest_group && dest_group.akey.array) || new Uint32Array(0)];
            let x_mask = [null];
            let src_nums = []; // used in undo delta and in undo description
            for(let group_num in delta.src_masks){
                group_num = parseInt(group_num);
                let g = this.groups[group_num];
                if(!g){
                    throw "transplant: src 'group " + group_num + "' doesn't exist.";
                }
                x.push(g.akey.array)
                x_mask.push(delta.src_masks[group_num]);

                let new_inds = delta.src_masks[group_num] ? 
                                    take_masked(g.akey.array, delta.src_masks[group_num], false)
                                   : null;
                this.splice('groups', group_num, 1, new_inds && new_inds.length ? 
                                this._make_okey(new_inds, group_num) : null); // if group is empty we delete it
                src_nums.push(group_num); 
            }
            let res = merge_sorted_masked(x, x_mask); // this combines everything
            
            if(!res[0].length){
                return false; // nothing actually was transfered
            }

            // and now we can update the dest group
            this.splice('groups', delta.dest, 1, this._make_okey(res[0], delta.dest));

            delta.src = res[1]; // remember that src[ii]=0 means element ii was originally in dest group,
                               // and src[ii]=v means that element ii was oritinally in src_nums[v+1] group.
            delta.src_nums = src_nums;
            delete delta['src_masks']; // don't need this any more

            return true;

        }, _undo_transplant: function(delta){
            let src_inds = [null];
            for(let group_num of delta.src_nums){
                src_inds.push(this.groups[group_num] && this.groups[group_num].akey.array);
            }
            let res = labeled_split(this.groups[delta.dest].akey.array, delta.src, src_inds);

            this.splice('groups', delta.dest, 1, res[0][0].length ? this._make_okey(res[0][0], delta.dest) : null);

            let src_masks = {}; // this will be the same as originally povided to transplant
            for(let [ii, group_num] of delta.src_nums.entries()){
                src_masks[group_num] = res[1][ii+1]; // +1 because the 0th entry is the dest
                this.splice('groups', group_num, 1, res[0][ii+1].length ? this._make_okey(res[0][ii+1], group_num) : null)
            }
            delta.src_masks = src_masks;
            delete delta['src']; //we don't need these any more..
            delete delta['src_nums'];

        }, undo: function(){
            var delta = this.undo_stack[this.undo_stack.length-1];
            var success = false;

            // note that b will always be greater than a...
            switch(delta.action){
                case "merge":
                var new_arrs = mask_split(this.groups[delta.a].akey.array, delta.mask);
                this.splice('groups', delta.a, 1, this._make_okey(new_arrs[0], delta.a));
                this.splice('groups', delta.b, 1, this._make_okey(new_arrs[1], delta.b));
                delete delta['mask']; // not absolutely neccessary, but we don't need it now
                success = true;
                break;

                case "split":
                // we could have kept the mask originally, but we didn't
                var packed = merge_sorted([this.groups[delta.a].akey.array, 
                                           this.groups[delta.a+1].akey.array])
                var inds = packed[0];
                // update group_nums in preparation for announcing splice
                for(let ii=delta.a+1; ii<this.groups.length; ii++){
                    this.groups[ii] && (this.groups[ii].group_num = ii-1);
                }
                this.splice('groups', delta.a, 2, this._make_okey(inds, delta.a));
                delta.mask = packed[1];
                success = true;
                break;

                case "swap":
                this._do_swap(delta.a, delta.b);
                success = true;
                break;

                case "transplant":
                this._undo_transplant(delta); // it's complicated so it gets its own function
                success = true;
                break;

                default:
                console.log("attempted undo of unknown or invalid delta");
            }

            if(success){
                // note we hadn't yet actually removed the delta from the undo stack
                this.redo_stack.push(this.undo_stack.pop())
                this.push('redo_stack_descriptions', this.pop('undo_stack_descriptions'));
            }

        }, redo: function(){
            var delta = this.redo_stack[this.redo_stack.length-1];
            if(!delta)
                return;
            var success = false;

            // note that b will always be greater than a...
            switch(delta.action){
                case "merge":
                var packed = merge_sorted([this.groups[delta.a].akey.array, 
                                           this.groups[delta.b].akey.array]);
                var inds = packed[0];
                this.splice('groups', delta.b, 1, null);
                this.splice('groups', delta.a, 1, this._make_okey(inds, delta.a));
                delta.mask = packed[1];
                success = true;
                break;

                case "split":
                // we could have kept the mask originally, but we didn't
                var new_arrs = mask_split(this.groups[delta.a].akey.array, delta.mask);
                delete delta['mask'];
                for(let ii=delta.a+1; ii<this.groups.length; ii++){
                    this.groups[ii] && (this.groups[ii].group_num = ii+1);
                }
                this.splice('groups', delta.a, 1, this._make_okey(new_arrs[0], delta.a), this._make_okey(new_arrs[1], delta.a+1));
                success = true;
                break;

                case "swap":
                this._do_swap(delta.a, delta.b);
                success = true;
                break;

                case "transplant":
                this._do_transplant(delta); // it's complicated so it gets its own function
                success = true;
                break;

                default:
                console.log("attempted redo of unknown or invalid delta");  
            }
            if(success){
                // note we hadn't yet actually removed the delta from the redo stack
                this.undo_stack.push(this.redo_stack.pop())
                this.push('undo_stack_descriptions', this.pop('redo_stack_descriptions'));
            }
        }
    });

})();
</script>

  
</dom-module><script id="worker_extra" type="javascript/worker">


// issues requests from main thread to functions on worker thread
self.onmessage = function(e){
    if(e.data.foo && self[e.data.foo]){
        if(e.data.bufs){
            var buffers = {};
            for(var ii=0; ii<e.data.bufs.length; ii++){
                var item = e.data.bufs[ii];
                buffers[item.name] = item.constructor === "ArrayBuffer" ? item.buffer : new self[item.constructor](item.buffer);
            }
            for(var ii=0; ii<e.data.undefineds.length; ii++){
                buffers[e.data.undefineds[ii]] = undefined;
            }
            e.data.args.push(buffers);
        }
        self[e.data.foo].apply(null, e.data.args);
    } else if (e.data.foo === '_ports'){
        var a = {};
        for(var ii=0; ii< e.ports.length; ii++){
            a[e.data.args[ii]] = e.ports[ii];
        }
        self.got_ports(a);
    }else {
        throw "worker '" + self._title + "' got bad message: " + (e.data && e.data.foo ? e.data.foo : JSON.stringify(e.data));
    }
};


// Send back to main
var exec_main = function(/*arguments*/){
    self.postMessage({
        foo: arguments[0],
        args: Array.prototype.slice.call(arguments, 1)
    });
};
 
// Send back to main with buffers
var exec_main_b = function(/*arguments*/){
    var msg = {
        foo: arguments[0],
        args: Array.prototype.slice.call(arguments,1, arguments.length-1),
        bufs: []
    };
    var x = arguments[arguments.length-1] || {};
    var buffers = [];

    // x is a map from labels to typedarrays
    for(var k in x)if(x.hasOwnProperty(k)){
        buffers.push(x[k].buffer);
        msg.bufs.push({
            buffer: x[k].buffer,
            name: k,
            constructor: x[k].constructor.name
        });
    }
    self.postMessage(msg, buffers);
};


 // Add basic console support
 var console = {
    log: function(){
        self.postMessage({
            foo:'console.log',
            args: Array.prototype.slice.call(arguments, 0)
        });
    }
 };


 // typed array debug function, from worker thread, use as:
 //    set_array_on_main_window(my_int16_array, "thing")
 // This will set window.thing as a copy of my_int16_array. 
 // Works for any array with a .constructor property which can be found
 // by name on the window in the main thread.
 // see also exec_b
  var set_array_on_main_window = function(x, name){
    var buffer = x.buffer.slice(0);
    self.postMessage({
        foo: 'set_array_on_main_window',
        args: [buffer, name, x.constructor.name, [buffer]]
    });
 }; 


 // Add setImmediate and clearImmediate.
 // see https://github.com/YuzuJS/setImmediate/blob/master/setImmediate.js 
 // and https://developer.mozilla.org/en-US/docs/Web/API/Window/setImmediate
 // this version doesn't bother accepting args.
(function(){
    var last_task_h=0;
    var tasks = {};
    self._immediate_channel = new MessageChannel();
    _immediate_channel.port1.onmessage = function(e) {
        var h = e.data;
        try {
            tasks[h] && tasks[h]();
        } finally {
            clearImmediate(h);
        }
    }
    self.setImmediate = function(cb) {
        tasks[++last_task_h] = cb;
        _immediate_channel.port2.postMessage(last_task_h);
        return last_task_h;
    }
    self.clearImmediate = function(h){
        delete tasks[h];
    }
})();


// often helpful to have when doing compute stuff
var endian = function(){
    var b = new ArrayBuffer(2);
    (new DataView(b)).setInt16(0,256,true);
    return (new Int16Array(b))[0] == 256? 'L' : 'B';
}();

// call created user funciton if it exists
self.created && self.created();
</script>


<script>
    "use strict";
    var worker_extra =  document.currentScript.previousElementSibling.textContent; //  note polyfilled as _currentScript in webcomponents

    var BuiltWorker = function(url, title, listener){
        this._worker = new Worker(url);
        this._listener = listener;
        this._title = title;
        this._worker.onmessage = this._onmessage.bind(this);
        return this;
    }
    
    BuiltWorker.prototype.exec = function(/*arguments*/){
        this._worker.postMessage({
            foo: arguments[0],
            args: Array.prototype.slice.call(arguments, 1)
        })
    }

    BuiltWorker.prototype.exec_b = function(/*arguments*/){
        var msg = {
        foo: arguments[0],
        args: Array.prototype.slice.call(arguments, 1, arguments.length-1),
        bufs: [],
        undefineds: []
        };
        var x = arguments[arguments.length-1] || {};
        var buffers = [];
        // x is a map from labels to typedarrays
        for(var k in x)if(x.hasOwnProperty(k)){
            if(x[k] && x[k].buffer){
                buffers.push(x[k].buffer);
                msg.bufs.push({
                    buffer: x[k].buffer,
                    name: k,
                    constructor: x[k].constructor.name
                });
            } else {
                msg.undefineds.push(k);
            }
        }
        this._worker.postMessage(msg, buffers);
    }

    BuiltWorker.prototype._onmessage = function(e){
        if(!e.data || !e.data.foo)
            throw "bad message recieved on main thread from built worker '" + this._title + "'."
        if(e.data.bufs){
            var buffers = {};
            for(var ii=0; ii<e.data.bufs.length; ii++){
                var item = e.data.bufs[ii];
                buffers[item.name] = new window[item.constructor](item.buffer);
            }
            e.data.args.push(buffers);
        }
        var foo = e.data.foo;
        try{
            this._listener[foo].apply(this._listener, e.data.args);
        }catch(err){
            if(foo === "console.log"){
                console.log.apply(console, e.data.args);
            } else if(foo === "set_array_on_main_window"){
                window[e.data.args[1]] = new window[e.data.args[2]](e.data.args[0]);
            } else {
                throw err;
            }
        }
    }

    BuiltWorker.prototype.send_ports = function(a){
        // a is a map from port name to port,
        // i.e. analgous to the last arg in exec_b.
        var ports = [];
        var names = [];
        for(var k in a){
            ports.push(a[k]);
            names.push(k);
        }
        this._worker.postMessage({
            foo: '_ports',
            args: names,
        }, ports);

    }

    Polymer({
        is:'worker-builder',
        extends: 'script',
        properties: { 
            title: {
                type: String,
                value: "Untitled"
            },
            url: {
                type: String,
                value: ""
            },
        },
        observers: [ ],
        ready: function(){
            var user_code = this.root.textContent;
            var full_code = "/* ===================\n\n" + this.title + " (worker constructed with worker-builder)" +
                            "\n\n =================== */\n\n\n" + user_code + 
                            "\n\n/* ======================================================== */\n" + 
                            "self._title='" + this.title + "';\n\n" +  worker_extra;
            this.set('url',  window.URL.createObjectURL(new Blob([full_code],
                                                         {type:'text/javascript'})));
        },
        create_for: function(that){
            return new BuiltWorker(this.url, this.title, that);
        },
    });

</script>

<dom-module id="parsed-data" assetpath="/">

<script is="worker-builder" id="io_worker" title="io-worker" type="javascript/worker">
"use strict";

var timer = 0;
var ports = {};
var pending_files = {};
var pending_fkeys = {};
var pending_options = {};
var types = ['tet', 'set', 'pos', 'cut']; // this is the priority order
var parsers_cached_fkeys = {
    tet: new Set(), // tracks which fkeys tet worker currently holds in its cache buffers
    pos: new Set() // same for pos
}
var max_cache_size = 4; // pretty arbitrary, especially as it's not type-specific
var currently_reading;

var got_ports = function(ports_){
    ports = ports_;
    for(let t of types){
        let t_local = t;
        ports[t].onmessage = function(e){
            if(e.data !== 'done reading'){
                throw "bad message from " + t + " to io worker: " + JSON.String(data);
            }
            if (currently_reading === t_local){
                currently_reading = undefined;
                touch_timer();
            }
        }
    }
}

var read_files = function(files, options){
    for(let t of types){
        if(files[t] !== undefined){
            pending_files[t] = files[t];
            pending_options[t] = options[t];
            pending_fkeys[t] = files[t+'_fkey'];
        }
    }
    touch_timer();
}

var touch_timer = function(){
    for(let t of types){
        if(pending_files[t]){
            timer = timer || setImmediate(timer_tick);
            return;
        }
    }
    clearImmediate(timer);
    timer = 0;
}

var timer_tick = function(){
    timer = 0;
    // if there are any files already cached, then issue those requests immediately
    for(let t of types){
        if(!pending_files[t] || !parsers_cached_fkeys[t]){
            continue;
        }
        let file = pending_files[t];
        let fkey = pending_fkeys[t];
        let cache = parsers_cached_fkeys[t];
        if(cache.has(fkey)){
            // bump in FIFO
            cache.delete(fkey); 
            cache.add(fkey); 
            ports[t].postMessage({
                fkey: fkey,
                name: file.name,
                file: null, // buffer is available at the reciever's end!!
                options: pending_options[t],
                delete_from_cache: null 
            });
            pending_files[t] = undefined;
            pending_fkeys[t] = undefined;
            pending_options[t] = undefined;
        }
    }

    if(currently_reading){
        return; // and do not touch_timer, instead wait for the message from the current reader or from main thread
    }

    // now, load zero or one files from disk and issue request to corresponding worker
    // crucially, we do this in the priority order defined by the types array
    for(let t of types){
        if(!pending_files[t]){
            continue;
        }
        let file = pending_files[t];
        let fkey = pending_fkeys[t];
        let cache = parsers_cached_fkeys[t];
        let delete_from_cache;
        if(cache){
            // note that fkey can't have been in the cache already, because we tested for that in the above loop.
            cache.add(fkey);
            if(cache.size > max_cache_size){
                delete_from_cache = cache.keys().next().value;
                cache.delete(delete_from_cache);
            }
        }
        currently_reading = t; // see note about Chrome bug at top of page
        //let reader = new FileReaderSync();  
        //let buf = reader.readAsArrayBuffer(file);
        ports[t].postMessage({
            fkey: fkey,
            name: file.name,
            file: file,
            options: pending_options[t],
            delete_from_cache: delete_from_cache
        });
        pending_files[t] = undefined;
        pending_options[t] = undefined;
        pending_fkeys[t] = undefined;
        break;
    }

    // and keep going...
    touch_timer();
}
</script>


<script is="worker-builder" id="pos_parser" title="pos-parser" type="javascript/worker">
"use strict";

var fkey_to_buffer = new Map();
var main_cached_opts = new Set(); // set of objects each giving options and fkey
var max_cache_size = 4; // arbitrary

var got_ports = function(ports){
    self.io_port = ports.pos;
    io_port.onmessage = function(e){
        var fkey = e.data.fkey;
        var buffer = fkey_to_buffer.get(fkey);
        if(!buffer){
            // see note at top of page on Chrome bug
            let reader =  new FileReaderSync();  // see note about Chrome bug at top of page
            buffer = reader.readAsArrayBuffer(e.data.file);
        }
        io_port.postMessage('done reading');

         // add/delete entries in buffer cache, based on instructions from io-worker
        fkey_to_buffer.set(fkey, buffer);
        if(e.data.delete_from_cache){
            fkey_to_buffer.delete(e.data.delete_from_cache);
        }

        // check to see if main cache actually holds the requested data     
        var options = e.data.options;
        options.fkey = fkey;
        for(let cached_opts of main_cached_opts){
            if(is_equal_simple(cached_opts, options)){
                // bump in FIFO
                main_cached_opts.delete(cached_opts);
                main_cached_opts.add(cached_opts);
                return; // nothing to be done
            }
        }
        
        // pre-emptively add to the record of main cache and decide what, if anything, to remove
        main_cached_opts.add(Object.assign({}, options));
        var delete_from_cache;
        if(main_cached_opts.size > max_cache_size){
            delete_from_cache = main_cached_opts.keys().next().value;
            main_cached_opts.delete(delete_from_cache);
        }

        parse_pos_file(buffer, fkey, options, e.data.name, delete_from_cache);

    }
}


var is_equal_simple = function(a, b){
    // very simple....
    if((a && !b) || (!a && b)){
        return false;
    }
    for(let aa in a){
        if(b[aa] !== a[aa]){
            return false;
        }
    }
    for(let bb in b){
        if(b[bb] !== a[bb]){
            return false;
        }
    }
    return true;
}

var swap_16 = function (val) {
    return ((val & 0xFF) << 8) | ((val >> 8) & 0xFF);
}

var take_2_2_swapped = function(src, offset_bytes, stride_bytes){
    // takes 4 bytes total, swapping bytes 0 and 1, and swapping bytes 2 and 3.

    var dest = new Uint32Array( (0 | (src.length/stride_bytes)) - (0 | (offset_bytes/stride_bytes)));

    for(let p_src=offset_bytes, p_dest=0; p_src<src.length;p_src=p_src+stride_bytes,p_dest++){
        dest[p_dest] =   src[p_src+1]
                       |(src[p_src+0] << 8)
                       |(src[p_src+3] << 16)
                       |(src[p_src+2] << 24);
    }
    return dest;
}

var take = function(data,offset,stride){
    // takes every stride'th element from data, starting with the offset'th element
    
    var n = data.length/stride;
    var res = new data.constructor(n);
    
    for(let i=0,j=offset;i<n;i++,j+=stride){
        res[i] = data[j];
    }
    return res;
}

var times_in_place = function(src, factor, skip_val){
    for(let i=0;i<src.length;i++)if(src[i] != skip_val){
        src[i] *= factor;
    }
}

var replace_val_in_place = function(src, find, replace){
    for(let i=0;i<src.length;i++)if(src[i] == find){
        src[i] = replace;
    }
}

var sqr = function(a){return a*a;}

var clone = function(a){ 
    if(a.slice){
        return a.slice(0); //for basic arrays and pure arraybuffer
    }else{
        return new a.constructor(a);
    }
}

var minus = function(a, b, c){
    // we subtract b and c from alternate elemetns of a, inplace, nan16 is skipped
    for(let i=0;i<a.length;i++){
        a[i] -= a[i] == nan16? 0 : b;
        i++;
        a[i] -= a[i] == nan16? 0 : c;
    }
}

const regex_header_a = /((?:[\S\s](?!\r\ndata_start))*[\S\s])(\r\ndata_start)/
const regex_header_b = /(\S*) ([\S ]*)/g

const bytes_per_pos_sample = 4 + 2 + 2 + 2 + 2 + 2 + 2 + (2 + 2) ;//the last two uint16s are numpix1 and numpix2 repeated
const nan16 = -32768; //custom nan value, equal to minimum int16 value    
const pos_nan = 1023;

var parse_pos_file = function(buffer, fkey, options, file_name, delete_from_cache){
    var top_str = new TextDecoder('utf-8').decode(buffer.slice(0, 1204+1));
    var match = regex_header_a.exec(top_str);
    if(!match){
        throw 'did not find end of header in pos file.';
    }

    var data_start = match.index + match[0].length;
    var header = {
        file: file_name
    };
    var header_str = match[0];
    while (match = regex_header_b.exec(header_str)){
        header[match[1]] = match[2];
    }

    if (header.pos_format !== "t,x1,y1,x2,y2,numpix1,numpix2"){
        throw "uncregonised pos format used in pos file";
    }
    
    // apply overrides
    for (let k in options.header_override){
        if(header[k] !== undefined){
            header[k+"_original"] = header[k];
        }
        header[k] = header_override[k];
    }

    var data_len_bytes = parseInt(header.num_pos_samples)*bytes_per_pos_sample;

    var pos = post_process(buffer, data_start, data_len_bytes, header, options);
    delete options.fkey;

    exec_main_b('got_pos',{
        fkey: fkey,
        header: header,
        options: options,
        xy: 'xy',
        dir: 'dir',
        speed: 'speed',
        delete_from_cache: delete_from_cache,
    }, {
        xy: pos.xy,
        dir: get_dir(pos),
        speed: get_speed(pos)
    });

}



var interp_xy_sub = function(xy,x_a,y_a,x_b,y_b,i,n_nans){
    //interpolates from element i-1 back to i-n_nans, where element i is x_b,y_b and element i-n_nans-1 is x_a,x_b
    var dx = (x_b-x_a)/(n_nans+1);
    var dy = (y_b-y_a)/(n_nans+1);
    for(let j=0;j<n_nans;j++){
        xy[(i-n_nans + j)*2+0] = x_a + (j+1)*dx;
        xy[(i-n_nans + j)*2+1] = y_a + (j+1)*dy; 
    }
}

var interp_xy = function(xy,n_pos){
   /* 
    Interpolates linearly across nan blocks for single xy stream.
    Does it in place.

    TODO: verify that this does exactly what we want
   */

    // Find first (x,y) that is non-nan
    for(var start=0; start<n_pos; start++){
        let ix = start*2+0;
        let iy = start*2+1;
        if(xy[ix] != nan16 && xy[iy] !=nan16)
            break;
    }

    var ix = start*2+0;
    var iy = start*2+1; 
    var x_a = xy[ix];
    var y_a = xy[iy];
    var n_nans = start; //this will cause first non-nan to be copied back through all previous nan values
    for(var i=start;i<n_pos;i++){
        let ix = i*2+0;
        let iy = i*2+1; 
        let x_b = xy[ix];
        let y_b = xy[iy];
        if(x_b == nan16 || y_b == nan16){
            n_nans++;
        }else{
            if(n_nans) 
                interp_xy_sub(xy, x_a, y_a, x_b, y_b, i, n_nans)
            x_a = x_b;
            y_a = y_b;
            n_nans = 0;
        }
    }
    
    if(n_nans) //fill end-nan values with last non-nan val
        interp_xy_sub(xy, x_a, y_a, x_a, y_a, i, n_nans);

}

var smooth_1d_in_place = function(x, stride, k){
    //box car smoothing of length 2*k + 1
    // (If we pretend the stride=1) The first few values of x will be:
    //  x[0] = (x[0] + x[1] + ... + x[k])/(k+1)
    //  x[1] = (x[0] + x[1] + ... + x[k+1])/(k+2)
    //  ... and then we get to..
    //  x[b] = (x[b-k] + ... + x[b] + ... x[b+k])/(2*k+1)
    // and then we ramp down at the end as with the start.
             
    //a couple of checks for unimplemented generalisations...
    if(stride != 2)
        throw("stride must be 2");
    if(2*k+1 > 256)
        throw("smoothing kernel max length is 256")
    if(k==0)
        return; //no smoothing

    /* Note: (a & 0xff) is (a mod 256) */
    var n = x.length/2;
    
    var circ_buff_1 = new x.constructor(256);
    var circ_buff_2 = new x.constructor(256);
    var tot_1 = 0;
    var tot_2 = 0;
    
    //a is the lowest-index in the sum, b is the central and destination index, c is the highgest index in the sum
    var a=-2*k,b=-k,c=0; 
    
    // ramp up part 1: push the first k values into the buffer and sum
    for(;c<k;a++,b++,c++){
        tot_1 += circ_buff_1[c & 0xff] = x[c*2 + 0]; 
        tot_2 += circ_buff_2[c & 0xff] = x[c*2 + 1];
    }
    
    // ramp up part 2: calculate the first k values
    for(;a<0;a++,b++,c++){
        tot_1 += circ_buff_1[c & 0xff] = x[c*2 + 0]; 
        tot_2 += circ_buff_2[c & 0xff] = x[c*2 + 1];
        x[b*2+0] = tot_1 / (c+1);
        x[b*2+1] = tot_2 / (c+1);
    }
        
    // main section
    var d = 2*k+1;
    for(;c<n;a++,b++,c++){
        tot_1 += circ_buff_1[c & 0xff] = x[c*2 + 0]; 
        tot_2 += circ_buff_2[c & 0xff] = x[c*2 + 1];
        x[b*2+0] = tot_1/d;
        x[b*2+1] = tot_2/d;
        tot_1 -= circ_buff_1[a & 0xff]; 
        tot_2 -= circ_buff_2[a & 0xff];
    }
    
    // ramp down: calculate last k values
    for(;b<n;a++,b++,c++){
        x[b*2+0] = tot_1 / (n-a);
        x[b*2+1 ] = tot_2 / (n-a);
        tot_1 -= circ_buff_1[a & 0xff]; 
        tot_2 -= circ_buff_2[a & 0xff];
    }
    
}

var jump_filter = function(xy, n_pos, max_speed, units_per_m, pos_timebase){
    /*
        For a single stream of xy values, it finds the first non-nan point,
        and then checks the speed required to reach the next point, given the
        sampling rate.  If the speed is too high, it skips that point and calcualtes
        the speed required to get to the following point. This continues until,
        the speed requirement is satisfied. The "skipped" points are set to NaN, inplace.
        The number of points skipped over is returned as an integer.
    */

    if(!max_speed)
        return 0;

    var sqr_max_samp_step = sqr(max_speed*units_per_m /pos_timebase);

    // Find first (x,y) that is non-nan
    for(var start=0; start<n_pos; start++){
        let ix = start*2+0;
        let iy = start*2+1;
        if(xy[ix] != nan16 && xy[iy] !=nan16)
            break;
    }
            
    var ix = start*2+0;
    var iy = start*2+1;     
    var x_from = xy[ix];
    var y_from = xy[iy];
    var jump_len = 1;

    // Set big jump sections to nan
    var n_jumpy = 0;
    for(let i=start+1; i<n_pos; i++){
        let ix = i*2+0;
        let iy = i*2+1;
        // check if this pos is already nan
        // or if (dx^2 + dy^2)/dt^2 is greater than maxSpeed^2, where the d's are relative to the last "good" sample
        if(xy[ix] == nan16 || xy[iy] == nan16){
            xy[ix] = xy[iy] = nan16; //just in case only one or the other was nan
            jump_len++; // note we don't count n_jumpy here
        }else if (sqr(x_from-xy[ix]) + sqr(y_from-xy[iy]) > sqr_max_samp_step *  sqr(jump_len)){
            //sample is nan or speed is too large, so make this a jump
            xy[ix] = xy[iy] = nan16; 
            n_jumpy++;
            jump_len++;
        }else{
            //speed is sufficiently small, so this point is ok
            jump_len = 1;
            x_from = xy[ix];
            y_from = xy[iy];
        }
    }

    return n_jumpy;
}       

var swap = function(a, b, do_swap){
    var n = 0;
    for(let i=0;i<a.length;i++) if(do_swap[i]){
        let tmp = a[i];
        a[i] = b[i];
        b[i] = tmp;
        n++;
    }
    return n;
}

var nanmean_and_std_2 = function(x){
    /* 
        x is nx2 array, we want nancount, nanmean, and nanstd for both columns.
    */

    var sum_1 = 0; var sum_2 = 0;
    var n1 = 0; var n2 = 0;

    for(let i=0; i<x.length/2; i++){
        let i1 = i*2+0;
        let i2 = i*2+1;
        if(x[i1] && x[i1] != nan16){
            n1++;
            sum_1 += x[i1];
        }
        if(x[i2] && x[i2] != nan16){
            n2++;
            sum_2 += x[i2];
        }
    }
    var mean_1 = sum_1/n1; var mean_2 = sum_2/n2;

    // now get sum(sqr(xy-mean_xy)) and use to calculate nanstd...
    sum_1 = 0; sum_2 = 0;  // NOTE: reusing sums vars!!!!
    for (let i=0; i<x.length/2; i++){
        let i1 = i*2+0;
        let i2 = i*2+1;
        if(x[i1] && x[i1] != nan16)
            sum_1 += sqr(x[i1] - mean_1);
        if(x[i2] && x[i2] != nan16)
            sum_2 += sqr(x[i2] - mean_2);
    }
    var std_1 = Math.sqrt(sum_1/n1); var std_2 = Math.sqrt(sum_2/n2);

    return {mean_1: mean_1, mean_2: mean_2, std_1: std_1, std_2: std_2, n_1: n1, n_2: n2};
}

var combine_xy = function(xy_1, xy_2, weight_1, weight_2){
    /*
        xy_1 and xy_2 are both streams of (x,y) values. 
        We combine them into a single stream according to the ratio of the weights.
    */
    var weight_sum = (weight_1 + weight_2);
    var weight_1 = weight_1/weight_sum;
    var weight_2 = weight_2/weight_sum;
    var ret = new xy_1.constructor(xy_1.length);
    for(let i=0;i<xy_1.length/2;i++){
        let ix = 2*i+0;
        let iy = 2*i+1;
        ret[ix] = xy_1[ix]*weight_1 + xy_1[ix]*weight_2;
        ret[iy] = xy_1[iy]*weight_1 + xy_1[iy]*weight_2;
    }
    return ret;
}

var get_dir = function(pos){
    var xy_1 = pos.xy_1;
    var xy_2 = pos.xy_2;
    var ret = new Float32Array(xy_1.length/2);
    var pi = 3.14159265;

    if(xy_2){
        for(let i=0;i<xy_1.length/2;i++){
            let ix = 2*i+0;
            let iy = 2*i+1;
            let dy = xy_2[iy] - xy_1[iy];
            let dx = xy_2[ix] - xy_1[ix];
            ret[i] = Math.abs(dx) < 0.001 && Math.abs(dy) < 0.001 ? NaN : (Math.atan2(dy, dx) + 2*pi) % (2*pi);
        }        
    } else {
        // only one led used...
        for(let i=1;i<xy_1.length/2;i++){
            let dy = xy_1[2*i+1] - xy_1[2*i-1];
            let dx = xy_1[2*i+0] - xy_1[2*i-2];
            ret[i] = Math.abs(dx) < 0.001 && Math.abs(dy) < 0.001 ? NaN : (Math.atan2(dy, dx) + 2*pi) % (2*pi);
        }
        ret[0] = ret[1];
    }
    return ret;
}

var get_speed = function(pos){
    var xy = pos.xy;
    var ret = new Float32Array(xy.length/2);
    for(let ii=0; ii<xy.length; ii=ii+2){
         ret[ii>>1] = Math.hypot(xy[ii+2]-xy[ii+0], xy[ii+3]-xy[ii+1]);
    }
    return ret;
}


var any_nonzero = function(x, offset, stride){
    for(let ii=offset; ii<x.length; ii+= stride){
        if(x[ii] && x[ii] != pos_nan){
            return true;
        }
    } 
    return false;
}

var compute_zscores = function(xy_pix, n_pos, mean_1, mean_2, std_1, std_2){
    var dest = new Uint8Array(n_pos);  

    for(let i=0; i< n_pos; i++){
        let i1 = i*2+0;
        let i2 = i*2+1;
        if(xy_pix[i1] && xy_pix[i2] && xy_pix[i1] != nan16 && xy_pix[i2] != nan16){
            let z11 = (mean_1 - xy_pix[i1])/std_1;
            let z12 = (xy_pix[i1] - mean_2)/std_2;
            dest[i] = z11 > z12;
        }
    }
    return dest;
}

var use_zscore = function(xy_1, xy_2, n_pos, shrunk_and_switched, swapping_thresh){
    // Find first (x,y) that is non-nan on both xy and xy_2
    let start;
    for(start=0; start<n_pos; start++){
        let ix = start*2+0;
        let iy = start*2+1;
        if(xy_1[ix] != nan16 && xy_1[iy] !=nan16 && xy_2[ix] != nan16 && xy_2[iy] !=nan16)
            break;
    }

    for(let i = start+1; i<n_pos; i++)if(shrunk_and_switched[i]){
        // we are going to do diffs with XY_i - XY_(i-1)
        let ix = i*2+0;
        let iy = i*2+1;
        let i_1x = i*2-2;
        let i_1y = i*2-1;
        if(xy_1[ix] == nan16 || xy_1[iy] == nan16 || xy_2[ix] == nan16 || xy_2[iy] == nan16){
            shrunk_and_switched[i] = 0;
            i++; // skip next iteration as well becuase the current index cannot be used as i, or as (i-1)
            shrunk_and_switched[i] = 0;
            continue; 
        }

        let dist12 = Math.hypot(xy_1[ix] - xy_2[i_1x],  xy_1[iy] - xy_2[i_1y]);
        let dist11 = Math.hypot(xy_1[ix] - xy_1[i_1x],  xy_1[iy] - xy_1[i_1y]);
        let dist21 = Math.hypot(xy_2[ix] - xy_1[i_1x],  xy_2[iy] - xy_1[i_1y]);
        let dist22 = Math.hypot(xy_2[ix] - xy_2[i_1x],  xy_2[iy] - xy_2[i_1y]);

        shrunk_and_switched[i] = (dist12 < dist11-swapping_thresh) && (dist21 < dist22 - swapping_thresh);
    }
}

var post_process = function(buffer, offset_bytes, length_bytes, header, options){
    let data8 = new Uint8Array(buffer, offset_bytes, length_bytes);

    let elements_per_pos_sample = bytes_per_pos_sample/2;
    let n_pos = parseInt(header.num_pos_samples); 
    let end = n_pos * elements_per_pos_sample; 
    
     // for each pos sample take bytes 4-7, and then view them as a pair of int16s 
    let xy_1 = new Int16Array(take_2_2_swapped(data8, 4, bytes_per_pos_sample).buffer);
    replace_val_in_place(xy_1, pos_nan,nan16); //switch from axona custom nan value to our custom nan value
    
    let n_led = 1;
    let xy_2, xy_pix;
    if (options.use_both_leds){
        // Rather than using colactive header value in set file (which is a massive pain to get asynchrously here)
        // We see if any of the pixel counts are non-zero/non-nan for the second led, to establish how many leds were used.
        xy_pix = new Int16Array(take_2_2_swapped(data8, 12, bytes_per_pos_sample).buffer);
        replace_val_in_place(xy_pix, pos_nan, nan16); //switch from axona custom nan value to our custom nan value
        n_led = any_nonzero(xy_pix, 1, 2) ? 2 : 1;

        if(n_led == 2){
             // for each pos sample take bytes 8-11, and then view them as a pair of int16s 
            xy_2 = new Int16Array(take_2_2_swapped(data8, 8, bytes_per_pos_sample).buffer);
            replace_val_in_place(xy_2, pos_nan, nan16); //switch from axona custom nan value to our custom nan value
        }
    }
    
    if(options.need_to_subtract_mins){
        var min_x = parseInt(header.window_min_x);
        var min_y = parseInt(header.window_min_y);
        minus(xy_1, min_x, min_y);
        if(n_led == 2)
            minus(xy_2, min_x, min_y);
    }

    let ppm = parseInt(header.pixels_per_metre);
    const units_per_m = 10000;
    times_in_place(xy_1, units_per_m/ppm, nan16); //convert from pixels to milimeters (we use mm because then we can happily use Int16s)
    if(n_led == 2){
        times_in_place(xy_2, units_per_m/ppm, nan16); //convert from pixels to milimeters (we use mm because then we can happily use Int16s)
    }

    let weight_1, weight_2, mean_1, mean_2, std_1, std_2;
    if(n_led == 2){
        // check for and apply LED swaping...
        let swapping_thresh = options.swapping_thresh_cm * (units_per_m/100);

        // firstly we check to see if number of pixels for first LED is actually closer to pixel count mean for second led,
        // where "closer" is defined as z-score, i.e. distance/std for the relevant distribution.
        let pix_props = nanmean_and_std_2(xy_pix);
        weight_1 = pix_props.n_1/n_pos; weight_2 = pix_props.n_2/n_pos;

        mean_1 = pix_props.mean_1; mean_2 = pix_props.mean_2; std_1 = pix_props.std_1; std_2 = pix_props.std_2;
        header.post_n_pix_led1 = "mean=" + pix_props.mean_1.toFixed(2) + " std=" + pix_props.std_1.toFixed(2) + " (nan count=" + (n_pos - pix_props.n_1) + ")";
        header.post_n_pix_led2 = "mean=" + pix_props.mean_2.toFixed(2) + " std=" + pix_props.std_2.toFixed(2) + " (nan count=" + (n_pos - pix_props.n_2) + ")";

        // use std and mean to get z score of pix1 to pix1 and pix2
        let shrunk_and_switched = compute_zscores(xy_pix, n_pos, mean_1, mean_2, std_1, std_2);

        // Now we calculate jump distance (from time i-1 to time i)
        // four distnaces: led1 to led1, led1 to led2, led2 to led1, led2 to led2.
        // if the recorded version of distance is more than swapping_thresh further
        // than the potential "swapped" version, then consider it a swap.
        use_zscore(xy_1, xy_2, n_pos, shrunk_and_switched, swapping_thresh)

        // Swap xy_1 with xy_2 where we decided we need to swap. (Note we use 32bit to swap 2x16bit xy in one go)
        header.post_n_swapped = swap(new Uint32Array(xy_1.buffer), new Uint32Array(xy_2.buffer), shrunk_and_switched);
    }
    
    let pos_timebase = parseInt(header.sample_rate);
    header.post_n_jumpy_led1 = jump_filter(xy_1, n_pos, options.max_speed, units_per_m, pos_timebase)
    if(n_led == 2){
         header.post_n_jumpy_led2 = jump_filter(xy_2, n_pos, options.max_speed, units_per_m, pos_timebase);
    }
    
    interp_xy(xy_1,n_pos);
    if(n_led == 2){
        interp_xy(xy_2,n_pos);
    }

    let k = Math.floor(pos_timebase*options.smoothing_secs/2); //the actual filter will be of length k*2+1, which means it may be one sample longer than desired         
    smooth_1d_in_place(xy_1, 2, k);
    let xy;
    if(n_led == 2){
        smooth_1d_in_place(xy_2, 2, k);
        xy = combine_xy(xy_1, xy_2, weight_1, weight_2);
    }else{
        xy = xy_1;
    }

    header.max_vals = [(parseInt(header.window_max_y)-parseInt(header.window_min_y))*units_per_m/ppm ,
                       (parseInt(header.window_max_x)-parseInt(header.window_min_x))*units_per_m/ppm ]; //TODO: decide which way round we want x and y
    header.units_per_meter = units_per_m;

    return {
        xy: xy,
        xy_1: xy_1,
        xy_2: xy_2,
        header: header
    }
}

</script>


<script is="worker-builder" id="tet_parser" title="tet-parser" type="javascript/worker">
"use strict";
// TODO: it might be nice, though complicated, to batch the tet parsing, that would
// allow the io to overlap with the compute, both of which are about 1ms/1k spikes.

var fkey_to_buffer = new Map();

var main_cached_opts = new Set();
var max_cache_size = 4; //aribtrary

var got_ports = function(ports){
    self.io_port = ports.tet;
    io_port.onmessage = function(e){
        var fkey = e.data.fkey;
        var buffer = fkey_to_buffer.get(fkey);
        if(!buffer){
            // see note at top of page on Chrome bug
            let reader =  new FileReaderSync();  // see note about Chrome bug at top of page
            buffer = reader.readAsArrayBuffer(e.data.file);
        }
        io_port.postMessage('done reading');

        // add/delete entries in buffer cache, based on instructions from io-worker
        fkey_to_buffer.set(fkey, buffer);
        if(e.data.delete_from_cache){
            fkey_to_buffer.delete(e.data.delete_from_cache);
        }

        // check to see if main cache actually holds any of the requested data 
        var options = e.data.options;       
        options.fkey = fkey;
        let cached_opts;
        for(cached_opts of main_cached_opts){
            if(cached_opts.fkey === fkey){
                // bump in FIFO
                main_cached_opts.delete(cached_opts);
                main_cached_opts.add(cached_opts);
                // remove the things that are already in cache
                if(cached_opts.times){
                    delete options.times;
                }
                if(cached_opts.amps){
                    delete options.amps;
                }
                if(cached_opts.gl_data){
                    delete options.gl_data;
                }
                if(options.times || options.amps || options.gl_data){
                    break; // there is at least some work to be done
                } else{
                    return; // nothing new requested
                }
            }
        }   

        if (!cached_opts || cached_opts.fkey !== fkey){
            // create new entry in main cache record, and possibly delete something
            cached_opts = {fkey: fkey};
            main_cached_opts.add(cached_opts);
            if(main_cached_opts.size > max_cache_size){
                let delete_from_cache = main_cached_opts.keys().next().value;
                exec_main('delete_from_tet_cache', delete_from_cache.fkey);
                main_cached_opts.delete(delete_from_cache);
            }
        }

        // pre-emptively record what we are about to put in main cache
        if(options.times){
            cached_opts.times = 1;
        }
        if(options.gl_data){
            cached_opts.gl_data = 1;
        }
        if(options.amps){
            cached_opts.amps = 1;
        }

        // and actually do the work...
        parse_tet_file(buffer, fkey, options, e.data.name);

    }
}

const regex_header_a = /((?:[\S\s](?!\r\ndata_start))*[\S\s])(\r\ndata_start)/
const regex_header_b = /(\S*) ([\S ]*)/g
const data_end = "\r\ndata_end";
const n_c = 4;
const n_w = 50;
const bytes_per_spike = n_c*(4 + n_w);

var parse_tet_file = function(buffer, fkey, options, file_name){
    var top_str = new TextDecoder('utf-8').decode(buffer.slice(0, 1204+1));
        
    var match = regex_header_a.exec(top_str);
    if(!match){
        throw 'did not find end of header in tet file.';
    }

    var data_start = match.index + match[0].length;
    var header = {
        file: file_name
    };
    var header_str = match[0];
    while (match = regex_header_b.exec(header_str)){
        header[match[1]] = match[2];
    }

    if (header.spike_format !== "t,ch1,t,ch2,t,ch3,t,ch4"){
        throw "uncregonised spike format used in tet file";
    }
    
    // sometimes DaCQ creates a header with num_spikes >0, but there are no spikes
    // (this happens when you choose not to record a given tetrode but a file previously existed)
    if(top_str.slice(data_start, data_start + data_end.length) === data_end){
        header.num_spikes_claimed = header.num_spikes;
        header.num_spikes = 0;
    }
    var n = parseInt(header.num_spikes);
    var data_len_bytes = n*bytes_per_spike;

    exec_main('got_tet_header', fkey, header);

    // TODO: test whether it's faster to iterate over the data once and compute everything
    // or to iterate once for each thing of interest (which is a bit more complicated)
    // if we stick with the multiple separate iterations, then decide on a good priority order
    // that gives users the best perception of speed...gl data probably comes first as it is
    // worth having even without cut data, whereas the other two are less helpful without cut
    // data.

    if(options.gl_data){
        var data =  build_gl_data(buffer, data_start, data_len_bytes, n);
        exec_main_b('got_gl_data', {
            data: 'data', 
            fkey: fkey,
            n_spikes: n
        }, {data: data});
    }

    if(options.times){
        var data =  get_times(buffer, data_start, data_len_bytes, n);
        exec_main_b('got_times', {
            data: 'data', 
            fkey: fkey,
            n_spikes: n,
            timebase: parseInt(header.timebase),
        }, {data: data});
    }

    if(options.amps){
        var data = get_amplitudes(buffer, data_start, data_len_bytes, n);
        var good_chans = check_channels(data);
        exec_main_b('got_amplitudes', {
            data: 'data', 
            chan_is_ok: good_chans,
            fkey: fkey,
            n_spikes: n
        }, {data: data});
    }
}

var build_gl_data_sub = function(data_in, data_out_16, n_spikes){
    // Note how we read from data_in contiguously, but write out non-contiguously.
    // This is about 4x faster than doing it the other way around.
    // It takes about 80ms for 80k spikes.
    // DataView should allow for fast misaligned uint16 access of data_in, but currently it's slow...
    // https://bugs.chromium.org/p/chromium/issues/detail?id=225811. Even if it's optimized in chrome
    // it probably won't help by more than 5-10% I would think.

    var q = -1;
    for(let i=0, p=0;i<n_spikes;i++,p=i){ //for each spike
        for(let c=0;c<n_c;c++){ //for each channel
            q = q + 5;
            for(let t=0;t<n_w-1;t++){ //for each time point (except the last one)
                data_out_16[p] = data_in[q] | (data_in[++q] << 8); // TODO: deal properly with endianness of system 
                // (Note that even though we are drawing a stand alone line segment from a to b, we still need to know how they match up to times t and t+1)
                p = p + n_spikes;
            }
        }
    }
}

var build_gl_data = function(buffer, offset_bytes, length_bytes, n_spikes){
    var old_data = new Uint8Array(buffer, offset_bytes, length_bytes);
    var new_data = new Uint16Array(n_c*(n_w-1)*n_spikes);
    
    build_gl_data_sub(old_data, new_data, n_spikes);
    return new_data;        
}


var get_times = function(buffer, offset_bytes, length_bytes, n_spikes){ //get spike times in milliseconds as a Uint32Array 
    var times = new Uint32Array(n_spikes);
    var data8 = new Uint8Array(buffer, offset_bytes, length_bytes); // can't make this int32 because it may not be sufficeintly alligned

    if (endian === 'L') {
        for(let i=0, p=0; i<times.length; i++, p+= bytes_per_spike){
            times[i] = (data8[p+0] << 24)
                     | (data8[p+1] << 16)   
                     | (data8[p+2] << 8) 
                     | (data8[p+3] << 0); 
        }        
    } else {
        throw "need to implement for big endian"; // TODO: or maybe the version above is actually valid for bothered?
    }

    return times;
}

var get_amplitudes_sub = function(old_data, amps, n_sc, n_w){
    n_sc = n_sc | 0; // int
    n_w = n_w | 0; // int
    for(let i=0, p=0; i<n_sc; i++){
        p = p+ 4; // skip timestamp 
        let min = 127;
        let max = -128;
        for(let t=0; t<n_w; t++,p++){
            (old_data[p] > max) && (max = old_data[p]);
            (old_data[p] < min) && (min = old_data[p]);
        }
        amps[i] = max-min; 
    }
}

var check_channels = function(amps){
    let small_amp = 5; // arbitrary threshold

    let chan_is_ok = new Uint8Array(n_c);
    for(let c=0; c<n_c; c++){
        for(let ii=c; ii<amps.length; ii+=n_c){
            chan_is_ok[c] = (amps[ii] > small_amp);
            if(chan_is_ok[c]){
                break;
            }
        }
    }
    return chan_is_ok;
}

var get_amplitudes = function(buffer, offset_bytes, length_bytes, n_spikes){
    var old_data = new Int8Array(buffer, offset_bytes, length_bytes);
    var amps = new Uint8Array(n_spikes * n_c);
    get_amplitudes_sub(old_data, amps, n_spikes * n_c, n_w);

    return amps;
}

</script>


<script is="worker-builder" id="set_parser" title="set-parser" type="javascript/worker">
"use strict";

var max_cache_size = 4; // arbitrary
var main_cached_fkeys = new Set();
var fkey_to_buffer = new Map();

var got_ports = function(ports){
    self.io_port = ports.set;
    io_port.onmessage = function(e){
        var fkey = e.data.fkey;
        var buffer = fkey_to_buffer.get(fkey);
        if(!buffer){
            // see note at top of page on Chrome bug
            let reader =  new FileReaderSync();  // see note about Chrome bug at top of page
            buffer = reader.readAsArrayBuffer(e.data.file);
        }
        io_port.postMessage('done reading');

        // add/delete entries in buffer cache, based on instructions from io-worker
        fkey_to_buffer.set(fkey, buffer);
        if(e.data.delete_from_cache){
            fkey_to_buffer.delete(e.data.delete_from_cache);
        }

        if(main_cached_fkeys.has(fkey)){
            // bump in FIFO
            main_cached_fkeys.delete(fkey);
            main_cached_fkeys.add(fkey);
            return;
        }
        var full_str = new TextDecoder('utf-8').decode(buffer);
        
        main_cached_fkeys.add(fkey);
        var delete_from_cache;
        if(main_cached_fkeys.size > max_cache_size){
            delete_from_cache = main_cached_fkeys.keys().next().value;
            main_cached_fkeys.delete(delete_from_cache);
        }

        var header = parse_set_file(full_str, fkey);
        header.file = e.data.name;
        exec_main('set_file_parsed', {
            fkey: fkey,
            header: header,
            delete_from_cache: delete_from_cache});

    }
}

const regex_header_b = /(\S*) ([\S ]*)/g

var parse_set_file = function(full_str, fkey){
    var header = {};
    var match;
    while (match = regex_header_b.exec(full_str))
        header[match[1]] = match[2];
    return header;
}

</script>


<script is="worker-builder" id="cut_parser" title="cut-parser" type="javascript/worker">
"use strict";

const max_cache_size = 4; // arbitrary
const main_cached_fkeys = new Set();
const regex_ext = /\.([0-9a-z]+)$/i;
const fkey_to_buffer = new Map();

var got_ports = function(ports){
    self.io_port = ports.cut;
    io_port.onmessage = function(e){
        var fkey = e.data.fkey;
        var buffer = fkey_to_buffer.get(fkey);
        if(!buffer){
            // see note at top of page on Chrome bug
            let reader =  new FileReaderSync();  // see note about Chrome bug at top of page
            buffer = reader.readAsArrayBuffer(e.data.file);
        }
        io_port.postMessage('done reading');

        // add/delete entries in buffer cache, based on instructions from io-worker
        fkey_to_buffer.set(fkey, buffer);
        if(e.data.delete_from_cache){
            fkey_to_buffer.delete(e.data.delete_from_cache);
        }

        if(main_cached_fkeys.has(fkey)){
            // bump in FIFO
            main_cached_fkeys.delete(fkey);
            main_cached_fkeys.add(fkey);
            return; // main already has it, so no need to send it.
        }
        var full_str = new TextDecoder('utf-8').decode(buffer);

        // TODO: clu/cut based on extension
        var ext = e.data.name.match(regex_ext)[1]
        var msg;
        if (ext === 'cut') {
            msg = parse_cut_file(full_str, fkey);
        } else if(!isNaN(parseInt(ext))){
            msg = parse_clu_file(full_str, fkey);
        } else{
            throw "urecognised cut type";
        }
        
        var cut = msg.cut;
        msg.cut = "cut";
        msg.fkey = fkey;
        msg.header.file = e.data.name;
        main_cached_fkeys.add(fkey);
        if(main_cached_fkeys.size > max_cache_size){
            msg.delete_from_cache = main_cached_fkeys.keys().next().value;
            main_cached_fkeys.delete(msg.delete_from_cache);
        }

        exec_main_b('cut_file_parsed', msg, {cut : cut});

    }
}

const regex_cut_a = /n_clusters:\s*(\S*)\s*n_channels:\s*(\S*)\s*n_params:\s*(\S*)\s*times_used_in_Vt:\s*(\S*)\s*(\S*)\s*(\S*)\s*(\S*)/;
const regex_cut_b = /Exact_cut_for: ((?:[\s\S](?! spikes:))*[\s\S])\s*spikes: ([0-9]*)/;
const regex_cut_c = /([0-9]+)/g;
const max_length_match_cut_b = 300;//this is needed so that when we read in chunks of the cut fkey we dont have to apply the regex_b to the whole thing each time

var parse_cut_file = function(full_str, fkey){
    var match = regex_cut_a.exec(full_str);      
    var cut_props = {};
    cut_props.n_clusters =  parseInt(match[1]);
    cut_props.n_channels =  parseInt(match[2]);
    cut_props.n_params =  parseInt(match[3]);

    match = regex_cut_b.exec(full_str);
    cut_props.exp = match[1];
    cut_props.n_spikes = parseInt(match[2]);
    cut_props.data_start = match.index + match[0].length;
    cut_props.is_clu = false;

    var cut_as_str = full_str.slice(cut_props.data_start).match(regex_cut_c);
    var cut = new Uint32Array(cut_as_str.length);
    for(let ii=0; ii<cut.length; ii++){
        cut[ii] = parseInt(cut_as_str[ii]);
    }

    return {
        header: cut_props,
        cut: cut
    }

}

var parse_clu_file = function(full_str, fkey){
    var cut_as_str = full_str.match(regex_cut_c);
    var cut_props = {
        n_clusters: parseInt(cut_as_str[0]),  // TODO: check +/- 1
        n_spikes: cut_as_str.length-1,
        is_clu: true
    }
    var cut = new Uint32Array(cut_as_str.length-1);
    for(let ii=0; ii<cut.length; ii++){
        cut[ii] = parseInt(cut_as_str[ii+1]) -1;
    }

    return {
        header: cut_props,
        cut: cut
    }
}

</script>

<template></template>


<script>
    "use strict";
    Polymer({
        is:'parsed-data',
        properties: {
            selected_files: {
                type: Object,
                value: function(){return {set: null, pos: null, tet: null, cut: null}}, //fkeys
                notify: true,
                observer: '_change_to_files'
            },
            use_n_leds: {
                type: Number, //1 or 2
                value: 2,
                notify: true
            },
            speed_filter_mps: {
                type: Number,  //mps= meters per second
                value: 4,
                notify: true
            },
            pos_smoothing_s: {
                type: Number, 
                value: 0.2,
                notify: true
            },
            duration: {
                type: Number, // seconds
                value: 0,
                notify: true,
                readOnly: true
            },
            start_end_times: {
                type: Object, // start and end miliseconds (numbers)
                value: null,
                notify: true,
                readOnly: true
            },
            spike_times: {
                type: Object,
                value: function(){ return {};}, // data (akey), timebase
                readOnly: true,
                notify: true
            },
            pos_xy: {
                type: Object,
                value: function(){ return {};}, // xy (akey), timebase,  and units_per_cm
                readOnly: true,
                notify: true 
            },
            pos_dir: {
                type: Object,
                value: function(){ return {};}, // dir (akey), timebase
                readOnly: true,
                notify: true
            },
            pos_speed: {
                type: Object,
                value: function(){ return {};}, // speed (akey), timebase
                readOnly: true,
                notify: true
            },
            pos_header: {
                type: Object,
                value: function(){ return {};},
                readOnly: true,
                notify: true
            },
            set_header: {
                type: Object,
                value: function(){ return {};},
                readOnly: true,
                notify: true
            },
            tet_header: {
                type: Object,
                value: function(){ return {};},
                readOnly: true,
                notify: true
            },
            cut_box: {
                type: Object, // is: ["stack" | "file" | "n" | <undefined> ]
                              // is="file". akey: indices for file, header: header for file
                              // is="n". n_spikes in tet file
                              // is="stack". see cut-obj for details
                value: function(){ return {} },
                readOnly: true,
                notify: true
            },
            amplitudes: {
                type: Object,
                value: function(){return {};}, // n, chan_is_ok bool[4], amps taid
                notify: true,
                readOnly: true
            },
            data_for_gl: {
                type: Object,
                value: function(){return {};}, // has n value and typed-array-manager id for gl voltages
                readOnly: true,
                notify: true
            },
            want_spike_times: {
                type: Array,
                value: function(){return [];},
                notify: true
            },
            want_amplitudes: {
                type: Array,
                value: function(){return [];},
                notify: true
            },
            want_data_for_gl: {
                type: Array,
                value: function(){return [];},
                notify: true
            },
            no_groups: { // unlike everything else, this is only updated in the second phase of a file-switch
                type: Boolean,
                value: true,
                notify: true,
                readOnly: true
            }
        }, observers: [
            '_pos_options_changed(speed_filter_mps, use_n_leds, pos_smoothing_s)',
            '_tet_options_changed(want_spike_times.splices, want_data_for_gl.splices, want_amplitudes.splices)'
        ], created: function(){
            this._files = {}; // set, tet, pos, cut
            this._fkey_ids = {}; // set, tet, pos, cut
            this._cut_from_fkey = new Map();
            this._set_from_fkey = new Map();
            this._pos_from_options = new Map(); // key=options object giving fkey and parse options; value= {header, xy, dir, speed}
            this._tet_from_fkey = new Map(); // contains objects with one or more of {header, amps, times, gl_data}

            // this is slightly gratuitous as the set worker and cut workers really don't do all that much
            // but it's unlikely to be worse having them as workers.
            this._worker_io = Polymer.DomModule.import('parsed-data', '#io_worker').create_for(this);
            this._worker_set = Polymer.DomModule.import('parsed-data', '#set_parser').create_for(this);
            this._worker_tet = Polymer.DomModule.import('parsed-data', '#tet_parser').create_for(this);
            this._worker_pos = Polymer.DomModule.import('parsed-data', '#pos_parser').create_for(this);
            this._worker_cut = Polymer.DomModule.import('parsed-data', '#cut_parser').create_for(this);
            var ports_for_io = {};

            var c = new MessageChannel();
            ports_for_io['set'] = c.port1;
            this._worker_set.send_ports({set: c.port2});

            c = new MessageChannel();
            ports_for_io['tet'] = c.port1;
            this._worker_tet.send_ports({tet: c.port2});

            c = new MessageChannel();
            ports_for_io['pos'] = c.port1;
            this._worker_pos.send_ports({pos: c.port2});

            c = new MessageChannel();
            ports_for_io['cut'] = c.port1;
            this._worker_cut.send_ports({cut: c.port2});

            this._worker_io.send_ports(ports_for_io);

        }, attached: function(){
            var els = document.getElementsByTagName('cut-object');
            for(let ii=0; ii<els.length; ii++){
                this.listen(els[ii], 'fork', '_cut_forked');
            }
        }, _cut_forked: function(e){
            // We catch this signal from the cut-obj directly, in addition to the file-organiser catching it.
            // By doing this, when the file-organiser changes its file_selection, we will not treat the forked cut
            // as being new..which is great.  Note that setting the cut_box here will send it to the cut obj, but the
            // cut object will find that each inidvidual property is the same as before, so will not actually do anything.
            // Another thing to note is that file_selection is updated from within a debounce in file-organiser, which ensures
            // that this event handler is called before the file-organiser notifies us of the change.
            this._fkey_ids.cut = null;
            this._files.cut = e.detail;
            this._setCut_box(this._files.cut);
        }, _change_to_files: function(new_fkeys){
            // nullify things that are changing... (note we use this._fkey_ids rather than 2nd argument, old_fkeys due to _cut_forked)
            var changing = new Set();
            for(let k of ['tet','cut','pos','set']){
                if(!this._files[k] || !new_fkeys[k] || this._fkey_ids[k] !== new_fkeys[k].id){
                    changing.add(k);
                    if(new_fkeys[k]){
                        this._files[k] = new_fkeys[k].file || new_fkeys[k]; // cut sometimes isn't an fkey but a CutStackState
                        this._fkey_ids[k] = new_fkeys[k].id;       
                    } else {
                        this._files[k] = null;
                        this._fkey_ids[k] = null;      
                    }
                }
            }
            if(changing.has('tet') && this._files.cut && this._files.cut.is === "n"){
                changing.add('cut');
            }
            
            if(changing.has('set')){
                this._setDuration(null);
                this._setSet_header(null);
            }
            if(changing.has('pos')){
                this._setPos_xy(null);
                this._setPos_speed(null);
                this._setPos_dir(null);
                this._setPos_header(null);
            }
            if(changing.has('tet')){
                this._setSpike_times(null);
                this._setAmplitudes(null);
                this._setData_for_gl(null);
                this._setTet_header(null);
            }
            if(changing.has('cut')){
                this._setCut_box(null);
            }

            // build request for io-worker, taking as much as possible from the main cache
            var request = {};
            var options = {};

            if(changing.has('set')){
                request['set'] = null;
                if(this._files.set && this._set_from_fkey.has(this._fkey_ids.set)){
                    this._use_set(this._set_from_fkey.get(this._fkey_ids.set));
                } else {
                    request['set'] = this._files.set;
                    request['set_fkey'] = this._fkey_ids.set;
                }
            }

            if(changing.has('cut')){
                this._make_cut_from_n = false;
                request['cut'] = null;
                if(!this._files.cut){
                    this._make_cut_from_n = true; // we have already guaranteed that changing has 'tet'
                                                  // though if there's no tet file we will never get to make the cut
                } else if(this._files.cut.is === "stack"){
                    // new_values.cut is an fkey for a "fake" file, which is actually a cut "stack" object
                    this._setCut_box(this._files.cut); //easy
                } else {
                    // this._files.cut is an fkey for a proper file
                    if(this._cut_from_fkey.has(this._fkey_ids.cut)){
                        // create box from cached inds and header
                        this._setCut_box({
                            is: 'file',
                            akey: this._cut_from_fkey.get(this._fkey_ids.cut).cut,
                            header: this._cut_from_fkey.get(this._fkey_ids.cut).header
                        });
                    } else {
                        request['cut'] = this._files.cut;
                        request['cut_fkey'] = this._fkey_ids.cut;
                    }
                }
            }

            if(changing.has('pos')){
                request['pos'] = null;
                if(this._files.pos){
                    var in_cache = false;
                    var pos_options = this._make_pos_options();
                    pos_options.fkey = this._fkey_ids.pos;
                    for(let [cached_opts, data] of this._pos_from_options){
                        if(Utils.is_equal_simple(cached_opts, pos_options)){
                            this._use_pos(data);
                            in_cache = true;
                            break;
                        }
                    }
                    if(!in_cache){
                        request['pos'] = this._files.pos;
                        options['pos'] = this._make_pos_options();
                        request['pos_fkey'] = this._fkey_ids.pos;
                    }
                }
            }

            if(changing.has('tet')){
                this._make_tet_request(this._fkey_ids.tet, this._files.tet, request, options);
            }

            this._worker_io.exec('read_files', request, options); 

            this._setNo_groups(!(new_fkeys.tet || new_fkeys.cut)); // as promissed, we only set this once during the file-change

        }, _pos_options_changed: function(){
            var options = this._make_pos_options();
            this._worker_io.exec('read_files', {
                pos: this._files.pos,
                pos_fkey: this._fkey_ids.pos
            }, {
                pos: options
            });
        }, got_pos: function(msg, arrays){
            var am = Utils.typed_array_manager;
            var result = {
                xy: am.to_akey(arrays['xy']),
                dir: am.to_akey(arrays['dir']),
                speed: am.to_akey(arrays['speed']),
                header: msg.header
            };
            msg.options.fkey = msg.fkey; // needed both for adding to cache (on next line) and for delete_from_cache loop
            this._pos_from_options.set(msg.options, result);
            if(msg.delete_from_cache){
                for(let cached_opts of this._pos_from_options.keys()){
                    if(Utils.is_equal_simple(cached_opts, msg.delete_from_cache)){
                        this._pos_from_options.delete(cached_opts);
                    }
                }
            }
            var opts =  this._make_pos_options();
            opts.fkey = this._fkey_ids.pos;
            if(Utils.is_equal_simple(msg.options, opts)){
                this._use_pos(result);
            }            
        },
        _use_pos: function(result){
            let timebase = result.header && parseInt(result.header.timebase);
            this._setPos_xy({
                xy: result.xy,
                timebase: timebase,
                units_per_cm: result.header && parseInt(result.header.units_per_meter)/100,
                max_x: result.header && result.header.max_vals[0],
                max_y: result.header && result.header.max_vals[1]
            });
            this._setPos_dir({
                dir: result.dir,
                timebase: timebase
            });
            this._setPos_speed({
                speed: result.speed,
                timebase: timebase
            });
            this._setPos_header(result.header);
        },
        _make_tet_request: function(fkey, file, request, options){
            if(!fkey){
                request['tet'] = null;
                return;
            }

            var cached = this._tet_from_fkey.get(fkey) || {};
            options['tet'] = {};
            if(this.want_amplitudes.length){
                if(cached.amps){
                    this._setAmplitudes(cached.amps);
                } else {
                    request['tet'] = file;
                    request['tet_fkey'] = fkey;
                    options['tet']['amps'] = 1;    
                }
            } 
            if(this.want_spike_times.length){
                if(cached.times){
                    this._setSpike_times(cached.times);
                } else {
                    request['tet'] = file;
                    request['tet_fkey'] = fkey;
                    options['tet']['times'] = 1;
                }
            }
            if(this.want_data_for_gl.length){
                if(cached.gl_data) {
                    this._setData_for_gl(cached.gl_data);
                } else {
                    request['tet'] = file;
                    request['tet_fkey'] = fkey;
                    options['tet']['gl_data'] = 1;                            
                }
            }
            if(cached.header){
                this._setTet_header(cached.header);
                if(this._make_cut_from_n){
                    this._setCut_box({
                        is: 'n',
                        n_spikes: parseInt(cached.header.num_spikes),
                        header: null
                    });
                }

            }

        }, _tet_options_changed: function(){
            var request = {}, options = {};
            this._make_tet_request(this._fkey_ids.tet, this._files.tet, request, options);
            this._worker_io.exec('read_files', request, options); 
        }, cut_file_parsed: function(msg, arrays){
            var am = Utils.typed_array_manager;
            this._cut_from_fkey.set(msg.fkey,{
                header: msg.header,
                cut: am.to_akey(arrays['cut'])
            });
            if(this._fkey_ids.cut === msg.fkey){
                this._setCut_box({
                    is: 'file',
                    akey: this._cut_from_fkey.get(msg.fkey).cut,
                    header: this._cut_from_fkey.get(msg.fkey).header
                });
            }
            if(msg.delete_from_cache){
                this._cut_from_fkey.delete(msg.delete_from_cache);
            }
        }, _make_pos_options: function(){
            return {
                use_both_leds: (this.use_n_leds == 2),
                need_to_subtract_mins: false,
                swapping_thresh_cm: 1,
                max_speed: this.speed_filter_mps,
                smoothing_secs: this.pos_smoothing_s
            }
        }, got_gl_data: function(msg, arrays){
            var am = Utils.typed_array_manager;
            var cached = this._tet_from_fkey.get(msg.fkey);
            if(!cached){
                cached = {};
                this._tet_from_fkey.set(msg.fkey, cached);
            }
            cached.gl_data = {
                n: msg.n_spikes,
                voltages: am.to_akey(arrays.data)
            };
            if(msg.fkey === this._fkey_ids.tet){
                this._setData_for_gl(cached.gl_data);
            }
        }, got_amplitudes: function(msg, arrays){
            var am = Utils.typed_array_manager;
            var cached = this._tet_from_fkey.get(msg.fkey);
            if(!cached){
                cached = {};
                this._tet_from_fkey.set(msg.fkey, cached);
            }
            cached.amps = {
                n: msg.n_spikes,
                amps: am.to_akey(arrays.data),
                chan_is_ok: msg.chan_is_ok
            };
            if(msg.fkey === this._fkey_ids.tet){
                this._setAmplitudes(cached.amps);
            }
        }, got_times: function(msg, arrays){
            var am = Utils.typed_array_manager;
            var cached = this._tet_from_fkey.get(msg.fkey);
            if(!cached){
                cached = {};
                this._tet_from_fkey.set(msg.fkey, cached);
            }
            cached.times = {
                n: msg.n_spikes,
                timebase: msg.timebase,
                times: am.to_akey(arrays.data)
            };
            if(msg.fkey === this._fkey_ids.tet){
                this._setSpike_times(cached.times);
            }
        }, got_tet_header: function(fkey, header){
            var cached = this._tet_from_fkey.get(fkey);
            if(!cached){
                cached = {};
                this._tet_from_fkey.set(fkey, cached);
            }
            cached.header = header;
            if(fkey === this._fkey_ids.tet){
                this._setTet_header(header);
                if(this._make_cut_from_n){
                    this._setCut_box({
                        is: 'n',
                        n_spikes: parseInt(header.num_spikes),
                        header: null
                    })
                }
            }
        }, delete_from_tet_cache: function(fkey){
            this._tet_from_fkey.delete(fkey);
        }, set_file_parsed: function(msg) {
            if(this._fkey_ids.set === msg.fkey){
                this._use_set(msg.header);
            }
            this._set_from_fkey.set(msg.fkey, msg.header);
            if(msg.delete_from_cache){
                this._set_from_fkey.delete(msg.delete_from_cache);
            }
        }, _use_set: function(header){
            this._setDuration(parseInt(header.duration));
            let start = parseInt(header.lasttrialdatetime)*1000;
            this._setStart_end_times({
                start: start,
                end: start + this.duration *1000
            });
            this._setSet_header(header);
        }
    });
</script>

  
</dom-module>
<script>

  /**
   * `Polymer.IronScrollTargetBehavior` allows an element to respond to scroll events from a
   * designated scroll target.
   *
   * Elements that consume this behavior can override the `_scrollHandler`
   * method to add logic on the scroll event.
   *
   * @demo demo/scrolling-region.html Scrolling Region
   * @demo demo/document.html Document Element
   * @polymerBehavior
   */
  Polymer.IronScrollTargetBehavior = {

    properties: {

      /**
       * Specifies the element that will handle the scroll event
       * on the behalf of the current element. This is typically a reference to an element,
       * but there are a few more posibilities:
       *
       * ### Elements id
       *
       *```html
       * <div id="scrollable-element" style="overflow: auto;">
       *  <x-element scroll-target="scrollable-element">
       *    <!-- Content-->
       *  </x-element>
       * </div>
       *```
       * In this case, the `scrollTarget` will point to the outer div element. 
       *
       * ### Document scrolling
       *
       * For document scrolling, you can use the reserved word `document`:
       *
       *```html
       * <x-element scroll-target="document">
       *   <!-- Content -->
       * </x-element>
       *```
       *
       * ### Elements reference
       *
       *```js
       * appHeader.scrollTarget = document.querySelector('#scrollable-element');
       *```
       * 
       * @type {HTMLElement}
       */
      scrollTarget: {
        type: HTMLElement,
        value: function() {
          return this._defaultScrollTarget;
        }
      }
    },

    observers: [
      '_scrollTargetChanged(scrollTarget, isAttached)'
    ],

    _scrollTargetChanged: function(scrollTarget, isAttached) {
      var eventTarget;

      if (this._oldScrollTarget) {
        eventTarget = this._oldScrollTarget === this._doc ? window : this._oldScrollTarget;
        eventTarget.removeEventListener('scroll', this._boundScrollHandler);
        this._oldScrollTarget = null;
      }

      if (!isAttached) {
        return;
      }
      // Support element id references
      if (scrollTarget === 'document') {

        this.scrollTarget = this._doc;

      } else if (typeof scrollTarget === 'string') {

        this.scrollTarget = this.domHost ? this.domHost.$[scrollTarget] :
            Polymer.dom(this.ownerDocument).querySelector('#' + scrollTarget);

      } else if (this._isValidScrollTarget()) {

        eventTarget = scrollTarget === this._doc ? window : scrollTarget;
        this._boundScrollHandler = this._boundScrollHandler || this._scrollHandler.bind(this);
        this._oldScrollTarget = scrollTarget;

        eventTarget.addEventListener('scroll', this._boundScrollHandler);
      }
    },

    /**
     * Runs on every scroll event. Consumer of this behavior may override this method.
     *
     * @protected
     */
    _scrollHandler: function scrollHandler() {},

    /**
     * The default scroll target. Consumers of this behavior may want to customize
     * the default scroll target.
     *
     * @type {Element}
     */
    get _defaultScrollTarget() {
      return this._doc;
    },

    /**
     * Shortcut for the document element
     *
     * @type {Element}
     */
    get _doc() {
      return this.ownerDocument.documentElement;
    },

    /**
     * Gets the number of pixels that the content of an element is scrolled upward.
     *
     * @type {number}
     */
    get _scrollTop() {
      if (this._isValidScrollTarget()) {
        return this.scrollTarget === this._doc ? window.pageYOffset : this.scrollTarget.scrollTop;
      }
      return 0;
    },

    /**
     * Gets the number of pixels that the content of an element is scrolled to the left.
     *
     * @type {number}
     */
    get _scrollLeft() {
      if (this._isValidScrollTarget()) {
        return this.scrollTarget === this._doc ? window.pageXOffset : this.scrollTarget.scrollLeft;
      }
      return 0;
    },

    /**
     * Sets the number of pixels that the content of an element is scrolled upward.
     *
     * @type {number}
     */
    set _scrollTop(top) {
      if (this.scrollTarget === this._doc) {
        window.scrollTo(window.pageXOffset, top);
      } else if (this._isValidScrollTarget()) {
        this.scrollTarget.scrollTop = top;
      }
    },

    /**
     * Sets the number of pixels that the content of an element is scrolled to the left.
     *
     * @type {number}
     */
    set _scrollLeft(left) {
      if (this.scrollTarget === this._doc) {
        window.scrollTo(left, window.pageYOffset);
      } else if (this._isValidScrollTarget()) {
        this.scrollTarget.scrollLeft = left;
      }
    },

    /**
     * Scrolls the content to a particular place.
     *
     * @method scroll
     * @param {number} left The left position
     * @param {number} top The top position
     */
    scroll: function(left, top) {
       if (this.scrollTarget === this._doc) {
        window.scrollTo(left, top);
      } else if (this._isValidScrollTarget()) {
        this.scrollTarget.scrollLeft = left;
        this.scrollTarget.scrollTop = top;
      }
    },

    /**
     * Gets the width of the scroll target.
     *
     * @type {number}
     */
    get _scrollTargetWidth() {
      if (this._isValidScrollTarget()) {
        return this.scrollTarget === this._doc ? window.innerWidth : this.scrollTarget.offsetWidth;
      }
      return 0;
    },

    /**
     * Gets the height of the scroll target.
     *
     * @type {number}
     */
    get _scrollTargetHeight() {
      if (this._isValidScrollTarget()) {
        return this.scrollTarget === this._doc ? window.innerHeight : this.scrollTarget.offsetHeight;
      }
      return 0;
    },

    /**
     * Returns true if the scroll target is a valid HTMLElement.
     *
     * @return {boolean}
     */
    _isValidScrollTarget: function() {
      return this.scrollTarget instanceof HTMLElement;
    }
  };

</script>


<dom-module id="iron-list" assetpath="bower_components/iron-list/">
  <template>
    <style>
      :host {
        display: block;
        position: relative;
      }

      @media only screen and (-webkit-max-device-pixel-ratio: 1) {
        :host {
          will-change: transform;
        }
      }

      #items {
        @apply(--iron-list-items-container);
        position: relative;
      }

      #items > ::content > * {
        width: 100%;
        box-sizing: border-box;
        position: absolute;
        top: 0;
        will-change: transform;
      }
    </style>

    <array-selector id="selector" items="{{items}}" selected="{{selectedItems}}" selected-item="{{selectedItem}}">
    </array-selector>

    <div id="items">
      <content></content>
    </div>

  </template>
</dom-module>

<script>

(function() {

  var IOS = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/);
  var IOS_TOUCH_SCROLLING = IOS && IOS[1] >= 8;
  var DEFAULT_PHYSICAL_COUNT = 3;
  var MAX_PHYSICAL_COUNT = 500;
  var HIDDEN_Y = '-10000px';

  Polymer({

    is: 'iron-list',

    properties: {

      /**
       * An array containing items determining how many instances of the template
       * to stamp and that that each template instance should bind to.
       */
      items: {
        type: Array
      },

      /**
       * The name of the variable to add to the binding scope for the array
       * element associated with a given template instance.
       */
      as: {
        type: String,
        value: 'item'
      },

      /**
       * The name of the variable to add to the binding scope with the index
       * for the row.
       */
      indexAs: {
        type: String,
        value: 'index'
      },

      /**
       * The name of the variable to add to the binding scope to indicate
       * if the row is selected.
       */
      selectedAs: {
        type: String,
        value: 'selected'
      },

      /**
       * When true, tapping a row will select the item, placing its data model
       * in the set of selected items retrievable via the selection property.
       *
       * Note that tapping focusable elements within the list item will not
       * result in selection, since they are presumed to have their * own action.
       */
      selectionEnabled: {
        type: Boolean,
        value: false
      },

      /**
       * When `multiSelection` is false, this is the currently selected item, or `null`
       * if no item is selected.
       */
      selectedItem: {
        type: Object,
        notify: true
      },

      /**
       * When `multiSelection` is true, this is an array that contains the selected items.
       */
      selectedItems: {
        type: Object,
        notify: true
      },

      /**
       * When `true`, multiple items may be selected at once (in this case,
       * `selected` is an array of currently selected items).  When `false`,
       * only one item may be selected at a time.
       */
      multiSelection: {
        type: Boolean,
        value: false
      }
    },

    observers: [
      '_itemsChanged(items.*)',
      '_selectionEnabledChanged(selectionEnabled)',
      '_multiSelectionChanged(multiSelection)',
      '_setOverflow(scrollTarget)'
    ],

    behaviors: [
      Polymer.Templatizer,
      Polymer.IronResizableBehavior,
      Polymer.IronA11yKeysBehavior,
      Polymer.IronScrollTargetBehavior
    ],

    keyBindings: {
      'up': '_didMoveUp',
      'down': '_didMoveDown',
      'enter': '_didEnter'
    },

    /**
     * The ratio of hidden tiles that should remain in the scroll direction.
     * Recommended value ~0.5, so it will distribute tiles evely in both directions.
     */
    _ratio: 0.5,

    /**
     * The padding-top value for the list.
     */
    _scrollerPaddingTop: 0,

    /**
     * This value is the same as `scrollTop`.
     */
    _scrollPosition: 0,

    /**
     * The sum of the heights of all the tiles in the DOM.
     */
    _physicalSize: 0,

    /**
     * The average `F` of the tiles observed till now.
     */
    _physicalAverage: 0,

    /**
     * The number of tiles which `offsetHeight` > 0 observed until now.
     */
    _physicalAverageCount: 0,

    /**
     * The Y position of the item rendered in the `_physicalStart`
     * tile relative to the scrolling list.
     */
    _physicalTop: 0,

    /**
     * The number of items in the list.
     */
    _virtualCount: 0,

    /**
     * A map between an item key and its physical item index
     */
    _physicalIndexForKey: null,

    /**
     * The estimated scroll height based on `_physicalAverage`
     */
    _estScrollHeight: 0,

    /**
     * The scroll height of the dom node
     */
    _scrollHeight: 0,

    /**
     * The height of the list. This is referred as the viewport in the context of list.
     */
    _viewportSize: 0,

    /**
     * An array of DOM nodes that are currently in the tree
     * @type {?Array<!TemplatizerNode>}
     */
    _physicalItems: null,

    /**
     * An array of heights for each item in `_physicalItems`
     * @type {?Array<number>}
     */
    _physicalSizes: null,

    /**
     * A cached value for the first visible index.
     * See `firstVisibleIndex`
     * @type {?number}
     */
    _firstVisibleIndexVal: null,

    /**
     * A cached value for the last visible index.
     * See `lastVisibleIndex`
     * @type {?number}
     */
    _lastVisibleIndexVal: null,

    /**
     * A Polymer collection for the items.
     * @type {?Polymer.Collection}
     */
    _collection: null,

    /**
     * True if the current item list was rendered for the first time
     * after attached.
     */
    _itemsRendered: false,

    /**
     * The page that is currently rendered.
     */
    _lastPage: null,

    /**
     * The max number of pages to render. One page is equivalent to the height of the list.
     */
    _maxPages: 3,

    /**
     * The currently focused physical item.
     */
    _focusedItem: null,

    /**
     * The index of the `_focusedItem`.
     */
    _focusedIndex: -1,

    /**
     * The the item that is focused if it is moved offscreen.
     * @private {?TemplatizerNode}
     */
    _offscreenFocusedItem: null,

    /**
     * The item that backfills the `_offscreenFocusedItem` in the physical items
     * list when that item is moved offscreen.
     */
    _focusBackfillItem: null,

    /**
     * The bottom of the physical content.
     */
    get _physicalBottom() {
      return this._physicalTop + this._physicalSize;
    },

    /**
     * The bottom of the scroll.
     */
    get _scrollBottom() {
      return this._scrollPosition + this._viewportSize;
    },

    /**
     * The n-th item rendered in the last physical item.
     */
    get _virtualEnd() {
      return this._virtualStart + this._physicalCount - 1;
    },

    /**
     * The height of the physical content that isn't on the screen.
     */
    get _hiddenContentSize() {
      return this._physicalSize - this._viewportSize;
    },

    /**
     * The maximum scroll top value.
     */
    get _maxScrollTop() {
      return this._estScrollHeight - this._viewportSize + this._scrollerPaddingTop;
    },

    /**
     * The lowest n-th value for an item such that it can be rendered in `_physicalStart`.
     */
    _minVirtualStart: 0,

    /**
     * The largest n-th value for an item such that it can be rendered in `_physicalStart`.
     */
    get _maxVirtualStart() {
      return Math.max(0, this._virtualCount - this._physicalCount);
    },

    /**
     * The n-th item rendered in the `_physicalStart` tile.
     */
    _virtualStartVal: 0,

    set _virtualStart(val) {
      this._virtualStartVal = Math.min(this._maxVirtualStart, Math.max(this._minVirtualStart, val));
    },

    get _virtualStart() {
      return this._virtualStartVal || 0;
    },

    /**
     * The k-th tile that is at the top of the scrolling list.
     */
    _physicalStartVal: 0,

    set _physicalStart(val) {
      this._physicalStartVal = val % this._physicalCount;
      if (this._physicalStartVal < 0) {
        this._physicalStartVal = this._physicalCount + this._physicalStartVal;
      }
      this._physicalEnd = (this._physicalStart + this._physicalCount - 1) % this._physicalCount;
    },

    get _physicalStart() {
      return this._physicalStartVal || 0;
    },

    /**
     * The number of tiles in the DOM.
     */
    _physicalCountVal: 0,

    set _physicalCount(val) {
      this._physicalCountVal = val;
      this._physicalEnd = (this._physicalStart + this._physicalCount - 1) % this._physicalCount;
    },

    get _physicalCount() {
      return this._physicalCountVal;
    },

    /**
     * The k-th tile that is at the bottom of the scrolling list.
     */
    _physicalEnd: 0,

    /**
     * An optimal physical size such that we will have enough physical items
     * to fill up the viewport and recycle when the user scrolls.
     *
     * This default value assumes that we will at least have the equivalent
     * to a viewport of physical items above and below the user's viewport.
     */
    get _optPhysicalSize() {
      return this._viewportSize * this._maxPages;
    },

   /**
    * True if the current list is visible.
    */
    get _isVisible() {
      return this.scrollTarget && Boolean(this.scrollTarget.offsetWidth || this.scrollTarget.offsetHeight);
    },

    /**
     * Gets the index of the first visible item in the viewport.
     *
     * @type {number}
     */
    get firstVisibleIndex() {
      if (this._firstVisibleIndexVal === null) {
        var physicalOffset = this._physicalTop + this._scrollerPaddingTop;

        this._firstVisibleIndexVal = this._iterateItems(
          function(pidx, vidx) {
            physicalOffset += this._physicalSizes[pidx];
            if (physicalOffset > this._scrollPosition) {
              return vidx;
            }
          }) || 0;
      }
      return this._firstVisibleIndexVal;
    },

    /**
     * Gets the index of the last visible item in the viewport.
     *
     * @type {number}
     */
    get lastVisibleIndex() {
      if (this._lastVisibleIndexVal === null) {
        var physicalOffset = this._physicalTop;

        this._iterateItems(function(pidx, vidx) {
          physicalOffset += this._physicalSizes[pidx];

          if (physicalOffset <= this._scrollBottom) {
            this._lastVisibleIndexVal = vidx;
          }
        });
      }
      return this._lastVisibleIndexVal;
    },

    get _defaultScrollTarget() {
      return this;
    },

    ready: function() {
      this.addEventListener('focus', this._didFocus.bind(this), true);
    },

    attached: function() {
      this.updateViewportBoundaries();
      this._render();
      // `iron-resize` is fired when the list is attached if the event is added
      // before attached causing unnecessary work.
      this.listen(this, 'iron-resize', '_resizeHandler');
    },

    detached: function() {
      this._itemsRendered = false;
      this.unlisten(this, 'iron-resize', '_resizeHandler');
    },

    /**
     * Set the overflow property if this element has its own scrolling region
     */
    _setOverflow: function(scrollTarget) {
      this.style.webkitOverflowScrolling = scrollTarget === this ? 'touch' : '';
      this.style.overflow = scrollTarget === this ? 'auto' : '';
    },

    /**
     * Invoke this method if you dynamically update the viewport's
     * size or CSS padding.
     *
     * @method updateViewportBoundaries
     */
    updateViewportBoundaries: function() {
      this._scrollerPaddingTop = this.scrollTarget === this ? 0 :
          parseInt(window.getComputedStyle(this)['padding-top'], 10);

      this._viewportSize = this._scrollTargetHeight;
    },

    /**
     * Update the models, the position of the
     * items in the viewport and recycle tiles as needed.
     */
    _scrollHandler: function() {
      // clamp the `scrollTop` value
      var scrollTop = Math.max(0, Math.min(this._maxScrollTop, this._scrollTop));
      var delta = scrollTop - this._scrollPosition;
      var tileHeight, tileTop, kth, recycledTileSet, scrollBottom, physicalBottom;
      var ratio = this._ratio;
      var recycledTiles = 0;
      var hiddenContentSize = this._hiddenContentSize;
      var currentRatio = ratio;
      var movingUp = [];

      // track the last `scrollTop`
      this._scrollPosition = scrollTop;

      // clear cached visible indexes
      this._firstVisibleIndexVal = null;
      this._lastVisibleIndexVal = null;

      scrollBottom = this._scrollBottom;
      physicalBottom = this._physicalBottom;

      // random access
      if (Math.abs(delta) > this._physicalSize) {
        this._physicalTop += delta;
        recycledTiles =  Math.round(delta / this._physicalAverage);
      }
      // scroll up
      else if (delta < 0) {
        var topSpace = scrollTop - this._physicalTop;
        var virtualStart = this._virtualStart;

        recycledTileSet = [];

        kth = this._physicalEnd;
        currentRatio = topSpace / hiddenContentSize;

        // move tiles from bottom to top
        while (
            // approximate `currentRatio` to `ratio`
            currentRatio < ratio &&
            // recycle less physical items than the total
            recycledTiles < this._physicalCount &&
            // ensure that these recycled tiles are needed
            virtualStart - recycledTiles > 0 &&
            // ensure that the tile is not visible
            physicalBottom - this._physicalSizes[kth] > scrollBottom
        ) {

          tileHeight = this._physicalSizes[kth];
          currentRatio += tileHeight / hiddenContentSize;
          physicalBottom -= tileHeight;
          recycledTileSet.push(kth);
          recycledTiles++;
          kth = (kth === 0) ? this._physicalCount - 1 : kth - 1;
        }

        movingUp = recycledTileSet;
        recycledTiles = -recycledTiles;
      }
      // scroll down
      else if (delta > 0) {
        var bottomSpace = physicalBottom - scrollBottom;
        var virtualEnd = this._virtualEnd;
        var lastVirtualItemIndex = this._virtualCount-1;

        recycledTileSet = [];

        kth = this._physicalStart;
        currentRatio = bottomSpace / hiddenContentSize;

        // move tiles from top to bottom
        while (
            // approximate `currentRatio` to `ratio`
            currentRatio < ratio &&
            // recycle less physical items than the total
            recycledTiles < this._physicalCount &&
            // ensure that these recycled tiles are needed
            virtualEnd + recycledTiles < lastVirtualItemIndex &&
            // ensure that the tile is not visible
            this._physicalTop + this._physicalSizes[kth] < scrollTop
          ) {

          tileHeight = this._physicalSizes[kth];
          currentRatio += tileHeight / hiddenContentSize;

          this._physicalTop += tileHeight;
          recycledTileSet.push(kth);
          recycledTiles++;
          kth = (kth + 1) % this._physicalCount;
        }
      }

      if (recycledTiles === 0) {
        // Try to increase the pool if the list's client height isn't filled up with physical items
        if (physicalBottom < scrollBottom || this._physicalTop > scrollTop) {
          this._increasePoolIfNeeded();
        }
      } else {
        this._virtualStart = this._virtualStart + recycledTiles;
        this._physicalStart = this._physicalStart + recycledTiles;
        this._update(recycledTileSet, movingUp);
      }
    },

    /**
     * Update the list of items, starting from the `_virtualStart` item.
     * @param {!Array<number>=} itemSet
     * @param {!Array<number>=} movingUp
     */
    _update: function(itemSet, movingUp) {
      // manage focus
      this._manageFocus();
      // update models
      this._assignModels(itemSet);
      // measure heights
      this._updateMetrics(itemSet);
      // adjust offset after measuring
      if (movingUp) {
        while (movingUp.length) {
          this._physicalTop -= this._physicalSizes[movingUp.pop()];
        }
      }
      // update the position of the items
      this._positionItems();
      // set the scroller size
      this._updateScrollerSize();
      // increase the pool of physical items
      this._increasePoolIfNeeded();
    },

    /**
     * Creates a pool of DOM elements and attaches them to the local dom.
     */
    _createPool: function(size) {
      var physicalItems = new Array(size);

      this._ensureTemplatized();

      for (var i = 0; i < size; i++) {
        var inst = this.stamp(null);
        // First element child is item; Safari doesn't support children[0]
        // on a doc fragment
        physicalItems[i] = inst.root.querySelector('*');
        Polymer.dom(this).appendChild(inst.root);
      }
      return physicalItems;
    },

    /**
     * Increases the pool of physical items only if needed.
     *
     * @return {boolean} True if the pool was increased.
     */
    _increasePoolIfNeeded: function() {
      // Base case 1: the list has no size.
      if (this._viewportSize === 0) {
        return false;
      }
      // Base case 2: If the physical size is optimal and the list's client height is full
      // with physical items, don't increase the pool.
      var isClientHeightFull = this._physicalBottom >= this._scrollBottom && this._physicalTop <= this._scrollPosition;
      if (this._physicalSize >= this._optPhysicalSize && isClientHeightFull) {
        return false;
      }
      // this value should range between [0 <= `currentPage` <= `_maxPages`]
      var currentPage = Math.floor(this._physicalSize / this._viewportSize);

      if (currentPage === 0) {
        // fill the first page
        this._debounceTemplate(this._increasePool.bind(this, Math.round(this._physicalCount * 0.5)));
      } else if (this._lastPage !== currentPage && isClientHeightFull) {
        // paint the page and defer the next increase
        // wait 16ms which is rough enough to get paint cycle.
        Polymer.dom.addDebouncer(this.debounce('_debounceTemplate', this._increasePool.bind(this, 1), 16));
      } else {
        // fill the rest of the pages
        this._debounceTemplate(this._increasePool.bind(this, 1));
      }

      this._lastPage = currentPage;

      return true;
    },

    /**
     * Increases the pool size.
     */
    _increasePool: function(missingItems) {
      var nextPhysicalCount = Math.min(
          this._physicalCount + missingItems,
          this._virtualCount - this._virtualStart,
          MAX_PHYSICAL_COUNT
        );
      var prevPhysicalCount = this._physicalCount;
      var delta = nextPhysicalCount - prevPhysicalCount;

      if (delta <= 0) {
        return;
      }

      [].push.apply(this._physicalItems, this._createPool(delta));
      [].push.apply(this._physicalSizes, new Array(delta));

      this._physicalCount = prevPhysicalCount + delta;

      // update the physical start if we need to preserve the model of the focused item.
      // In this situation, the focused item is currently rendered and its model would
      // have changed after increasing the pool if the physical start remained unchanged.
      if (this._physicalStart > this._physicalEnd &&
          this._isIndexRendered(this._focusedIndex) &&
          this._getPhysicalIndex(this._focusedIndex) < this._physicalEnd) {
        this._physicalStart = this._physicalStart + delta;
      }
      this._update();
    },

    /**
     * Render a new list of items. This method does exactly the same as `update`,
     * but it also ensures that only one `update` cycle is created.
     */
    _render: function() {
      var requiresUpdate = this._virtualCount > 0 || this._physicalCount > 0;

      if (this.isAttached && !this._itemsRendered && this._isVisible && requiresUpdate) {
        this._lastPage = 0;
        this._update();
        this._itemsRendered = true;
      }
    },

    /**
     * Templetizes the user template.
     */
    _ensureTemplatized: function() {
      if (!this.ctor) {
        // Template instance props that should be excluded from forwarding
        var props = {};
        props.__key__ = true;
        props[this.as] = true;
        props[this.indexAs] = true;
        props[this.selectedAs] = true;
        props.tabIndex = true;

        this._instanceProps = props;
        this._userTemplate = Polymer.dom(this).querySelector('template');

        if (this._userTemplate) {
          this.templatize(this._userTemplate);
        } else {
          console.warn('iron-list requires a template to be provided in light-dom');
        }
      }
    },

    /**
     * Implements extension point from Templatizer mixin.
     */
    _getStampedChildren: function() {
      return this._physicalItems;
    },

    /**
     * Implements extension point from Templatizer
     * Called as a side effect of a template instance path change, responsible
     * for notifying items.<key-for-instance>.<path> change up to host.
     */
    _forwardInstancePath: function(inst, path, value) {
      if (path.indexOf(this.as + '.') === 0) {
        this.notifyPath('items.' + inst.__key__ + '.' +
          path.slice(this.as.length + 1), value);
      }
    },

    /**
     * Implements extension point from Templatizer mixin
     * Called as side-effect of a host property change, responsible for
     * notifying parent path change on each row.
     */
    _forwardParentProp: function(prop, value) {
      if (this._physicalItems) {
        this._physicalItems.forEach(function(item) {
          item._templateInstance[prop] = value;
        }, this);
      }
    },

    /**
     * Implements extension point from Templatizer
     * Called as side-effect of a host path change, responsible for
     * notifying parent.<path> path change on each row.
     */
    _forwardParentPath: function(path, value) {
      if (this._physicalItems) {
        this._physicalItems.forEach(function(item) {
          item._templateInstance.notifyPath(path, value, true);
        }, this);
      }
    },

    /**
     * Called as a side effect of a host items.<key>.<path> path change,
     * responsible for notifying item.<path> changes.
     */
    _forwardItemPath: function(path, value) {
      if (!this._physicalIndexForKey) {
        return;
      }
      var inst;
      var dot = path.indexOf('.');
      var key = path.substring(0, dot < 0 ? path.length : dot);
      var idx = this._physicalIndexForKey[key];
      var el = this._physicalItems[idx];


      if (idx === this._focusedIndex && this._offscreenFocusedItem) {
        el = this._offscreenFocusedItem;
      }
      if (!el) {
        return;
      }

      inst = el._templateInstance;

      if (inst.__key__ !== key) {
        return;
      }
      if (dot >= 0) {
        path = this.as + '.' + path.substring(dot+1);
        inst.notifyPath(path, value, true);
      } else {
        inst[this.as] = value;
      }
    },

    /**
     * Called when the items have changed. That is, ressignments
     * to `items`, splices or updates to a single item.
     */
    _itemsChanged: function(change) {
      if (change.path === 'items') {
        // reset items
        this._virtualStart = 0;
        this._physicalTop = 0;
        this._virtualCount = this.items ? this.items.length : 0;
        this._collection = this.items ? Polymer.Collection.get(this.items) : null;
        this._physicalIndexForKey = {};

        this._resetScrollPosition(0);
        this._removeFocusedItem();

        // create the initial physical items
        if (!this._physicalItems) {
          this._physicalCount = Math.max(1, Math.min(DEFAULT_PHYSICAL_COUNT, this._virtualCount));
          this._physicalItems = this._createPool(this._physicalCount);
          this._physicalSizes = new Array(this._physicalCount);
        }

        this._physicalStart = 0;

      } else if (change.path === 'items.splices') {
        this._adjustVirtualIndex(change.value.indexSplices);
        this._virtualCount = this.items ? this.items.length : 0;

      } else {
        // update a single item
        this._forwardItemPath(change.path.split('.').slice(1).join('.'), change.value);
        return;
      }

      this._itemsRendered = false;
      this._debounceTemplate(this._render);
    },

    /**
     * @param {!Array<!PolymerSplice>} splices
     */
    _adjustVirtualIndex: function(splices) {
      splices.forEach(function(splice) {
        // deselect removed items
        splice.removed.forEach(this._removeItem, this);
        // We only need to care about changes happening above the current position
        if (splice.index < this._virtualStart) {
          var delta = Math.max(
              splice.addedCount - splice.removed.length,
              splice.index - this._virtualStart);

          this._virtualStart = this._virtualStart + delta;

          if (this._focusedIndex >= 0) {
            this._focusedIndex = this._focusedIndex + delta;
          }
        }
      }, this);
    },

    _removeItem: function(item) {
      this.$.selector.deselect(item);
      // remove the current focused item
      if (this._focusedItem && this._focusedItem._templateInstance[this.as] === item) {
        this._removeFocusedItem();
      }
    },

    /**
     * Executes a provided function per every physical index in `itemSet`
     * `itemSet` default value is equivalent to the entire set of physical indexes.
     *
     * @param {!function(number, number)} fn
     * @param {!Array<number>=} itemSet
     */
    _iterateItems: function(fn, itemSet) {
      var pidx, vidx, rtn, i;

      if (arguments.length === 2 && itemSet) {
        for (i = 0; i < itemSet.length; i++) {
          pidx = itemSet[i];
          if (pidx >= this._physicalStart) {
            vidx = this._virtualStart + (pidx - this._physicalStart);
          } else {
            vidx = this._virtualStart + (this._physicalCount - this._physicalStart) + pidx;
          }
          if ((rtn = fn.call(this, pidx, vidx)) != null) {
            return rtn;
          }
        }
      } else {
        pidx = this._physicalStart;
        vidx = this._virtualStart;

        for (; pidx < this._physicalCount; pidx++, vidx++) {
          if ((rtn = fn.call(this, pidx, vidx)) != null) {
            return rtn;
          }
        }
        for (pidx = 0; pidx < this._physicalStart; pidx++, vidx++) {
          if ((rtn = fn.call(this, pidx, vidx)) != null) {
            return rtn;
          }
        }
      }
    },

    /**
     * Assigns the data models to a given set of items.
     * @param {!Array<number>=} itemSet
     */
    _assignModels: function(itemSet) {
      this._iterateItems(function(pidx, vidx) {
        var el = this._physicalItems[pidx];
        var inst = el._templateInstance;
        var item = this.items && this.items[vidx];

        if (item != null) {
          inst[this.as] = item;
          inst.__key__ = this._collection.getKey(item);
          inst[this.selectedAs] = /** @type {!ArraySelectorElement} */ (this.$.selector).isSelected(item);
          inst[this.indexAs] = vidx;
          inst.tabIndex = this._focusedIndex === vidx ? 0 : -1;
          this._physicalIndexForKey[inst.__key__] = pidx;
          el.removeAttribute('hidden');
        } else {
          inst.__key__ = null;
          el.setAttribute('hidden', '');
        }
      }, itemSet);
    },

    /**
     * Updates the height for a given set of items.
     *
     * @param {!Array<number>=} itemSet
     */
     _updateMetrics: function(itemSet) {
      // Make sure we distributed all the physical items
      // so we can measure them
      Polymer.dom.flush();

      var newPhysicalSize = 0;
      var oldPhysicalSize = 0;
      var prevAvgCount = this._physicalAverageCount;
      var prevPhysicalAvg = this._physicalAverage;

      this._iterateItems(function(pidx, vidx) {

        oldPhysicalSize += this._physicalSizes[pidx] || 0;
        this._physicalSizes[pidx] = this._physicalItems[pidx].offsetHeight;
        newPhysicalSize += this._physicalSizes[pidx];
        this._physicalAverageCount += this._physicalSizes[pidx] ? 1 : 0;

      }, itemSet);

      this._physicalSize = this._physicalSize + newPhysicalSize - oldPhysicalSize;
      this._viewportSize = this._scrollTargetHeight;

      // update the average if we measured something
      if (this._physicalAverageCount !== prevAvgCount) {
        this._physicalAverage = Math.round(
            ((prevPhysicalAvg * prevAvgCount) + newPhysicalSize) /
            this._physicalAverageCount);
      }
    },

    /**
     * Updates the position of the physical items.
     */
    _positionItems: function() {
      this._adjustScrollPosition();

      var y = this._physicalTop;

      this._iterateItems(function(pidx) {
        this.translate3d(0, y + 'px', 0, this._physicalItems[pidx]);
        y += this._physicalSizes[pidx];
      });
    },

    /**
     * Adjusts the scroll position when it was overestimated.
     */
    _adjustScrollPosition: function() {
      var deltaHeight = this._virtualStart === 0 ? this._physicalTop :
          Math.min(this._scrollPosition + this._physicalTop, 0);

      if (deltaHeight) {
        this._physicalTop = this._physicalTop - deltaHeight;
        // juking scroll position during interial scrolling on iOS is no bueno
        if (!IOS_TOUCH_SCROLLING) {
          this._resetScrollPosition(this._scrollTop - deltaHeight);
        }
      }
    },

    /**
     * Sets the position of the scroll.
     */
    _resetScrollPosition: function(pos) {
      if (this.scrollTarget) {
        this._scrollTop = pos;
        this._scrollPosition = this._scrollTop;
      }
    },

    /**
     * Sets the scroll height, that's the height of the content,
     *
     * @param {boolean=} forceUpdate If true, updates the height no matter what.
     */
    _updateScrollerSize: function(forceUpdate) {
      this._estScrollHeight = (this._physicalBottom +
          Math.max(this._virtualCount - this._physicalCount - this._virtualStart, 0) * this._physicalAverage);

      forceUpdate = forceUpdate || this._scrollHeight === 0;
      forceUpdate = forceUpdate || this._scrollPosition >= this._estScrollHeight - this._physicalSize;

      // amortize height adjustment, so it won't trigger repaints very often
      if (forceUpdate || Math.abs(this._estScrollHeight - this._scrollHeight) >= this._optPhysicalSize) {
        this.$.items.style.height = this._estScrollHeight + 'px';
        this._scrollHeight = this._estScrollHeight;
      }
    },
    /**
     * Scroll to a specific item in the virtual list regardless
     * of the physical items in the DOM tree.
     *
     * @method scrollToIndex
     * @param {number} idx The index of the item
     */
    scrollToIndex: function(idx) {
      if (typeof idx !== 'number') {
        return;
      }

      Polymer.dom.flush();

      idx = Math.min(Math.max(idx, 0), this._virtualCount-1);
      // update the virtual start only when needed
      if (!this._isIndexRendered(idx) || idx >= this._maxVirtualStart) {
        this._virtualStart = idx - 1;
      }
      // manage focus
      this._manageFocus();
      // assign new models
      this._assignModels();
      // measure the new sizes
      this._updateMetrics();
      // estimate new physical offset
      this._physicalTop = this._virtualStart * this._physicalAverage;

      var currentTopItem = this._physicalStart;
      var currentVirtualItem = this._virtualStart;
      var targetOffsetTop = 0;
      var hiddenContentSize = this._hiddenContentSize;

      // scroll to the item as much as we can
      while (currentVirtualItem < idx && targetOffsetTop < hiddenContentSize) {
        targetOffsetTop = targetOffsetTop + this._physicalSizes[currentTopItem];
        currentTopItem = (currentTopItem + 1) % this._physicalCount;
        currentVirtualItem++;
      }
      // update the scroller size
      this._updateScrollerSize(true);
      // update the position of the items
      this._positionItems();
      // set the new scroll position
      this._resetScrollPosition(this._physicalTop + this._scrollerPaddingTop + targetOffsetTop);
      // increase the pool of physical items if needed
      this._increasePoolIfNeeded();
      // clear cached visible index
      this._firstVisibleIndexVal = null;
      this._lastVisibleIndexVal = null;
    },

    /**
     * Reset the physical average and the average count.
     */
    _resetAverage: function() {
      this._physicalAverage = 0;
      this._physicalAverageCount = 0;
    },

    /**
     * A handler for the `iron-resize` event triggered by `IronResizableBehavior`
     * when the element is resized.
     */
    _resizeHandler: function() {
      // iOS fires the resize event when the address bar slides up
      if (IOS && Math.abs(this._viewportSize - this._scrollTargetHeight) < 100) {
        return;
      }
      // In Desktop Safari 9.0.3, if the scroll bars are always shown, 
      // changing the scroll position from a resize handler would result in 
      // the scroll position being reset. Waiting 1ms fixes the issue. 
      Polymer.dom.addDebouncer(this.debounce('_debounceTemplate',
        function() {
          this._render();

          if (this._itemsRendered && this._physicalItems && this._isVisible) {
            this._resetAverage();
            this.updateViewportBoundaries();
            this.scrollToIndex(this.firstVisibleIndex);
          }
        }.bind(this), 1));
    },

    _getModelFromItem: function(item) {
      var key = this._collection.getKey(item);
      var pidx = this._physicalIndexForKey[key];

      if (pidx != null) {
        return this._physicalItems[pidx]._templateInstance;
      }
      return null;
    },

    /**
     * Gets a valid item instance from its index or the object value.
     *
     * @param {(Object|number)} item The item object or its index
     */
    _getNormalizedItem: function(item) {
      if (this._collection.getKey(item) === undefined) {
        if (typeof item === 'number') {
          item = this.items[item];
          if (!item) {
            throw new RangeError('<item> not found');
          }
          return item;
        }
        throw new TypeError('<item> should be a valid item');
      }
      return item;
    },

    /**
     * Select the list item at the given index.
     *
     * @method selectItem
     * @param {(Object|number)} item The item object or its index
     */
    selectItem: function(item) {
      item = this._getNormalizedItem(item);
      var model = this._getModelFromItem(item);

      if (!this.multiSelection && this.selectedItem) {
        this.deselectItem(this.selectedItem);
      }
      if (model) {
        model[this.selectedAs] = true;
      }
      this.$.selector.select(item);
      this.updateSizeForItem(item);
    },

    /**
     * Deselects the given item list if it is already selected.
     *

     * @method deselect
     * @param {(Object|number)} item The item object or its index
     */
    deselectItem: function(item) {
      item = this._getNormalizedItem(item);
      var model = this._getModelFromItem(item);

      if (model) {
        model[this.selectedAs] = false;
      }
      this.$.selector.deselect(item);
      this.updateSizeForItem(item);
    },

    /**
     * Select or deselect a given item depending on whether the item
     * has already been selected.
     *
     * @method toggleSelectionForItem
     * @param {(Object|number)} item The item object or its index
     */
    toggleSelectionForItem: function(item) {
      item = this._getNormalizedItem(item);
      if (/** @type {!ArraySelectorElement} */ (this.$.selector).isSelected(item)) {
        this.deselectItem(item);
      } else {
        this.selectItem(item);
      }
    },

    /**
     * Clears the current selection state of the list.
     *
     * @method clearSelection
     */
    clearSelection: function() {
      function unselect(item) {
        var model = this._getModelFromItem(item);
        if (model) {
          model[this.selectedAs] = false;
        }
      }

      if (Array.isArray(this.selectedItems)) {
        this.selectedItems.forEach(unselect, this);
      } else if (this.selectedItem) {
        unselect.call(this, this.selectedItem);
      }

      /** @type {!ArraySelectorElement} */ (this.$.selector).clearSelection();
    },

    /**
     * Add an event listener to `tap` if `selectionEnabled` is true,
     * it will remove the listener otherwise.
     */
    _selectionEnabledChanged: function(selectionEnabled) {
      var handler = selectionEnabled ? this.listen : this.unlisten;
      handler.call(this, this, 'tap', '_selectionHandler');
    },

    /**
     * Select an item from an event object.
     */
    _selectionHandler: function(e) {
      if (this.selectionEnabled) {
        var model = this.modelForElement(e.target);
        if (model) {
          this.toggleSelectionForItem(model[this.as]);
        }
      }
    },

    _multiSelectionChanged: function(multiSelection) {
      this.clearSelection();
      this.$.selector.multi = multiSelection;
    },

    /**
     * Updates the size of an item.
     *
     * @method updateSizeForItem
     * @param {(Object|number)} item The item object or its index
     */
    updateSizeForItem: function(item) {
      item = this._getNormalizedItem(item);
      var key = this._collection.getKey(item);
      var pidx = this._physicalIndexForKey[key];

      if (pidx != null) {
        this._updateMetrics([pidx]);
        this._positionItems();
      }
    },

    /**
     * Creates a temporary backfill item in the rendered pool of physical items
     * to replace the main focused item. The focused item has tabIndex = 0
     * and might be currently focused by the user.
     *
     * This dynamic replacement helps to preserve the focus state.
     */
    _manageFocus: function() {
      var fidx = this._focusedIndex;

      if (fidx >= 0 && fidx < this._virtualCount) {
        // if it's a valid index, check if that index is rendered
        // in a physical item.
        if (this._isIndexRendered(fidx)) {
          this._restoreFocusedItem();
        } else {
          this._createFocusBackfillItem();
        }
      } else if (this._virtualCount > 0 && this._physicalCount > 0) {
        // otherwise, assign the initial focused index.
        this._focusedIndex = this._virtualStart;
        this._focusedItem = this._physicalItems[this._physicalStart];
      }
    },

    _isIndexRendered: function(idx) {
      return idx >= this._virtualStart && idx <= this._virtualEnd;
    },

    _isIndexVisible: function(idx) {
      return idx >= this.firstVisibleIndex && idx <= this.lastVisibleIndex;
    },

    _getPhysicalIndex: function(idx) {
      return this._physicalIndexForKey[this._collection.getKey(this._getNormalizedItem(idx))];
    },

    _focusPhysicalItem: function(idx) {
      if (idx < 0 || idx >= this._virtualCount) {
        return;
      }
      this._restoreFocusedItem();
      // scroll to index to make sure it's rendered
      if (!this._isIndexRendered(idx)) {
        this.scrollToIndex(idx);
      }

      var physicalItem = this._physicalItems[this._getPhysicalIndex(idx)];
      var SECRET = ~(Math.random() * 100);
      var model = physicalItem._templateInstance;
      var focusable;

      // set a secret tab index
      model.tabIndex = SECRET;
      // check if focusable element is the physical item
      if (physicalItem.tabIndex === SECRET) {
       focusable = physicalItem;
      }
      // search for the element which tabindex is bound to the secret tab index
      if (!focusable) {
        focusable = Polymer.dom(physicalItem).querySelector('[tabindex="' + SECRET + '"]');
      }
      // restore the tab index
      model.tabIndex = 0;
      // focus the focusable element
      this._focusedIndex = idx;
      focusable && focusable.focus();
    },

    _removeFocusedItem: function() {
      if (this._offscreenFocusedItem) {
        Polymer.dom(this).removeChild(this._offscreenFocusedItem);
      }
      this._offscreenFocusedItem = null;
      this._focusBackfillItem = null;
      this._focusedItem = null;
      this._focusedIndex = -1;
    },

    _createFocusBackfillItem: function() {
      var pidx, fidx = this._focusedIndex;
      if (this._offscreenFocusedItem || fidx < 0) {
        return;
      }
      if (!this._focusBackfillItem) {
        // create a physical item, so that it backfills the focused item.
        var stampedTemplate = this.stamp(null);
        this._focusBackfillItem = stampedTemplate.root.querySelector('*');
        Polymer.dom(this).appendChild(stampedTemplate.root);
      }
      // get the physical index for the focused index
      pidx = this._getPhysicalIndex(fidx);

      if (pidx != null) {
        // set the offcreen focused physical item
        this._offscreenFocusedItem = this._physicalItems[pidx];
        // backfill the focused physical item
        this._physicalItems[pidx] = this._focusBackfillItem;
        // hide the focused physical
        this.translate3d(0, HIDDEN_Y, 0, this._offscreenFocusedItem);
      }
    },

    _restoreFocusedItem: function() {
      var pidx, fidx = this._focusedIndex;

      if (!this._offscreenFocusedItem || this._focusedIndex < 0) {
        return;
      }
      // assign models to the focused index
      this._assignModels();
      // get the new physical index for the focused index
      pidx = this._getPhysicalIndex(fidx);

      if (pidx != null) {
        // flip the focus backfill
        this._focusBackfillItem = this._physicalItems[pidx];
        // restore the focused physical item
        this._physicalItems[pidx] = this._offscreenFocusedItem;
        // reset the offscreen focused item
        this._offscreenFocusedItem = null;
        // hide the physical item that backfills
        this.translate3d(0, HIDDEN_Y, 0, this._focusBackfillItem);
      }
    },

    _didFocus: function(e) {
      var targetModel = this.modelForElement(e.target);
      var focusedModel = this._focusedItem ? this._focusedItem._templateInstance : null;
      var hasOffscreenFocusedItem = this._offscreenFocusedItem !== null;
      var fidx = this._focusedIndex;

      if (!targetModel || !focusedModel) {
        return;
      }
      if (focusedModel === targetModel) {
        // if the user focused the same item, then bring it into view if it's not visible
        if (!this._isIndexVisible(fidx)) {
          this.scrollToIndex(fidx);
        }
      } else {
        this._restoreFocusedItem();
        // restore tabIndex for the currently focused item
        focusedModel.tabIndex = -1;
        // set the tabIndex for the next focused item
        targetModel.tabIndex = 0;
        fidx = targetModel[this.indexAs];
        this._focusedIndex = fidx;
        this._focusedItem = this._physicalItems[this._getPhysicalIndex(fidx)];

        if (hasOffscreenFocusedItem && !this._offscreenFocusedItem) {
          this._update();
        }
      }
    },

    _didMoveUp: function() {
      this._focusPhysicalItem(this._focusedIndex - 1);
    },

    _didMoveDown: function() {
      this._focusPhysicalItem(this._focusedIndex + 1);
    },

    _didEnter: function(e) {
      this._focusPhysicalItem(this._focusedIndex);
      this._selectionHandler(e.detail.keyboardEvent);
    }
  });

})();

</script>
<dom-module id="file-organiser" assetpath="/">

<script is="worker-builder" id="cut_reader" title="cut-base-reader" type="javascript/worker">
"use strict";

var get_base_for_cuts = function(files){
    // we don't bother with anything complicated here in terms of ticks/caching etc.
    // just iterate over every single file we recieve and read its experiment name
    var reader = new FileReaderSync();
    var batch_bytes = 10*1024;
    var regex_exact_cut = /Exact_cut_for: ((?:[\s\S](?! spikes:))*[\s\S])\s*spikes: ([0-9]*)/;
    var results = [];
    for (let ii=0; ii<files.length; ii++){
        let ff = files[ii];
        let header = "";
        for(let p=0; p<ff.size; p+= batch_bytes){
            // should only take one iteration
            header += reader.readAsBinaryString(ff.slice(p, p+batch_bytes));
            let match = regex_exact_cut.exec(header);
            if(match){
                results.push({
                    file: ff,
                    base: match[1]
                });
                break;
            }
        }
        // if something is wrong we end up reading the whole file and fail to find a match
    }
    exec_main('got_base_for_cuts', results);
}

</script>


<style>
:host{
user-drag: none;
-webkit-user-drag: none;
}
::-webkit-scrollbar {
width: 10px;
height: 10px;
}
::-webkit-scrollbar-button {
width: 0;
height: 0;
display: none;
}
::-webkit-scrollbar-thumb {
background-color: rgba(0,0,0,0.2);
-webkit-box-shadow: inset 1px 1px 0 rgba(0,0,0,0.10),inset 0 -1px 0 rgba(0,0,0,0.07);
}
.trial{
background: #f5f5f5;
padding: 5px;
border: 1px solid #ccc;
cursor: pointer;
display: block;
margin: 2px;
width: initial !important;
}
.trial.selected{
background: #ffffe0;
}
.trial_top{
margin-bottom: 4px;
}
.trial_bottom{

}
.trial_title{
font-weight: bold;
display: inline-block;
margin-right: 4px;
font-size: 12px;
}
.trial_set,
.trial_pos,
.trial_tet,
.trial_cut{
display: inline-block;
border: 1px #000 solid;
padding: 1px 2px 1px 2px;
margin-left: 1px;
background: #ddd;
line-height: 12px;
vertical-align: bottom;
}
.trial_tet_block{
display: inline-block;
border-left: 2px solid #000;
margin-bottom: 2px;
padding-right: 4px;
}
.trial_pos,
.trial_set{
background: #ddb550;
border-color: #552510;
color: #552510;
border-width: 2px;
font-size: 10px;
}
.trial_cut{
background: #fbb;
border-color: #500;
color: #500;
}
.trial_cut.selected{
background: #500;
color: #fff;
}
.trial_cut.stack{
background: #bbF;
border-color: #005;
color: #005;
user-drag: element;
-webkit-user-drag: element;
}
.trial_cut.stack.selected{
background: #005;
color: #fff;
}
iron-list{
flex: 2;
overflow-x: hidden !important;
}
:host{
display: flex;
flex-direction: column;
font-size: 0px;
};
.tet_button{
background: #f5f5f5;
text-align: center;
padding: 5px 10px 5px 10px;
margin: 2px;
display: inline-block;
border: 1px solid #ccc;
cursor: pointer;
font-size: 12px;
}
.tet_button.selected{
background: #ffffe0;
}
.tet_switcher_title{
font-size: 12px;
display: inline-block;
margin-left: 4px;
}
.trial_tet_block.selected .trial_cut,
.trial_tet_block.selected .trial_tet{
font-size: 10px;
}
/* TODO: on hover, we want a tooltip-style thing rather than causing an awkward reflow */;
/*
.trial_tet_block:hover .trial_cut,
.trial_tet_block:hover .trial_tet{
font-size: 10px;
}
*/
</style>
<template>
  <iron-a11y-keys keys="1 2 3 4 5 6 7 8 9 0" on-keys-pressed="_on_numeric_key" target="[[keyboard_target]]"></iron-a11y-keys>
  <iron-a11y-keys keys="o" on-keys-pressed="_on_tens_key" target="[[keyboard_target]]"></iron-a11y-keys>

  <div class="tet_switcher" style$="[[_scroll_shadow(scrolled_down)]]">
    <div class="tet_switcher_title">tetrode:</div>
    <template is="dom-repeat" items="[[available_tets]]">
        <div class$="tet_button [[_selected_equality(item, selected_tet_num)]]" on-click="_tet_button_click">[[item]]</div>
    </template>
  </div>
  <iron-list items="[[trials]]" as="trial" id="trial_list" on-scroll="_update_scrolled_down" on-selected-item-changed="_update_trial_selection_debounce" selection-enabled="">
    <template><div><div class$="trial [[_selected(selected)]]">
        <div class="trial_top" on-mouseenter="_make_trial_captions">
            <div class="trial_title">trial '[[trial.name]]'</div>
            <div class="trial_set" style$="display:[[_show(trial.set)]];" title$="[[trial.set_caption]]">~.set</div>
            <div class="trial_pos" style$="display:[[_show(trial.pos)]];" title$="[[trial.pos_caption]]">~.pos</div>
        </div>
        <div class="trial_bottom">
            <template is="dom-repeat" items="[[trial.tets]]" as="tet_block"> 
                <div class$="trial_tet_block [[_selected_equality(tet_block.tet_num, selected_tet_num)]]" on-mouseenter="_make_tet_captions" on-click="_tet_block_click">
                    <div class="trial_tet" style$="display:[[_show(tet_block.tet)]];" title$="[[tet_block.tet_caption]]">~.[[tet_block.tet_num]]</div>
                    <template is="dom-repeat" items="[[tet_block.cuts]]" as="cut">
                        <div class$="trial_cut [[cut.cut_type]] [[_selected_equality(selected_cut,cut.cut)]]" title$="[[cut.caption]]" on-click="_cut_click" on-dragstart="_cut_dragstart" on-dragend="_cut_dragend">[[cut.short_name]]</div>
                    </template>
                </div>
            </template>
        </div>
    </div></div></template>
  </iron-list>
</template>

<script>
    
Polymer({
    is: 'file-organiser',
    behaviors: [Polymer.IronResizableBehavior],
    properties: {
        no_files: {
            type: Boolean,
            value: true,
            notify: true,
            readOnly: true
        },
        selected_files: {
            type: Object,
            value: function(){return {set: 0, pos: 0, tet: 0, cut: 0}},
            readOnly: true,
            notify: true
        },
        is_dragging_out: {
            type: Boolean,
            value: false,
            notify: true,
            readOnly: true
        },
        is_dragging_in: {
            type: Boolean,
            value: false,
            notify: true,
            readOnly: true
        },
        scrolled_down: {
            type: Boolean,
            value: false,
            notify: true,
            readOnly: true
        },
        available_tets: {
            type: Array,
            value: function(){return [];},
            notify: true,
            readOnly: true
        },
        selected_trial: {
            type: String,
            value: "",
            notify: true,
            observer: '_update_trial'
        },
        selected_tet_num: {
            type: Number,
            value: -1,
            notify: true,
            observer: '_update_tet_num'
        },
        selected_cut: {
            type: Number, //fkey
            value: -1,
            notify: true,
            observer: '_update_cut'
        },
        trials: {
            type: Array,
            value: function(){ return [];},
            notify: true,
            readOnly: true
        },
        keyboard_target: {
            type: Object,
            value: function(){return document.querySelector('body');}
        }
    }, created: function(){
        this._time_formatter = new Intl.DateTimeFormat({},{hour: "numeric", minute: "numeric"});
        this._date_formatter = new Intl.DateTimeFormat({}, {month:"short", day:"numeric", year: "numeric"});
        this._byte_formatter = new Intl.NumberFormat({}, {maximumFractionDigits: 0});
        this._trial_from_base = new Map();
        this._use_url_search = window.location.search;
        this.listen(document, "dragover", '_dragover');
        this.listen(document, "drop", '_drop');
    }, _update_scrolled_down: function(e){
        this._setScrolled_down(e.target.scrollTop > 0);
    }, _update_trial_selection_debounce: function(e){
        this.debounce('update_trial_selection', this._update_trial_selection);
    }, attached: function(){
        let els = document.getElementsByTagName('cut-object');
        for(let ii=0; ii<els.length; ii++){
            this.listen(els[ii], 'fork', '_cut_forked');
        }
    }, _cut_forked: function(e){
        let new_cut = e.detail

        let trial = this._trial_from_base.get(this.selected_trial);
        let tet_obj = this._get_tet_obj(trial, this.selected_tet_num);
        let suffix = 'a'.charCodeAt(0);
        for(let cc of tet_obj.cuts)if(cc.cut_type === 'stack'){
            suffix += 1;
        }

        // I wish there was a nicer way to do this...
        this.unshift('trials.' + Utils.get_key(this.trials, trial)  +
                  '.tets.' + Utils.get_key(trial.tets, tet_obj) + '.cuts',{
                    cut: new_cut,
                    cut_type: 'stack',
                    caption: this.selected_trial + '_' + tet_obj.tet_num + ".cut" + " (modified cut)", //note no suffix when saved as file
                    date: Date.now(), // note that this doesn't update when you modify the cut further
                    date_name_str: Date.now() + ' ' + suffix, // this is neccessary for the deduping-machinery
                    short_name: '~' + String.fromCharCode(suffix) + '_' + tet_obj.tet_num + ".cut"
                });
        
        this.set('selected_cut', new_cut);
    }, _update_trial_selection: function(){
        var new_sel = this.$.trial_list.selectedItem;
        var old_sel = this._trial_from_base.get(this.selected_trial);
        if(!new_sel && old_sel){
            this.$.trial_list.selectItem(old_sel);
        } else if(new_sel === old_sel){
            // nothing changed after all
        } else {
            this.set('selected_trial', new_sel && new_sel.name);
        }
    }, _update_tet_num: function(new_val){
        this._select_default_cut(); // note cut may be updated again before the debouncer fires
        this.debounce('_switched_selection', this._switched_selection.bind(this));
    }, _update_trial: function(new_val){
        this._select_default_cut(); // note cut may be updated again before the debouncer fires
        this.debounce('_switched_selection', this._switched_selection.bind(this));
    }, _update_cut: function(new_val){
        let trial = this._trial_from_base.get(this.selected_trial);
        if(trial){
            let tet_obj = this._get_tet_obj(trial, this.selected_tet_num, false);
            tet_obj && (tet_obj.last_used_cut = new_val);
        }
        this.debounce('_switched_selection', this._switched_selection.bind(this));
    }, _tet_button_click: function(e){
        var model = e.model;
        this.set('selected_tet_num', model.item);
    }, _tet_block_click: function(e){
        var model = e.model;
        this.set('selected_trial', model.dataHost.dataHost.trial.name); // https://github.com/Polymer/polymer/issues/1919
        this.set('selected_tet_num', model.tet_block.tet_num);
        //e.stopPropagation();
    }, _cut_click: function(e){
        var model = e.model;
        this.set('selected_trial', model.dataHost.dataHost.dataHost.dataHost.trial.name); // https://github.com/Polymer/polymer/issues/1919
        this.set('selected_tet_num', model.dataHost.dataHost.tet_block.tet_num);
        this.set('selected_cut', model.cut.cut);
        //e.stopPropagation();
    }, _select_default_cut: function(){
        var trial = this._trial_from_base.get(this.selected_trial);
        if(trial){
            var tet_obj = this._get_tet_obj(trial, this.selected_tet_num, false);
            if(tet_obj){
                for(let ii=0;ii<tet_obj.cuts.length; ii++){
                    if(tet_obj.cuts[ii].cut === this.selected_cut){
                        return; // we already have a cut selected for the correct trial-tet
                    }
                }
            }
        }
        this.set('selected_cut', trial && tet_obj && tet_obj.cuts.length ?
                        (tet_obj.last_used_cut || tet_obj.cuts[0].cut) : null);               
    }, _dragover: function(e){
        if(this.is_dragging_out) return;
        
        e.stopPropagation();
        e.preventDefault();
        e.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
        this._setIs_dragging_in(true);
        // TODO: use all the drag events correctly
        // drag over is fired every few ms, show dragging notification for at least 500ms 
        clearTimeout(this._drag_end_timer)
        this._drag_end_timer = setTimeout(this._cancel_drag.bind(this),500); 

    }, _switched_selection: function(){
        // called via debounce when trial/tet/cut is changed

        var trial = this._trial_from_base.get(this.selected_trial);
        var tet_obj = trial && this._get_tet_obj(trial, this.selected_tet_num, false);
        var cut = this.selected_cut;
        var title = this.selected_trial ?  this.selected_trial + " [Waveform]" : "Waveform";
        var url = location.pathname + "?";
        url += this.selected_trial ? "exp=" + this.selected_trial + "&" : "";
        url += this.selected_tet_num > 0? "tet=" + this.selected_tet_num : "";
        (!this.no_files) && window.history.pushState("", title,  url);
        document.title = title;
        this._setSelected_files({
            set: trial && trial.set ? trial.set : 0,
            pos: trial && trial.pos ? trial.pos : 0,
            tet: tet_obj && tet_obj.tet ? tet_obj.tet : 0,
            cut: cut ? cut : 0
        });
        this.$.trial_list.notifyResize();
    }, _drop: function(e){
        e.stopPropagation();
        e.preventDefault();
        this._setNo_files(false); // TODO: wait till we've actually processed the files
        this._cancel_drag();
        var files = e.dataTransfer.files; // FileList object.
           
        var regex_file_ext = /\.([0-9a-z]+)$/i;
        var ignore_exts = new Set(['eeg', 'egf', 'eeg2', 'egf2', 'inp']); 
        var files_for_base = new Map();
        var pending_cut_files = [];

        // get lists of pos,set,tet files for each trial, and a single list of all cut files
        // and also store a reference to all those files by fkey
        for(let ii=0; ii< files.length; ii++){
            let ff = files[ii];
            let fname = ff.name;
            let ext = regex_file_ext.exec(fname);
            let base; // we will leave/set as undefined if we don't care about the file
            
            if (ext){
                ext = ext[1].toLowerCase();
                base = fname.slice(0, fname.length-ext.length-1);

                if(ext === "pos" || ext === "set"){
                    // good
                } else if(ignore_exts.has(ext)){
                    continue;
                } else if(ext === "cut"){
                    pending_cut_files.push(files[ii]);
                    base = undefined;
                } else if(!isNaN(parseInt(ext))){
                    if(base.slice(-4) === ".clu"){
                        if(base.slice(-9) === ".temp.clu"){
                            continue;
                        } else {
                            pending_cut_files.push(files[ii]);
                            base = undefined;
                        }
                    } else if(base.slice(-4) === ".fet" ||
                              base.slice(-4) === ".klg" ){
                        continue;
                    } // else a tet file
                } else {
                    continue; // entirely unknown file type
                }

                // store permanent reference to the file
                let fkey = Utils.file_manager.to_fkey(files[ii]);
                if(base){
                    // unless it was a cut, we now know the base ok...
                    let trial_files = files_for_base.get(base);
                    if(!trial_files){
                        trial_files = new Set();
                        files_for_base.set(base, trial_files);
                    }
                    trial_files.add(fkey);
                }
            }
        }
        
        // try and assign cuts based on available trial bases (from this and previous drops)
        var all_bases = new Set();
        for(let [b, ignore] of this._trial_from_base){
            all_bases.add(b);
        }
        for(let [b, ignore] of files_for_base){
            all_bases.add(b);
        }
        var re = Utils.regex_from_list(Array.from(all_bases));
        var difficult_cut_files = [];
        if(re){
            while(pending_cut_files.length){
                let ff = pending_cut_files.pop();
                match = re.exec(ff.name);
                if(match){
                    match = match[0];
                    let trial_files = files_for_base.get(match);
                    if(!trial_files){
                        trial_files = new Set();
                        files_for_base.set(match, trial_files);
                    }
                    let fkey = Utils.file_manager.to_fkey(ff);
                    trial_files.add(fkey);
                } else {
                    let ext = regex_file_ext.exec(ff.name)[1].toLowerCase();
                    if(ext === "cut"){
                        difficult_cut_files.push(ff);
                    } // if it's a clu file we're stuffed
                }
            }       
        } else {
            difficult_cut_files = pending_cut_files;
        }

        if(difficult_cut_files.length){
            this._worker = this._worker || Polymer.DomModule.import('file-organiser', '#cut_reader').create_for(this);
            this._worker.exec('get_base_for_cuts', difficult_cut_files);
        }

        var trials = this.trials; // we are going to make a lot of changes to this, so we do a hack-ed notify-all at the end
        var available_tets = new Set(this.available_tets); // we want this as a set for use bellow...
        for(let [base, trial_files] of files_for_base){
            let trial = this._trial_from_base.get(base);
            if(!trial){
                trial = this._new_trial(base);
                this._trial_from_base.set(base, trial);
                trials.push(trial);
            }
            for(let fkey of trial_files){
                let ff = fkey.file;
                let ext = regex_file_ext.exec(ff.name)[1].toLowerCase();
                if(ext === "set"){
                    trial.set = fkey;
                } else if(ext === "pos"){
                    trial.pos = fkey;
                } else if (ext === "cut"){
                    // note we sort and de-dupe cuts at the end of the trial_files loop (TODO: that)
                    let num = ff.name.match(this._regex_cut_tet_num);
                    if(num){
                        num = parseInt(num[1]);
                        tet_obj = this._get_tet_obj(trial, num, true);
                        available_tets.add(num);
                        tet_obj.cuts.push({
                            cut: fkey,
                            cut_type: 'cut',
                            short_name: ff.name.replace(base, '~')
                        });
                    } 
                } else {
                    let tet_num = parseInt(ext);
                    let tet_obj = this._get_tet_obj(trial, tet_num, true);
                    available_tets.add(tet_num);
                    if(ff.name.slice(-ext.length-".clu".length -1, -ext.length-1) === ".clu"){
                        // clu file
                        tet_obj.cuts.push({
                            cut: fkey,
                            cut_type: 'clu',
                            short_name: ff.name.replace(base, '~')
                        });
                    } else {
                        // tet file
                        tet_obj.tet = fkey;
                    }
                }
            }
            this._sort_trial_innards(trial); // sort tets and cuts
        }


        trials.sort(function(a,b){
            return a.name > b.name ? 1 : -1;
        })
        available_tets = Array.from(available_tets);
        available_tets.sort(this._numeric_sort);
        this._setAvailable_tets(available_tets);
        this._reassign_trials_denovo(); // notify absolutely everything !!!

        if(this._use_url_search){
            // note we do this before sorting all the cuts, but whatever
            let match = (/exp=([^&]+)/g).exec(this._use_url_search);
            let url_trial = match && decodeURIComponent(match[1]);
            match = (/tet=([^&]+)/g).exec(this._use_url_search);
            let url_tet_num = match && parseInt(decodeURIComponent(match[1]));
            if(url_trial && this._trial_from_base.has(url_trial)){
                this.$.trial_list.selectItem(this._trial_from_base.get(url_trial));
            }
            if(url_tet_num && this.available_tets.indexOf(url_tet_num) > -1){
                this.set('selected_tet_num', url_tet_num);
            }
        }
        this._use_url_search = null;
    }, _new_trial: function(base){
        return {
            name: base,
            tets: [],
            set: undefined,
            set_caption: undefined,
            pos: undefined,
            pos_caption: undefined
        };
    }, _sort_trial_innards: function(trial){
        // sort tets for the trial
        trial.tets = trial.tets.sort(function(a,b){
            return a.tet_num > b.tet_num ? 1 : -1;
        })

        // de-dupe cuts and sort by name and last-modified date
        // TODO: deal with cut obj kind
        for(let tet_obj of trial.tets){
            if(tet_obj.cuts.length > 1){
                let name_and_time_strs = new Set()
                for(let jj=0; jj<tet_obj.cuts.length; jj++) {
                    if(!tet_obj.cuts[jj].date_name_str){
                        let ff = tet_obj.cuts[jj].cut.file;
                        let d = tet_obj.cuts[jj].date = ff.lastModified;
                        tet_obj.cuts[jj].date_name_str = d + " " + ff.name;
                    }
                    if(name_and_time_strs.has(tet_obj.cuts[jj].date_name_str)){
                        tet_obj.cuts.splice(jj--, 1); // i.e. remove this cut
                    } else {
                        name_and_time_strs.add(tet_obj.cuts[jj].date_name_str);
                    }
                }
                tet_obj.cuts.sort(function(a,b){
                    return b.date - a.date;
                });
            }
        }
    }, _get_tet_obj: function(trial, tet_num, push_if_needed){
        // adds it to trial.tets if it doesn't exist
        for(let tet_obj of trial.tets){
            if(tet_obj.tet_num === tet_num){
                return tet_obj;
            }
        }
        if(push_if_needed){
            var tet_obj = {
                tet_num: tet_num,
                last_used_cut: null,
                cuts: []
            };
            trial.tets.push(tet_obj);
        }
        return tet_obj;

    }, _cancel_drag: function(){
        clearTimeout(this._drag_end_timer);
        this._drag_end_timer = 0;
        this._setIs_dragging_in(false);
    }, _show: function(v){
        return v ? '' : 'none';
    }, _scroll_shadow: function(v){
        return v ? 'box-shadow: 0px 3px 4px 0px #bbb;z-index: 1;' : '';
    }, _selected: function(v){
        return v ? 'selected' : '';
    }, _selected_equality: function(a, b){
        return a && a === b ? "selected" : "";
    }, _make_trial_captions: function(e){
        var model = e.model;
        if(!model.trial.set_caption && model.trial.set){
            model.set('trial.set_caption', this._caption_from_file(model.trial.set.file));
        }
        if(!model.trial.pos_caption && model.trial.pos){
            model.set('trial.pos_caption', this._caption_from_file(model.trial.pos.file));
        }
    }, _make_tet_captions: function(e){
        var model = e.model;
        if(!model.tet_block.tet_caption && model.tet_block.tet){
            model.set('tet_block.tet_caption', this._caption_from_file(model.tet_block.tet.file));  
        }
        for(let ii=0; ii<model.tet_block.cuts.length; ii++){
            if(!model.tet_block.cuts[ii].caption){
                model.set('tet_block.cuts.' + ii + '.caption', this._caption_from_file(model.tet_block.cuts[ii].cut.file));   
            }
        }
    }, _caption_from_file: function(file){
         // Note that reading file.lastModified is slow, so we only call this func when needed
         var d = new Date(file.lastModified);
         return file.name + " (" + this._byte_formatter.format(file.size/1204) + 
                "KB)\nmodified at " + this._time_formatter.format(d)
                 + " on " + this._date_formatter.format(d);
    }, _numeric_sort: function(a,b){
        return a-b; 
    }, _reassign_trials_denovo: function(){
        // TODO: see https://github.com/Polymer/polymer/issues/2279

        this._setTrials(Utils.deep_clone(this.trials));
        this._trial_from_base.clear();
        for(let trial of this.trials){
            this._trial_from_base.set(trial.name, trial);
        }
        this.$.trial_list.notifyResize();
    }, got_base_for_cuts: function(results){
        // TODO: there is a lot of copy-paste from main drop function, should fix that really.
        var trials = this.trials;
        var available_tets = new Set(this.available_tets); // we want this as a set for use below...
        var modified_trials = new Set(); // we will sort the innards of these trials at the end
        for(let result of results){
            let base = result.base;
            let ff = result.file;
            let trial = this._trial_from_base.get(base);
            if(!trial){
                trial = this._new_trial(base);
                trials.push(trial);
                this._trial_from_base.set(base, trial);
            }
            let num = ff.name.match(this._regex_cut_tet_num);
            if(num){
                num = parseInt(num[1]);
                tet_obj = this._get_tet_obj(trial, num, true);
                available_tets.add(num);
                let fkey = Utils.file_manager.to_fkey(ff);
                tet_obj.cuts.push({
                    cut: fkey,
                    cut_type: 'cut',
                    short_name: ff.name.replace(base, '~')
                });
            } 
            modified_trials.add(trial);
        }
        for(let trial of modified_trials){
            this._sort_trial_innards(trial);
        }   
        trials.sort(function(a,b){
            return a.name > b.name ? 1 : -1;
        })
        available_tets = Array.from(available_tets);
        available_tets.sort(this._numeric_sort);
        this._setAvailable_tets(available_tets);
        this._reassign_trials_denovo();     
    },
     _regex_cut_tet_num: /(\d*)[a-zA-Z _]*\.cut$/
    , _cut_dragstart: function(e){
        // this is enabled in css only for stack-type cuts
        let model = e.model;
        let trial_base = model.dataHost.dataHost.dataHost.dataHost.trial.name; // https://github.com/Polymer/polymer/issues/1919
        let tet_num = model.dataHost.dataHost.tet_block.tet_num;
        let cut = model.cut.cut;
        let filename = trial_base + "_" + tet_num + ".cut";
        let blob_url = cut.get_blob_url(trial_base);

        e.dataTransfer.setData("DownloadURL", 'application/octet-stream:' + filename +':' + blob_url);12
        this._setIs_dragging_out(true);
        return true;
     }, _cut_dragend: function(e){
        this._setIs_dragging_out(false);
     }, _on_numeric_key: function(e){
        let num = parseInt(e.detail.keyboardEvent.code.slice("Digit".length)); // TODO: is there a better way of doing this?
        let current_tens = 0|(this.selected_tet_num/10);
        num = current_tens*10 + num;
        if(this.available_tets.indexOf(num) > -1){
            this.set('selected_tet_num', num);
        }
     }, _on_tens_key: function(){
        let max_tet_tens = 0|(this.available_tets.slice(-1)[0]/10);
        let current_tens = 0|(this.selected_tet_num/10);
        current_tens = (current_tens + 1) % (max_tet_tens+1)
        let num = current_tens*10 + (this.selected_tet_num % 10);
        if(this.available_tets.indexOf(num) > -1){
           this.set('selected_tet_num', num);
        }
     }
})

</script>
</dom-module><dom-module is="drop-zone">

<style>
.border {
position: fixed;
margin: 40px;
border: 10px dashed #999;
right: 0px;
left: 0px;
bottom: 0px;
top: 0px;
}
:host{
position: fixed;
left: 0px;
right: 0px;
top: 0px;
bottom: 0px;
display: block;
color: #888;
z-index: 100;   
pointer-events: none;
}
.centre_content{
text-align: center;
position: relative;
margin: 0 auto;
height: 100%;
pointer-events: initial;
}
.centre_content_inner{
position: relative;
top: 50%;
transform: translateY(-60%);
display: inline-block;
}
.primary_text{
font-size: 52px;
margin-bottom: 20px;
}
.secondary_text{
font-size: 12px;
}
.initial_extra_under_title{
font-size: 12px;
}
.backstop{
position: absolute;
top: 0px;
left: 0px;
width: 100%;
height: 100%;
background: #fff;
}
.initial_extra_bottom_right{
position: absolute;
bottom: 60px;
right: 60px;
text-align: right;
}
.centre_content_inner:before{
position: absolute;
width: 120%;
height: 160%;
margin-left: -60%;
content: '';
z-index: -1;
background: radial-gradient(ellipse at center, rgba(255,255,255,1) 30%,rgba(255,255,255,1) 50%,rgba(255,255,255,0) 70%,rgba(255,255,255,0) 100%);
margin-top: -8%;
}

@-webkit-keyframes spaceboots {
    /* Taken from http://www.cssreset.com/demos/css3/webkit-animation-shake-links/spaceboots.html */
    0%   { -webkit-transform: translate(2px, 1px)   rotate(0deg); }
    10%  { -webkit-transform: translate(-1px, -2px) rotate(-1deg); }
    20%  { -webkit-transform: translate(-3px, 0px)  rotate(1deg); }
    30%  { -webkit-transform: translate(0px, 2px)   rotate(0deg); }
    40%  { -webkit-transform: translate(1px, -1px)  rotate(1deg); }
    50%  { -webkit-transform: translate(-1px, 1px)  rotate(-1deg); }
    60%  { -webkit-transform: translate(-3px, -2px)  rotate(0deg); }
    70%  { -webkit-transform: translate(2px, 1px)   rotate(-1deg); }
    80%  { -webkit-transform: translate(-1px, -2px) rotate(1deg); }
    90%  { -webkit-transform: translate(2px, -1px)   rotate(0deg); }
    100% { -webkit-transform: translate(1px, -2px)  rotate(-1deg); }
}
.wibbly_wobbly{
    -webkit-animation-name: 'spaceboots';
    -webkit-animation-duration: 0.8s;
    -webkit-transform-origin:50% 50%;
    -webkit-animation-iteration-count: infinite;
    -webkit-animation-timing-function: linear;    
}
</style>


<template>
<div class="backstop" style$="[[_show(show_initial)]]"></div>
<div class="border" style$="[[_show(show_initial)]]"></div> 

<div class="centre_content" style$="[[_show(drop_in_progress, show_initial)]]"><div class="centre_content_inner">
    <div class$="primary_text [[_wobble(drop_in_progress)]]"><content select=".primary_text"></content></div>
    <div class="secondary_text"><content select=".secondary_text"></content></div>
    <div class="initial_extra_under_secondary" style$="[[_show(show_initial)]]"><content select=".initial_extra_under_secondary"></content></div>
</div></div>

<div class="initial_extra_bottom_right" style$="[[_show(show_initial)]]">
    <content select=".initial_extra_bottom_right"></content>
</div>
</template>

<script>
    Polymer({
        is: 'drop-zone',
        properties: {
            show_initial: {
                type: Boolean,
                value: true,
                notify: true
            },
            drop_in_progress: {
                type: Boolean,
                value: false,
                notify: true
            }
        }, _show: function(a,b){
            return a || b ? '' : 'display:none;';
        }, _wobble: function(a){
            return a ? 'wibbly_wobbly' : '';
        }
    })
</script>
</dom-module>

<dom-module id="floating-pane" assetpath="/">

<style>
.pane_title{
background: #333;
color: #fff;
font-weight: bold;
padding: 5px;
display: flex;
flex-direction: row;
min-height: 14px;
}
:host{
position: fixed;
top: 0px;
left: 0px;
min-width: 200px;
max-width: 400px;
max-height: 600px;
background-color: rgba(255,255,255,0.92);
z-index: 100;
cursor: move;
box-shadow: 3px 3px 7px #999;
display: flex;
flex-direction: column;
}
::-webkit-scrollbar {
width: 10px;
height: 10px;
}
::-webkit-scrollbar-button {
width: 0;
height: 0;
display: none;
}
::-webkit-scrollbar-thumb {
background-color: rgba(0,0,0,0.2);
-webkit-box-shadow: inset 1px 1px 0 rgba(0,0,0,0.10),inset 0 -1px 0 rgba(0,0,0,0.07);
}
.pane_title.wide{
min-width: 360px;
}
.pane_body{
padding: 5px;
border: 1px solid #000;
flex: 2;
overflow-y: auto;
}
.grabber{
position: absolute;
top: 0px;
left: 0px;
right: 0px;
bottom: 0px;
}
.grabber:hover{
@apply(--grabber-hover);
}
::content > .nodrag{
cursor: default;
display: table; /* gives auto width, while still being display-block-like */
}
input{
font-size: 0.8em;
width: 130px;
margin: -2px;
}
.flexer{
flex:2;
display: inline-block;
}
</style>
<template>
    <div class$="pane_title [[_wide(has_search)]]">
        <content select=".pane_title"></content>
        <div class="flexer"></div>
        <input id="search_input" type="search" hidden$="{{!has_search}}" value="{{search_text::input}}" placeholder="[[search_placeholder]]" on-focus="_search_focus" on-blur="_search_blur" on-mousedown="_stop_propagation">
    </div>
    <div class="pane_body"><content></content></div>
    <div class="grabber" hidden$="{{!grabber_mode}}" on-mouseup="toggle"></div>
</template>

<script>

(function(){

var top_z_index = 100;

Polymer({
    is: 'floating-pane',
    behaviors: [Polymer.IronResizableBehavior],
    properties: {
        grabber_mode: {
            type: Boolean,
            value: false,
            notify: true
        },
        has_search: {
            type: Boolean,
            value: false,
            notify: true
        },
        search_text: {
            type: String,
            value: "",
            notify: true
        },
        search_placeholder: {
            type: String,
            value: "search",
            notify: true,   
        },
        disable_shortcuts: {
            type: Boolean,
            notify: true,
            value: false
        },
        initial_x:{
            type: Number,
            notify: true,
            value: 400
        },
        initial_y:{
            type: Number,
            notify: true,
            value: 400
        }, 
        width: {
            type: String,
            notify: true,
            value: '',
            observer: '_set_width'
        }
    }, listeners: {
        'mousedown': '_on_drag_start'
    }, observers: [
        '_set_initial_position(initial_x, initial_y)'
    ], attached: function(){
        this.style.zIndex = ++top_z_index;
    }, _stop_propagation: function(e){
        e.stopPropagation(); 
    }, _set_width: function(v){
        if(v){
            this.style.width = v;
            this.style.maxWidth = 'initial';    
            this.style.minWidth = 'initial';
        } else {
            this.style.width = '';
            this.style.maxWidth = '';   
            this.style.minWidth = '';
        }
    }, _on_drag_start: function(e){
        // if the mouse-down element or any of its ancestors has the "nodrag" class then dont start the dragging.
        // TODO: switch to using Polymer's tap event
        var el = e.target;
        while(el !== e.currentTarget){
            for(let c of el.classList){
                if(c === 'nodrag'){
                    return;   
                }
            }
            el = el.parentNode;
        }
        var offset = this.getBoundingClientRect();
        e.preventDefault();
        this.style.zIndex = ++top_z_index;
        this._drag_off_left = e.clientX-offset.left;
        this._drag_off_top = e.clientY-offset.top;
        if(! this._on_drag_move_bound){
            this._on_drag_move_bound = this._on_drag_move.bind(this);
            this._on_drag_end_bound = this._on_drag_end.bind(this);
        }        
        document.addEventListener('mousemove', this._on_drag_move_bound, true);
        document.addEventListener('mouseup', this._on_drag_end_bound, true); 
    }, _on_drag_move: function(e) {
        this._translate(e.clientX - this._drag_off_left, e.clientY - this._drag_off_top);
    }, _on_drag_end: function(e){
        document.removeEventListener('mousemove', this._on_drag_move_bound, true);
        document.removeEventListener('mouseup', this._on_drag_end_bound, true); 
    }, _translate: function(x, y){
        this.transform('translate(' + x + "px, " + y + "px)");
    }, _wide: function(v){
        return v ? "wide" : "";
    }, toggle: function(){
        if(this.hidden){
            this.removeAttribute('hidden');
            this.style.zIndex = ++top_z_index;
        } else {
            this.setAttribute('hidden', "true");            
            this.fire('close')
        }
        this.notifyResize();
    }, _search_focus: function(){
        this.set('disable_shortcuts', true); 
    }, _search_blur: function(){
        this.set('disable_shortcuts', false);
    }, _set_initial_position: function(x, y){
        this._translate(x, y);
    }
});


})();
</script>
</dom-module><dom-module id="document-focus-marker" assetpath="/">

<style>
:host{
position: absolute;
top: 0px;
left: 0px;
bottom: 0px;
right: 0px;
border: 20px solid rgba(255,0,0,0.2);
opacity: 0;
pointer-events: none;
};
</style>
<template></template>

<script>


Polymer({
    is: 'document-focus-marker',
    properties: {
        is_focused: {
            type: Boolean,
            value: true,
            notify: true,
            readOnly: true
        }
    }, created: function(){
        // bind these methods so we can add/remove easily
    
    }, attached: function(){
        var self = this;
        window.addEventListener('blur', function(e){
            if(e.target === window){
                self._setIs_focused(false);
                self.style.opacity = '1';               
            }
        }, true);
        window.addEventListener('focus', function(){
            self._setIs_focused(true);
            self.style.opacity = '0';
        }, true);   
        getComputedStyle(this).backgroundColor; // force original 0 opacity to take effect
        this.style.transition = 'opacity 2s';           
    }
});


</script>
</dom-module><dom-module id="header-view" assetpath="/">   

<style>
.header_item{
font-weight: bold;
font-size: 14px;
padding-top: 10px;
border-bottom: 1px solid #948A8A;
}
.item_key,
.item_value{
display: inline-block;
text-overflow: ellipsis;
overflow: hidden;
}
.not_showing{
display: none;
}
.entry_item{
white-space: nowrap;
cursor: default;
}
.item_key{
font-weight: bold;
width: 40%;
background: rgba(106, 119, 130, 0.18);
}
.item_value{
background: rgba(106, 119, 130, 0.08);  
width: 60%;
}
iron-list {
height:500px;
overflow-x: hidden !important;
width: 100%;
--iron-list-items-container: {
  };
}
::-webkit-scrollbar {
width: 10px;
height: 10px;
}
::-webkit-scrollbar-button {
width: 0;
height: 0;
display: none;
}
::-webkit-scrollbar-thumb {
background-color: rgba(0,0,0,0.2);
-webkit-box-shadow: inset 1px 1px 0 rgba(0,0,0,0.10),inset 0 -1px 0 rgba(0,0,0,0.07);
}
.file_name{
font-size: 10px;
display: inline-block;
margin-left: 3px;
font-weight: initial;
color: #1A64A5;
}
.row{
padding-top: 2px;
}
:host{
width: 100%;
}
</style>
<template>
    <iron-list id="the_list" items="{{_build_array(set_header, pos_header, tet_header, cut_header, header_filter, is_showing)}}" as="item">
        <template><div class="row">
            <div class$="[[item.class_a]]">
                [[item.name]]
                <div class="file_name">[[item.value]]</div>
            </div>
            <div class$="[[item.class_b]]">
                <div class="item_key" title="[[item.name]]">[[item.name]]</div>
                <div class="item_value" title="[[item.value]]">[[item.value]]&nbsp;</div>
            </div>
        </div></template>
    </iron-list>
</template>

<script>


Polymer({
    is: 'header-view',
    behaviors: [Polymer.IronResizableBehavior],
    listeners: {
        'iron-resize': '_on_resize'
    },
    properties: {
        header_filter: {
            type: String,
            value: "",
            notify: true
        },
        pos_header: {
            type: Object,
            value: function(){ return {};},
            notify: true
        },
        set_header: {
            type: Object,
            value: function(){ return {};},
            notify: true
        },
        tet_header: {
            type: Object,
            value: function(){ return {};},
            notify: true
        },
        cut_header: {
            type: Object,
            value: function(){ return {};},
            notify: true
        },
        is_showing: {
            type: Boolean,
            value: false,
            notify: true,
            readOnly: true
        }
    }, observers: [
        "_clear_cache('pos', pos_header)",
        "_clear_cache('set', set_header)",
        "_clear_cache('tet', tet_header)",
        "_clear_cache('cut', cut_header)"
    ], created: function(){
        this._cache = {};
        this._cached_for = {}; // if _clear_cache was guaranteed to be called before _build_array we wouldn't need this
    }, _on_resize: function(){
        let showing = true;
        let node = this.parentNode;
        while(node){
            if(node.hidden){
                showing = false;
                break;
            }
            node = node.parentNode;
        }
        this._setIs_showing(showing);
    }, _clear_cache: function(t, ignored){
        this._cache[t] = undefined;
        this._cached_for[t] = undefined;
    }, _build_array: function(set_header, pos_header, tet_header, cut_header, header_filter, is_showing) {
            if(!this.is_showing){
                return [];
            }
            var a = [];         
            for(let t of new Set(['tet', 'cut', 'pos', 'set'])){
                let header = this[t + '_header'];
                if(!header || !Object.keys(header).length){
                    continue;
                }
                if (this._cache[t] && this._cached_for[t] === header){
                    a = a.concat(this._cache[t]);
                    continue;
                } 
                let arr = Object.keys(header).map(function(key){
                    return {
                        is: 'item',
                        class_a: 'not_showing',
                        class_b: 'entry_item',
                        name: key + "",
                        value: header[key] + ""
                    };
                }).sort(function(a,b){
                    return a.name > b.name ? 1 : -1;
                });
                arr.splice(0, 0, {
                    is: 'header',
                    class_a: 'header_item',
                    class_b: 'not_showing',
                    name: "." + t,
                    value: header.file
                });
                this._cache[t] = arr;
                this._cached_for[t] = header;
                a = a.concat(arr);

            }
            if(header_filter){
                header_filter = header_filter.toLowerCase();
                a = a.filter(function(item){
                    return item.is==='header' || item.name.toLowerCase().indexOf(header_filter) !== -1 || item.value.toLowerCase().indexOf(header_filter) !== -1;
                });         
            }
            return a;
        }
});


</script>
</dom-module><dom-module id="value-transform" assetpath="/">
<template></template>
<script>
    "use strict";
    Polymer({
        is:'value-transform',
        properties: {
            value_a: {
                notify: true
            },
            value_b: {
                notify: true
            },
            a_to_b: {
                type: String
            },
            b_to_a: {
                type: String
            }
        }, observers: [
            '_value_a_changed(value_a.*)',
            '_value_b_changed(value_b.*)'
        ], attached: function(){
            let host = this.domHost || this.dataHost; // TODO: is that right?
            this._a_to_b_func = host ? host[this.a_to_b] : null;
            this._b_to_a_func = host ? host[this.b_to_a] : null;
            this._is_attached = true;
        }, _value_a_changed: function(e){
            if(this._changing || !this._is_attached){
                return;
            }
            this._changing = true;            
            if(this._a_to_b_func){
                this.set('value_b', this._a_to_b_func(this.value_a));
            } else {
                let sub_path =  e.path.slice("value_a".length);
                if(sub_path && !this.value_b){
                    this.set('value_b', this.value_a);
                } else {
                    this.set('value_b' + sub_path, e.value);
                }
            }
            this._changing = false;
        }, _value_b_changed: function(e){
            if(this._changing || !this._is_attached){
                return;
            }
            this._changing = true;
            if(this._b_to_a_func){
                this.set('value_a', this._b_to_a_func(this.value_b));
            } else {
                let sub_path =  e.path.slice("value_b".length);
                if(sub_path && !this.value_a){
                    this.set('value_a', this.value_b);
                } else {
                    this.set('value_a' + sub_path, e.value);
                }
            }
            this._changing = false;
        }
    });
</script>
</dom-module><dom-module id="rm-plots" assetpath="/">

<script is="worker-builder" id="worker" title="rm-plots" type="javascript/worker">
"use strict";

var render_options = {
    cm_per_spa_bin: undefined,
    smoothing_spa_bins: undefined,
    max_rate_spa: undefined,
    deg_per_dir_bin: undefined,
    smoothing_dir_bins: undefined,
    max_speed: undefined,
    cps_per_speed_bin: 4 // currently not exposed as a user-configurable
};
var speed_plot_size = [20, 46]; // might want to upgraded this to render_options
var dir_plot_size = 78;

var pi = 3.14159265;

var show;
var spike_times;
var spikes_timebase;
var pos_timebase; // Note that changing the pos timebase will force clear all pos_xy, pos_dir, and pos_speed
var pos_xy;
var xy_max;
var pos_units_per_cm;
var pos_dir;
var pos_speed;
var pkey_to_array = new Map(); // Note that in the worker, key's are used only for arrays of spike-indices.
var pkey_to_rendered_options = new Map(); 
var pkeys_pending_render = [];
var timer;
var pkey_generation = 0;
var pending_path_plot = null;

// cached stuff.... see clear_cache for logic for cleaning the cache
var cached_spike_pos_ind;
var cached_xy_bins;
var cached_xy_dwell;
var cached_xy_no_dwell;
var cached_dir_bins;
var cached_dir_dwell;
var cached_speed_bins;
var cached_speed_dwell;
var cached_spike_xy_bins;
var cached_spike_dir_bins;
var cached_spike_speed_bins;
var cached_path;

var n_bins_xy_0, n_bins_xy_1; //these are cached as well, but they are managed as a "side effect" of xy_bins
var cached_spike_xy_raw; // and this is managed as a "side effect" of cached_spike_xy_bins

var palette = function(){
    var p_colors = 5;
    var buf8 = new Uint8Array(4*(p_colors+1));

    //set all alpha values to opaque
    for(var i=0;i<=p_colors;i++)
        buf8[i*4+3] = 255;

    //buf8[0*4+0]= 255; buf8[0*4+1]=255; buf8[0*4+2]=255; //white
    buf8[0*4+3]= 0; // invisible
    buf8[1*4+2]= 198;
    buf8[2*4+1]= 162; buf8[2*4+2]= 255; 
    buf8[3*4+0]= 56; buf8[3*4+1]= 235; buf8[3*4+2]= 32; 
    buf8[4*4+0]= 248; buf8[4*4+1]= 221; 
    buf8[5*4+0]= 255; buf8[5*4+1]= 32;

    return new Uint32Array(buf8.buffer); //this is how to_image_data function wants it
}();

var set_show = function(v){
    show = v;
    build_cache();
    make_all_pkeys_pending(); // this may be slightly overkill, but when it comes down to it we will only render stuff that needs it
    touch_timer();
}

var set_options = function(opts){
    let to_clear = [];
    for(let k in render_options){
        if(opts[k] !== undefined  && render_options[k] !== opts[k]){
            render_options[k] =  opts[k];
            to_clear.push(k);
        }
    }
    clear_cache(to_clear);
    build_cache();
    make_all_pkeys_pending();
    touch_timer();
}

var set_spike_times = function(timebase, arrays){
    clear_cache(['spikes_timebase', 'spike_times']);
    spikes_timebase = timebase;
    spike_times = arrays && arrays.data; 
    build_cache();
    make_all_pkeys_pending();
    touch_timer();
}

var set_pos_xy = function(timebase, units_per_cm, max_x, max_y, arrays){
    if(timebase && timebase != pos_timebase){
        pos_timebase = timebase;
        pos_xy = pos_dir = pos_speed = undefined;
        clear_cache(['pos_timebase', 'pos_xy', 'pos_dir', 'pos_speed']);
    } else {
        clear_cache(['pos_xy']);
    }
    pos_units_per_cm = units_per_cm; // note that dir and speed are already in their final units
    xy_max = [max_x, max_y];
    pos_xy = arrays && arrays.data;

    build_cache();
    make_all_pkeys_pending();
    touch_timer();

}

var set_pos_dir = function(timebase, arrays){
    if(timebase && timebase != pos_timebase){
        pos_timebase = timebase;
        pos_xy = pos_dir = pos_speed = undefined;
        clear_cache(['pos_timebase', 'pos_xy', 'pos_dir', 'pos_speed']);
    } else {
        clear_cache(['pos_dir']);
    }
    pos_dir = arrays && arrays.data;
    build_cache();
    make_all_pkeys_pending();
    touch_timer();
}

var set_pos_speed = function(timebase, arrays){
    if(timebase && timebase != pos_timebase){
        pos_timebase = timebase;
        pos_xy = pos_dir = pos_speed = undefined;
        clear_cache(['pos_timebase', 'pos_xy', 'pos_dir', 'pos_speed']);
    } else {
        clear_cache(['pos_speed']);
    }
    pos_speed = arrays && arrays.data;
    build_cache();
    make_all_pkeys_pending();
    touch_timer();
}

var make_all_pkeys_pending = function(){
    pkeys_pending_render = Array.from(pkey_to_array.keys());
}


var update_pkeys = function(changes, arrays){

    if(changes.generation_remove !== pkey_generation){
        changes.remove = [];
        pkey_to_array.clear();
        pkey_to_rendered_options.clear();
        pkeys_pending_render = [];
        console.log("rm-plots worker: key generation mismatch");
    }

    // note we don't both to remove keys from the pending list
    // unless we change key generation, in which case we drop 
    // everything that's pending. This is ensures that when we
    // attempt a render we can be sure that if we do find the
    // array for the given key we know it's for the relevant 
    // generation and that it's still wanted.

    var remove_pkeys = changes.remove || [];
    for(let pkey of remove_pkeys){
        pkey_to_array.delete(pkey);
        pkey_to_rendered_options.delete(pkey);
    }

    if(changes.generation_add !== changes.generation_remove){
        pkeys_pending_render = [];
        pkey_generation = changes.generation_add;
        pending_path_plot = null;
    }

    var add_pkeys = changes.add || [];
    for(let pkey of add_pkeys){
        pkey_to_array.set(pkey, arrays[pkey]);
        pkeys_pending_render.push(pkey);
    }

    touch_timer();        
}

var touch_timer = function(){

    // turns timer on if there's work to be done, otherwise stops it (if it was running)
    // note it's not actually a timer, because the interval is zero!
    // the point of using this is that it enables messages from main thread to interupt
    // between ticks, we can thus cancel work as an when needed.

    if((spike_times && pkeys_pending_render.length && 
            show && show !== 'nnn' &&
            (show[0] === 'n' || cached_xy_bins) && (show[1] === 'n' || cached_dir_bins) 
            && (show[2] === 'n' || cached_speed_bins)) || 
        (pending_path_plot && can_process_plot_path())){
        
        timer = timer || setImmediate(timer_tick);
    } else {
        clearImmediate(timer);
        timer = 0;
    }
}

var options_match = function(a, b, kind){
    // copy-pasted from main thread version at bottom of file
    if((!a && b) || (a && !b)){
        return false;
    }
    if(kind === "spa"){
        return a.smoothing_spa_bins === b.smoothing_spa_bins
            && a.cm_per_spa_bin === b.cm_per_spa_bin
            && a.max_rate_spa === b.max_rate_spa;
    }
    if(kind === "dir"){
        return a.smoothing_dir_bins === b.smoothing_dir_bins
            && a.deg_per_dir_bin === b.deg_per_dir_bin;
    }
    if(kind === "speed"){
        return a.max_speed === b.max_speed
            && a.cps_per_speed_bin === b.cps_per_speed_bin;
    }
    throw "what kind?";
}

var copy_options = function(dest, src, kind){
    // copy-pasted from main thread version at bottom of file
    if(kind === "spa"){
        dest.smoothing_spa_bins = src.smoothing_spa_bins;
        dest.cm_per_spa_bin = src.cm_per_spa_bin;
        dest.max_rate_spa = src.max_rate_spa;
    } else if (kind === "dir"){
        dest.smoothing_dir_bins = src.smoothing_dir_bins;
        dest.deg_per_dir_bin = src.deg_per_dir_bin;
    } else if(kind === "speed"){
        dest.max_speed = src.max_speed;
        dest.cps_per_speed_bin = src.cps_per_speed_bin;
    } else {
        throw "what?"
    }
}

var timer_tick = function(){
    timer = 0;

    if(pending_path_plot && can_process_plot_path()){
        process_plot_path();
    } 

    let batch_limit = 5; // a bit arbitrary
    let arrays={};
    let msgs = [];

    // find batch_limit things to render...
    // this is somewhat ugly, but whatever.
    while(pkeys_pending_render.length > 0 && msgs.length < batch_limit){
        let pkey = pkeys_pending_render.shift();
        let pkey_rendered_options = pkey_to_rendered_options.get(pkey)
        let inds =  pkey_to_array.get(pkey);
        if(!pkey_rendered_options){
            pkey_rendered_options = { /* TODO: initialize using all values */};
            pkey_to_rendered_options.set(pkey, pkey_rendered_options);
        }
        if(pkey && inds && !is_equal_simple(pkey_to_rendered_options.get(pkey), render_options)){
            let msg = {
                pkey: pkey,
                generation: pkey_generation,
                render_options: render_options // note we send all options regardless of show 'n'
            }
            msgs.push(msg);
            if(show[0] === 'y' && !options_match(pkey_rendered_options, render_options, "spa")){
                    let res = get_group_xy_rm(inds);
                    msg.spa_rm = pkey + ' spa_rm';
                    msg.spa_max = res.max;
                    msg.spa_rm_dims = [n_bins_xy_1, n_bins_xy_0];
                    arrays[msg.spa_rm] = res.im;
                    copy_options(pkey_rendered_options, render_options, "spa");
            }

            if(show[1] === 'y' && !options_match(pkey_rendered_options, render_options, "dir")){
                    let res = get_group_dir_rm(inds);
                    msg.dir_rm = pkey + ' dir_rm';
                    msg.dir_max = res.max;
                    msg.dir_rm_dims = [dir_plot_size, dir_plot_size];
                    arrays[msg.dir_rm] = res.im;
                    copy_options(pkey_rendered_options, render_options, "dir");
            }

            if(show[2] === 'y' && !options_match(pkey_rendered_options, render_options, "speed")){
                let im = get_group_speed_rm(inds);
                msg.speed_rm = pkey + ' speed_rm';
                msg.speed_rm_dims = speed_plot_size;
                arrays[msg.speed_rm] = im;
                copy_options(pkey_rendered_options, render_options, "speed");
            }

        }
    }

    if(msgs.length){
        exec_main_b('plot_things', msgs, arrays);        
    }

    touch_timer();
}


//  The meat of the computation follows...
// =========================================================


var clear_cache = function(names){
    // This is a bit fiddly, but at least it's all in one place, right?!

    names = new Set(names);

    if(names.has('spikes_timebase') || names.has('pos_timebase') || names.has('spike_times')){
        cached_spike_pos_ind = undefined;
        cached_spike_xy_bins = undefined;
        cached_spike_xy_raw = undefined;
        cached_spike_dir_bins = undefined;
        cached_spike_speed_bins = undefined;
        pkey_to_rendered_options.clear(); //whatever we had is now irrelevant
    }

    if(names.has('pos_xy')){
        cached_path = undefined;
        let null_opts = {};
        for(let opts of pkey_to_rendered_options.values()){
            copy_options(opts, null_opts, "spa");
        }
    }
    if(names.has('pos_xy') || names.has('cm_per_spa_bin')){
        cached_xy_bins = undefined;
        cached_xy_dwell = undefined;
        cached_xy_no_dwell = undefined;
        cached_spike_xy_bins = undefined;
        cached_spike_xy_raw = undefined;
    } else if(names.has('smoothing_spa_bins')){
        cached_xy_dwell = undefined;
    }
     
    if(names.has('pos_dir')){
        let null_opts = {};
        for(let opts of pkey_to_rendered_options.values()){
            copy_options(opts, null_opts, "dir");
        }
    }
    if(names.has('pos_dir') || names.has('deg_per_dir_bin')){
        cached_dir_bins = undefined;
        cached_dir_dwell = undefined;
        cached_spike_dir_bins = undefined;
    } else if(names.has('smoothing_dir_bins')){
        cached_dir_dwell = undefined;
    }

    if(names.has('pos_speed')){
        let null_opts = {};
        for(let opts of pkey_to_rendered_options.values()){
            copy_options(opts, null_opts, "speed");
        }
    }
    if(names.has('pos_speed') || names.has('max_speed') || names.has('cps_per_speed_bin')){
        cached_speed_bins = undefined;
        cached_speed_dwell = undefined;
        cached_spike_speed_bins = undefined;
    }   

    // TODO: we could deal with adding more stuff to pending here perhaps??

}

var make_cached_path = function(){
    cached_path = draw_lines(pos_xy, 256, 256, 256/Math.max(xy_max[0], xy_max[1]));
     exec_main_b('plot_path', {
        path: 'path',
        dims: [256, 256],
    }, {
        path: new Uint32Array(cached_path)
    });
}

var send_speed_dwell_hist = function(){
    let im = plot_histogram(speed_plot_size[0], speed_plot_size[1], cached_speed_dwell);
     exec_main_b('plot_speed_hist', {
        path: 'hist',
        dims: speed_plot_size
    }, {
        hist: im
    });
}

var build_cache = function(){
    // this is called when we change xy/dir/speed/times/options/show
    // clear_cached will have been called immediately before hand.

    // using just pos timebas and spike times, we can get the pos indices for each spike
    if(!cached_spike_pos_ind && pos_timebase && spikes_timebase && spike_times){
        make_cached_spike_pos_ind();
    }    

    // it doesn't require spikes to just draw the path
    if(show && show[0] === 'y' && !cached_path && pos_xy){
        make_cached_path(); 
    }

    // it also doesn't require spikes to compute and draw the speed dwell hist
    if(show && show[2] === 'y' && !cached_speed_dwell && pos_speed
        && render_options.cps_per_speed_bin 
        && render_options.max_speed){
        make_cached_speed_bins_and_dwell();
        send_speed_dwell_hist(); 
    }

    // the rest requires spikes+xy/dir/speed

    if(show && show[0] === 'y'
         && !(cached_xy_bins && cached_xy_no_dwell && cached_xy_dwell && cached_spike_xy_bins)
         && pos_xy && cached_spike_pos_ind && render_options.cm_per_spa_bin 
         && render_options.smoothing_spa_bins !== undefined ){
        make_cached_xy_bins_and_dwell();    
    }

    if(show && show[1] === 'y'
        && !(cached_dir_bins && cached_dir_dwell && cached_spike_dir_bins)
        && pos_dir && cached_spike_pos_ind
        && render_options.deg_per_dir_bin 
        && render_options.smoothing_dir_bins !== undefined){
        make_cached_dir_bins_and_dwell();
    }

    if(show && show[2] === 'y'
        && !cached_spike_speed_bins
        && pos_speed && cached_spike_pos_ind
        && render_options.cps_per_speed_bin 
        && render_options.max_speed){
        make_cached_speed_spike_bins();
    }
}


var make_cached_spike_pos_ind = function(){    
    // cached_spike_pos_ind gives the indices into pos_xy, pos_dir, pos_speed for each spike

    cached_spike_pos_ind = new Uint32Array(spike_times.length);
    
    var factor = pos_timebase / spikes_timebase;
    for(let i=0; i<cached_spike_pos_ind.length; i++)
        cached_spike_pos_ind[i] = spike_times[i]*factor; //integer result, so implicitly the floor 

    return true;
}


var make_cached_xy_bins_and_dwell = function(){

    var factor = 1/pos_units_per_cm/render_options.cm_per_spa_bin;
    cached_xy_bins = new Uint8ClampedArray(pos_xy.length);
    for(let i=0;i<pos_xy.length;i++){
        cached_xy_bins[i] = pos_xy[i] * factor;           
    }
    
    //same form as cached_xy_bins, but we store it as 2byte blocks for easy picking
    cached_spike_xy_bins = pick(new Uint16Array(cached_xy_bins.buffer), cached_spike_pos_ind); 
                
    cached_spike_xy_raw = pick(new Uint32Array(pos_xy.buffer), cached_spike_pos_ind); // the _raw version if for plotting spikes on the path

    n_bins_xy_1 = Math.ceil(xy_max[1]*factor) + 1; // +1 is because of zero indexing
    n_bins_xy_0 = Math.ceil(xy_max[0]*factor) + 1;   

    var dwell = hist_2(cached_xy_bins, n_bins_xy_1, n_bins_xy_0);
    // TODO: check whether the zero bin has supuriously high data from NaN's, and force it to zero if needed

    //before we do the smoothing we need to remmber which bins were unvisted
    cached_xy_no_dwell = is_zero(dwell);

    //ok now we do the smoothing
    cached_xy_dwell = get_smoothed(dwell, n_bins_xy_1, n_bins_xy_0, render_options.smoothing_spa_bins);

    return true;
}


var make_cached_dir_bins_and_dwell = function(){

    var factor = 180/pi/render_options.deg_per_dir_bin;
    cached_dir_bins = new Uint8ClampedArray(pos_dir.length);
    for(let i=0;i<pos_dir.length;i++){
        cached_dir_bins[i] = pos_dir[i] * factor;
    }
    
    cached_spike_dir_bins = pick(cached_dir_bins, cached_spike_pos_ind); 

    var n_bins_dir = 360/render_options.deg_per_dir_bin;

    var dwell = hist_1(cached_dir_bins, n_bins_dir+1); //the +1'th bin will be combined with the zero'th bin...
    dwell[0] += dwell[n_bins_dir];
    dwell = dwell.subarray(0, n_bins_dir);
                
    cached_dir_dwell = get_smoothed_1d_periodic(dwell, render_options.smoothing_dir_bins);

    return true;
}




var make_cached_speed_bins_and_dwell = function(){
    let factor = 1/render_options.cps_per_speed_bin;
    cached_speed_bins = new Uint8ClampedArray(pos_speed.length);
    let n_valid_speed_bins = render_options.max_speed/render_options.cps_per_speed_bin;
    // we use an extra bin for everything invalid
    for(let i=0;i<pos_speed.length;i++){
        cached_speed_bins[i] = pos_speed[i] > render_options.max_speed ? 
                                n_valid_speed_bins : pos_speed[i] * factor;
    }
    cached_speed_dwell = hist_1(cached_speed_bins, n_valid_speed_bins+1);
    cached_speed_dwell = cached_speed_dwell.subarray(0, n_valid_speed_bins);
}


var make_cached_speed_spike_bins = function(){
    cached_spike_speed_bins = pick(cached_speed_bins, cached_spike_pos_ind); 
    return true;
}



var get_group_xy_rm = function(group_inds){
    var group_xy_bins = pick(cached_spike_xy_bins, group_inds); //cached_spike_xy_bins was stored as 2byte blocks, which is what we want here
    var spike = hist_2(new Uint8Array(group_xy_bins.buffer), n_bins_xy_1, n_bins_xy_0); //now we treat it as 1 byte blocks
    // TODO: see note about zero-bin in make_cached_xy_bins_and_dwell

    var spike = get_smoothed(spike, n_bins_xy_1, n_bins_xy_0, render_options.smoothing_spa_bins);
    var ratemap = divide_float(spike, cached_xy_dwell);
    use_mask(ratemap, cached_xy_no_dwell);

    var max_map = max(ratemap);
    
    var im = to_image_data(ratemap, render_options.max_rate_spa <= 0 ? max_map : render_options.max_rate_spa/pos_timebase);

    return {
        im: im,
        max: max_map * pos_timebase
    }

}

var to_image_data = function(map, max_map){
    // we use palette which is a Uint32Array, though really the underlying data is 4 bytes of RGBA

    var im = new Uint32Array(map.length);

     //for binning, we want values on interval [1 P], so use eps (lazy solution):
    var eps = 0.0000001;
    if(max_map == 0){
        for(let i=0; i<map.length; i++)
            im[i] = cached_xy_no_dwell[i]? palette[0] : palette[1];
    }else{
        var factor = (palette.length-1)/(max_map*(1+eps));
        for(let i=0;i<map.length;i++)
            im[i] = cached_xy_no_dwell[i]? palette[0] : palette[Math.min(1+(0 | (map[i]*factor)), palette.length-1)];
    }
    return im;
}

var get_group_dir_rm = function(group_inds){
    var n_bins_dir = cached_dir_dwell.length;
    var group_dir_bins = pick(cached_spike_dir_bins,group_inds); 

    var spike = hist_1(group_dir_bins, n_bins_dir+1);
    spike[0] += spike[n_bins_dir];
    spike = spike.subarray(0, n_bins_dir);

    var spike = get_smoothed_1d_periodic(spike, render_options.smoothing_dir_bins); 
    var ratemap = divide_float(spike, cached_dir_dwell);
    
    var max_map = max(ratemap);
    var im = plot_dir(ratemap, dir_plot_size, max_map);

    return {
        im: im,
        max: max_map * pos_timebase
    }

}

var get_group_speed_rm = function(group_inds){
    var group_speed_bins = pick(cached_spike_speed_bins, group_inds); 
    var spike = hist_1(group_speed_bins, cached_speed_dwell.length + 1);
    spike = spike.subarray(0, spike.length-1);

    var ratemap = divide_float(spike, cached_speed_dwell);
    return plot_histogram(speed_plot_size[0], speed_plot_size[1], ratemap);
}       


cached_speed_dwell

var plot_dir = function(vals, s, max){
    // produces a square plot
    var im = new Uint32Array(s*s);

    // draw axes
    draw_lines([0, s/2, s, s/2], s, s, 1, im, 0x99999999);
    draw_lines([s/2, 0, s/2, s], s, s, 1, im, 0x99999999);

    // go from linear to polar
    var n = vals.length;
    var xy = new Int8Array(n*2+2)
    for(let ii=0; ii<n; ii++){
        let theta = 2*pi/n*ii;
        xy[ii*2+0] = s/2 + Math.cos(theta) * vals[ii]/max*s/2;
        xy[ii*2+1] = s/2 - Math.sin(theta) * vals[ii]/max*s/2;
    }
    // join up the start and end
    xy[2*n+0] = xy[0];
    xy[2*n+1] = xy[1];

    draw_lines(xy, s, s, 1, im);
    return im;
}

var plot_histogram = function(w, h, vals){
    var color_a = 0xff000000;
    var color_b = 0x88000000;
    var color_ax = 0xff0000ff;
    var im = new Uint32Array(w*h);

    var f = w/max(vals);
    for(let i=0, y=0;i<vals.length && y<h;i++,y++){
        let h = f*vals[i];
        for (let k=0;k<3;k++){
            for(let x=0;x<h;x++){
                im[y*w+w-1-x] = color_a;
            }
            im[y*w+w-1] = color_ax;
            y++;
        }
        for(let x=0;x<h;x++){
            im[y*w+w-1-x] = color_b;
        }
        im[y*w+w-1] = color_ax;
    }
    return im;
}


var can_process_plot_path = function(){
    return cached_path && 
           (!pending_path_plot.a || (cached_spike_xy_raw && pkey_to_array.has(pending_path_plot.a))) &&
           (!pending_path_plot.b || pkey_to_array.has(pending_path_plot.b));
}

var process_plot_path = function(){
    let im = new Uint32Array(cached_path);

    if(pending_path_plot.a){
      //cached_spike_xy_raw is 16bit values stored as 4byte blocks, which is what we want to pick here
      let group_xy = pick(cached_spike_xy_raw, pkey_to_array.get(pending_path_plot.a)); 
            
      draw_points(new Uint16Array(group_xy.buffer), 256, 256, 256/Math.max(xy_max[0], xy_max[1]),
                   im, pending_path_plot.color_a, 1);
    }

    if(pending_path_plot.b){
      //cached_spike_xy_raw is 16bit values stored as 4byte blocks, which is what we want to pick here
      let group_xy = pick(cached_spike_xy_raw, pkey_to_array.get(pending_path_plot.b)); 
            
      draw_points(new Uint16Array(group_xy.buffer), 256, 256, 256/Math.max(xy_max[0], xy_max[1]),
                  im, pending_path_plot.color_b, 1);
    }
   
    exec_main_b('plot_path', {
        path: 'path',
        dims: [256, 256],
        generation: pkey_generation,
        a: pending_path_plot.a,
        b: pending_path_plot.b,
        color_a: pending_path_plot.color_a,
        color_b: pending_path_plot.color_b
    }, {
        path: im
    });
   pending_path_plot = null;
}


var plot_path = function(pkey_a, pkey_b, color_a, color_b){
    pending_path_plot = {
        a: pkey_a,
        b: pkey_b,
        color_a: color_a,
        color_b: color_b
    };
    touch_timer();
}

// TODO: come with a better method than copy-pasting utility functions ....

var hist_1 = function(inds, n_bins){
    var result = new Uint32Array(n_bins); 
    var n = inds.length;
    
    for(let i=0;i<n;i++){
        result[inds[i]]++;
    }
    return result;
}

var hist_2 = function(inds_xy, n_1, n_0){
    var result = new Uint32Array(n_0*n_1); 
    var n = inds_xy.length/2;

    for(let i=0; i<n; i++){
        result[inds_xy[i*2+1]*n_1 + inds_xy[i*2+0]]++;
    }
    return result;
}

var is_zero = function(vector){
    var result = new Uint8ClampedArray(vector.length);
    for(let i=0;i<vector.length;i++)
        result[i] = (vector[i]===0);
    return result;
}

var get_smoothed_1d_periodic = function(x, w){
    // kernel is box-car of size 2w+1
    var n = x.length;
    var result = new Uint32Array(n);
    for(let i=0; i<n; i++){
        for(let k=-w;k<=w; k++){
            result[i] += x[(i+k) % n];
        }
    }
    return result;
}

var get_smoothed = function(matrix, n_1, n_0, w){
    var result = new Uint32Array(matrix.length);
    // kernel is box-car of size 2w+1

    for(let ky=-w; ky<=w; ky++)for(var kx=-w; kx<=w; kx++){//for each offset within the kernel square
        let start_0 = ky<0? 0 : ky;
        let start_1 = kx<0? 0 : kx;
        let end_0 = ky>0? n_0 : n_0+ky;
        let end_1 = kx>0? n_1 : n_1+kx;

        for(let y=start_0; y<end_0; y++)for(let x=start_1; x<end_1; x++){
            result[y*n_1 +x] += matrix[(y-ky)*n_1 +(x-kx)];
        }
    }   
    return result; 
}

var max = function(x){
    var m = x[0];
    for(let i = 1;i< x.length; i++){
        (m < x[i]) && (m = x[i]);
    }
    return m; 
}

var pick = function(from, indices){
    // Take elements specified by indicies from the 1d array "from".
    var result =  new from.constructor(indices.length); //make an array of the same type as the from array
    for(let i=0;i<indices.length;i++){
        result[i] = from[indices[i]];
    }
    return result;
}

var is_equal_simple = function(a, b){
    // very simple....
    if((a && !b) || (!a && b)){
        return false;
    }
    for(let aa in a) if(a.hasOwnProperty(aa)){
        if(b[aa] !== a[aa]){
            return false;
        }
    }
    for(let bb in b) if(b.hasOwnProperty(bb)){
        if(b[bb] !== a[bb]){
            return false;
        }
    }
    return true;
}

var draw_points = function(xy, w, h, scale, im, color, k){
    for(let ii=0; ii<xy.length; ii+=2){
        let start_0 = Math.max(0, xy[ii+0]*scale-k) | 0;
        let end_0 = Math.min(w, xy[ii+0]*scale+k+1) | 0;
        let start_1 = Math.max(0, xy[ii+1]*scale-k) | 0;
        let end_1 = Math.min(h, xy[ii+1]*scale+k+1) | 0;
        for(let p0=start_0; p0<end_0; p0++){
            for(let p1=start_1; p1<end_1; p1++){
                im[p1*w + p0] = color;
            }
        }
    }
}

var draw_lines = function(xy, w, h, scale, im, color){
    // Chrome currently de-optizes for "compound let assignment"
    // which means using += or -= on a variable declared with "let"
    // so we have to manually write x = x + something
    
    color = color || 0xff000000; //black
    im = im || new Uint32Array(w*h);

    let x0 = (xy[0] * scale) | 0;
    let y0 = (xy[1] * scale) | 0;
    for(let ii=2; ii<xy.length; ii=ii+2){
        let x1 = (xy[ii+0] * scale) | 0;
        let y1 = (xy[ii+1] * scale) | 0;

        // Bresenham algorithm adapted from http://stackoverflow.com/a/4672319/2399799
        let sx = ((x0 < x1) <<1) -1; // (x0 < x1) ? 1 : -1
        let sy = ((y0 < y1) <<1) -1; // (y0 < y1) ? 1 : -1
        let dx = sx*(x1-x0); // abs(x0-x1)
        let dy = sy*(y1-y0); // abs(y0-y1)
        let err = dx-dy;
        while(true){
            im[y0*w + x0] = color;

            if ((x0===x1) && (y0===y1)) break;
            let e2 = err << 1;
            if (e2 >-dy){ 
                err = err - dy;
                x0  = x0 + sx; 
            }
            if (e2 < dx){
                err = err + dx;
                y0  = y0 + sy;
            }
        }

        x0 = x1;
        y0 = y1;
    }
    return im;
}

var divide_float = function(numerator, denominator){
    let out = new Float32Array(numerator.length);
    for(let ii=0; ii<out.length; ii++){
        out[ii] = numerator[ii] / denominator[ii];
    }
    return out;
}

var use_mask = function(vector, mask, val){
    // sets vector elemnts to val where mask is true, if val is omitted it defaults to zero
    val = typeof(val) === "number" ? val : 0;
    for(let ii=0; ii<mask.length; ii++) if(mask[ii]){
        vector[ii] = val;  
    }
}

</script>

<template></template>


<script>
    "use strict";

    Polymer({
        is:'rm-plots',
        behaviors: [
            Polymer.ShortcutNotifyerBehavior
        ], properties: {
            pos_path: {
                type: Object, 
                value: null,
                notify: true,
                readOnly: true
            },
            pos_speed_hist: {
                type: Object, 
                value: null,
                notify: true,
                readOnly: true
            },
            pos_xy: {
                type: Object, // array akey "data" and timebase Number in same units as max_delta_t
                value: function(){ return {};},
                notify: true
            },
            pos_dir: {
                type: Object, // array akey "data" and timebase Number in same units as max_delta_t
                value: function(){ return {};},
                notify: true
            },
            pos_speed: {
                type: Object, // array akey "data" and timebase Number in same units as max_delta_t
                value: function(){ return {};},
                notify: true
            },
            spike_times: {
                type: Object, // array akey "data" and timebase Number in same units as max_delta_t
                value: function(){ return {};},
                notify: true
            },
            cm_per_spa_bin: {
                type: Number,
                value: 2,
                notify: true
            },
            smoothing_spa_bins: {
                type: Number,
                value: 2,
                notify: true
            },
            max_rate_spa: {
                type: Number,
                value: -1,
                notify: true
            },
            deg_per_dir_bin: {
                type: Number,
                value: 6,
                notify: true
            },
            smoothing_dir_bins: {
                type: Number,
                value: 2,
                notify: true
            },
            speed_rm_max: {
                type: Number,
                value: 45,
                notify: true
            },
            show: {
                type: String,
                value: 'yyy',
                notify: true
            },
            groups: {
                type: Array,
                value: function(){return [];},
                notify: true,
                observer: '_groups_set'
            },
            want_spike_times: {
                type: Array,
                notify: true,
                observer: '_want_spike_times_set'
            },
            active_group_a: {
                type: Object,
                notify: true
            },
            active_group_b: {
                type: Object,
                notify: true
            }
        }, observers: [
            '_groups_spliced(groups.splices)',
            '_options_modified(cm_per_spa_bin, smoothing_spa_bins, max_rate_spa, deg_per_dir_bin, smoothing_dir_bins, speed_rm_max)',
            '_show_changed(show)',
            '_pos_xy_modified(pos_xy)',
            '_pos_dir_modified(pos_dir)',
            '_pos_speed_modified(pos_speed)',
            '_times_modified(spike_times)',
            '_update_pos_path(active_group_a, active_group_b)'
        ], created: function(){
            // copy-paste defaults from worker code above (could implement
            // something  more complicated, but hey this works and is easy).
            this._options = {
                cm_per_spa_bin: undefined,
                smoothing_spa_bins: undefined,
                max_rate_spa: undefined,
                deg_per_dir_bin: undefined,
                smoothing_dir_bins: undefined,
                max_speed: undefined, // partially supported as user-configurable
                cps_per_speed_bin: 4 // currently not exposed as user-configurable
            };
            var worker_builder = Polymer.DomModule.import('rm-plots','#worker');
            this._worker = worker_builder.create_for(this);
            this._pkey_generation = 0;
            this._times_is_on_worker = false;
            this._pos_xy_is_on_worker = false;
            this._pos_dir_is_on_worker = false;
            this._pos_speed_is_on_worker = false;
        }, _want_spike_times_set: function(){
            this._show_changed(this.show);
        }, _update_okeys: function(okeys_to_remove, okeys_to_add, generation_remove, generation_add){
            var am = Utils.typed_array_manager;
            var added_arrays = {};
            var pkeys_to_add = []; 
            if (this.show.indexOf('y') > -1){
                // get clones of new arrays to send to worker
                for(let okey of okeys_to_add){
                    if(!okey) continue;
                    pkeys_to_add.push(okey._pkey);
                    added_arrays[okey._pkey] = am.get_array_clone(okey.akey);
                    okey._rm_is_on_worker = true;                    
                }
            }

            // free canvases
            var pkeys_to_remove = [];
            for(let okey of okeys_to_remove){
                if(!okey) continue;
                pkeys_to_remove.push(okey._pkey);
                okey.rm.spa = null;
                okey.rm.dir = null;
                okey.rm.speed = null;
                okey._rm_spa_other = null;
                okey._rm_dir_other = null;
                okey._rm_speed_other = null;
                okey._rm_other_options = {};
                okey._rm_is_on_worker = false;
            }

            // inform worker of the new/deleted arrays
            this._worker.exec_b('update_pkeys', {
                add: pkeys_to_add,
                remove: pkeys_to_remove,
                generation_remove: generation_remove,
                generation_add: generation_add
            }, added_arrays);

        }, _use_other_if_possible: function(okeys){
            // The okey._rm_x_other stores the last canvas from the worker,
            // with okey._rm_other_options containing the render settings used.
            // Here we check whether the rendered options match what we currently
            // want, and if so we set the visible okey.rm_x property from the
            // okey._rm_x_other value. We also deal with hiding canvases on show='n'.
            for(let okey of okeys) if(okey){
                let op; // 0 : no-op, +1 : use _other values, -1: set to null
                let same; // are the okey.rm_x and okey._rm_x_other the same?
                let rm = okey.rm = Object.assign({}, okey.rm); // assign a copy so we can notify once for multiple changes (notify at end of iteration)

                // spa
                same = rm.spa === okey._rm_spa_other;
                op = this.show[0] === 'n' ? 
                         ( rm.spa ? -1 : 0 )
                       : ( !same && this._options_match(okey._rm_other_options, this._options, "spa") ? 1  : 0 );
                if(op){
                    okey.rm.spa = op === 1 ? okey._rm_spa_other : null;
                    rm.spa_max = op === 1 ? okey._rm_spa_max_other : null;
                }

                // dir
                same = rm.dir === okey._rm_dir_other;
                op = this.show[1] === 'n' ? 
                         ( rm.dir ? -1 : 0 )
                       : ( !same && this._options_match(okey._rm_other_options, this._options, "dir") ? 1  : 0 );
                if(op){
                    rm.dir = op === 1 ? okey._rm_dir_other : null;
                    rm.dir_max = op === 1 ? okey._rm_dir_max_other : null;
                }

                // speed
                same = rm.speed === okey._rm_speed_other;
                op = this.show[2] === 'n' ? 
                         ( rm.speed ? -1 : 0 )
                       : ( !same && this._options_match(okey._rm_other_options, this._options, "speed") ? 1  : 0 );
                if(op){
                    rm.speed = op === 1 ? okey._rm_speed_other : null;
                }

                this.shortcutNotify('rm', rm, okey); // actual path: 'groups.' + okey._pkey + '.rm'
            }

        }, _options_modified: function(){
            this._options.cm_per_spa_bin = this.cm_per_spa_bin;
            this._options.smoothing_spa_bins = this.smoothing_spa_bins;
            this._options.max_rate_spa = this.max_rate_spa;
            this._options.deg_per_dir_bin = this.deg_per_dir_bin;
            this._options.smoothing_dir_bins = this.smoothing_dir_bins;
            this._options.max_speed = this.speed_rm_max;
            this._use_other_if_possible(this.groups || []);
            this._worker.exec('set_options', this._options);
        }, _groups_set: function(new_val, old_val){
            this._groups_collection = Array.isArray(new_val) && Polymer.Collection.get(new_val);
            this._update_okeys(old_val || [], new_val || [], this._pkey_generation, ++this._pkey_generation); // added keys are for a new generation
        }, _groups_spliced: function(splices){
            let parsed = Utils.parse_splices(splices);
            this._update_okeys(parsed.removed, parsed.added, this._pkey_generation, this._pkey_generation);
        }, _show_changed: function(show){
            if(!this.want_spike_times){
                return;
            }
            if (!this.show.match(/^[yn]{3}$/)){
                console.log("bad rm show value");
                return;
            }

            this._use_other_if_possible(this.groups || []);

            if(show === "nnn"){
                let idx = this.want_spike_times.indexOf("rm-plots");
                (idx > -1) && this.splice('want_spike_times', idx, 1);

            } else {  
                let idx = this.want_spike_times.indexOf("rm-plots");
                (idx === -1) && this.push('want_spike_times', "rm-plots");

                // if show was completely off we avoided sending times to worker...
                if(!this._times_is_on_worker){
                    this._times_modified();
                }

                // and we avoided sending group inds to worker...
                let added = [];
                for(let okey of (this.groups || [])) if(okey && !okey._rm_is_on_worker){
                    added.push(okey);
                }
                this._update_okeys([], added, this._pkey_generation, this._pkey_generation);

            }
         
            // and we avoided sending the individual pos data types to the worker...
            if(show[0] === 'y' && !this._pos_xy_is_on_worker){
                this._pos_xy_modified();
            }
            if(show[1] === 'y' && !this._pos_dir_is_on_worker){
                this._pos_dir_modified();
            }
            if(show[2] === 'y' && !this._pos_speed_is_on_worker){
                this._pos_speed_modified();
            }

            this._worker.exec('set_show', this.show); // worker needs to know even if it's all 'nnn', because then it won't bother doing anything.
        }, _pos_xy_modified: function(){
            this._blank_pos_path = null;
            this._setPos_path(null); // TODO: might want to dealy this somehwo to avoid flash of null when changing settings
            if(this.show && this.show[0] === 'y'){
                if(this.pos_xy){
                    let arr = Utils.typed_array_manager.get_array_clone(this.pos_xy.xy);
                    this._worker.exec_b('set_pos_xy', this.pos_xy.timebase, 
                        this.pos_xy.units_per_cm, this.pos_xy.max_x, this.pos_xy.max_y, {data: arr});
                } else {
                    if(!this._worker) return;
                    this._worker.exec('set_pos_xy', {});
                }
                this._pos_xy_is_on_worker = true;
            } else {
                if(!this.pos_xy && this._pos_xy_is_on_worker){
                    this._worker.exec('set_pos_xy', {});
                }
                this._pos_xy_is_on_worker = false;
            }
        }, _pos_dir_modified: function(){
            if(this.show && this.show[1] === 'y'){
                if(this.pos_dir){
                    let arr = Utils.typed_array_manager.get_array_clone(this.pos_dir.dir);
                    this._worker.exec_b('set_pos_dir', this.pos_dir.timebase, {data: arr});
                } else {
                    if(!this._worker) return;
                    this._worker.exec('set_pos_dir', {});
                }
                this._pos_dir_is_on_worker = true;
            } else {
                if(!this.pos_dir && this._pos_dir_is_on_worker){
                    this._worker.exec('set_pos_dir', {});
                }
                this._pos_dir_is_on_worker = false;
            }
        }, _pos_speed_modified: function(){
            this._setPos_speed_hist(null); 
            if(this.show && this.show[2] === 'y'){
                if(this.pos_speed){
                    let arr = Utils.typed_array_manager.get_array_clone(this.pos_speed.speed);
                    this._worker.exec_b('set_pos_speed', this.pos_speed.timebase, {data: arr});
                } else {
                    if(!this._worker) return;
                    this._worker.exec('set_pos_speed', {});
                }
                this._pos_speed_is_on_worker = true;
            } else {
                if(!this.pos_speed && this._pos_speed_is_on_worker){
                    this._worker.exec('set_pos_speed', {});
                }
                this._pos_speed_is_on_worker = false;
            }
        }, _times_modified: function(){
            if(this.show !== 'nnn'){
                if(this.spike_times){
                    let arr = Utils.typed_array_manager.get_array_clone(this.spike_times.times);
                    this._worker.exec_b('set_spike_times', this.spike_times.timebase, {data: arr});
                } else {
                    if(!this._worker) return;
                    this._worker.exec('set_spike_times', {});
                }
                this._times_is_on_worker = true;
            } else {
                if(!this.spike_times && this._times_is_on_worker){
                    this._worker.exec('set_spike_times', {});
                }
                this._times_is_on_worker = false;
            }
        }, _options_match: function(a, b, kind){
            if((!a && b) || (a && !b)){
                return false;
            }
            if(kind === "spa"){
                return a.smoothing_spa_bins === b.smoothing_spa_bins
                    && a.cm_per_spa_bin == b.cm_per_spa_bin
                    && a.max_rate_spa == b.max_rate_spa;
            } else if(kind === "dir"){
                return a.smoothing_dir_bins === b.smoothing_dir_bins
                    && a.deg_per_dir_bin == b.deg_per_dir_bin;
            } else if(kind === "speed"){
                return a.max_speed === b.max_speed
                    && a.cps_per_speed_bin === b.cps_per_speed_bin;
            }
        }, _copy_options: function(dest, src, kind){
            if(kind === "spa"){
                dest.smoothing_spa_bins = src.smoothing_spa_bins;
                dest.cm_per_spa_bin = src.cm_per_spa_bin;
                dest.max_rate_spa = src.max_rate_spa;
            } else if (kind === "dir"){
                dest.smoothing_dir_bins = src.smoothing_dir_bins;
                dest.deg_per_dir_bin = src.deg_per_dir_bin;
            } else if(kind === "speed"){
                dest.max_speed = src.max_speed;
                dest.cps_per_speed_bin = src.cps_per_speed_bin;
            }
        }, plot_things: function(msgs, arrays) {
            for (let msg of msgs){
                if(msg.generation !== this._pkey_generation){
                    continue; // pft! get with the times, dude.
                }
                let okey = this._groups_collection.getItem(msg.pkey);
                if(!okey){
                    continue;
                }
                if(msg.spa_rm){
                    okey._rm_spa_other = {buffer: arrays[msg.spa_rm].buffer, dims: msg.spa_rm_dims};
                    okey._rm_spa_max_other = msg.spa_max.toFixed(1);
                    this._copy_options(okey._rm_other_options, msg.render_options, "spa");
                }
                if(msg.dir_rm){
                    okey._rm_dir_other = {buffer: arrays[msg.dir_rm].buffer, dims: msg.dir_rm_dims};
                    okey._rm_dir_max_other = msg.dir_max.toFixed(1);
                    this._copy_options(okey._rm_other_options, msg.render_options, "dir");
                }
                if(msg.speed_rm){
                    okey._rm_speed_other = {buffer: arrays[msg.speed_rm].buffer, dims: msg.speed_rm_dims};
                    this._copy_options(okey._rm_other_options, msg.render_options, "speed");
                }
                this._use_other_if_possible([okey]);
            }

        }, plot_path: function(msg, arrays){
            if(msg.a && this._pkey_generation == msg.generation &&
                (this.active_group_a && this.active_group_a._pkey == msg.a) && 
                ((!this.active_group_b && !msg.b) || (this.active_group_b && this.active_group_b._pkey == msg.b))
                && this.show && this.show[0]==='y'){
                // plot is of current a (and b), and generation is current and we want spa plots
                this._setPos_path({buffer: arrays.path.buffer, dims: msg.dims})    
            } else if(!msg.a){
                // plot has null a and b, so store it as the blank path and set it now
                this._blank_pos_path = {buffer: arrays.path.buffer, dims: msg.dims};
                this._setPos_path(this._blank_pos_path);
            }
            
        }, plot_speed_hist: function(msg, arrays){
                this._setPos_speed_hist({buffer: arrays.hist.buffer, dims: msg.dims});

        }, _update_pos_path: function(){
            if(this.active_group_a && this.show && this.show[0]==='y'){
                // note we are slightly lazy in so far as we don't watch for changes of group_num
                // while current active groups are unchanged..this is difficult/impossible to
                // actually cause you use the console or something.
                this._worker.exec('plot_path', 
                                   this.active_group_a._pkey,
                                   this.active_group_b  && this.active_group_b._pkey,
                                   Palettes.flag32[this.active_group_a.group_num],
                                   this.active_group_b && Palettes.flag32[this.active_group_b.group_num]);
            } else {
                this._setPos_path(this._blank_pos_path);
            }
        }
    });
</script>

  
</dom-module><dom-module id="tac-plots" assetpath="/">

<script is="worker-builder" id="worker" title="tac-plots" type="javascript/worker">
"use strict";

var render_options = {
    max_delta_t: 500, // miliseconds
    n_bins: 100,
    height: 50 //px, width matches n_bins exactly
};

var spike_times;
var timebase;
var pkey_to_array = new Map(); // Note that in the worker, key's are used only for arrays of spike-indices.
var pkey_to_rendered_options = new Map(); 
var pkeys_pending_render = [];
var timer;
var pkey_generation = 0;
var show;

var set_show = function(v){
    show = v;
    // note that we don't meddle with the pkeys_pending_render list here
    // instead we use the timer to decide whether or not to bother doing any rendering
    touch_timer();
}

var set_options = function(opts){
    for(var k in render_options){
        render_options[k] = opts[k] === undefined ? render_options[k] : opts[k];
    }
    pkeys_pending_render = [];    
    if(spike_times){
        for(let pkey of pkey_to_array.keys()){
            pkeys_pending_render.push(pkey);
        }
    }
    touch_timer();
}

var set_spike_times = function(timebase_, arrays){
    timebase = timebase_;
    spike_times = arrays && arrays.data; 
    pkeys_pending_render = [];    
    if(spike_times){
        for(let pkey of pkey_to_array.keys()){
            pkeys_pending_render.push(pkey);
        }
    }
    touch_timer();
}

var update_pkeys = function(changes, arrays){

    if(changes.generation_remove !== pkey_generation){
        changes.remove = [];
        pkey_to_array.clear();
        pkey_to_rendered_options.clear();
        pkeys_pending_render = [];
        console.log("tac-plots worker: key generation mismatch");
    }

    // note we don't both to remove keys from the pending list
    // unless we change key generation, in which case we drop 
    // everything that's pending. This is ensures that when we
    // attempt a render we can be sure that if we do find the
    // array for the given key we know it's for the relevant 
    // generation and that it's still wanted.

    var remove_pkeys = changes.remove || [];
    for(let pkey of remove_pkeys){
        pkey_to_array.delete(pkey);
        pkey_to_rendered_options.delete(pkey);
    }

    if(changes.generation_add !== changes.generation_remove){
        pkeys_pending_render = [];
        pkey_generation = changes.generation_add;
    }

    var add_pkeys = changes.add || [];
    for(let pkey of add_pkeys){
        pkey_to_array.set(pkey, arrays[pkey]);
        pkeys_pending_render.push(pkey);
    }

    touch_timer();        
}

var touch_timer = function(){
    // turns timer on if there's work to be done, otherwise stops it (if it was running)
    // note it's not actually a timer, because the interval is zero!
    // the point of using this is that it enables messages from main thread to interupt
    // between ticks, we can thus cancel work as an when needed.
    if(spike_times && pkeys_pending_render.length && show === 'y'){
        timer = timer || setImmediate(timer_tick);
    } else{
        clearImmediate(timer);
        timer = 0;
    }
}


var timer_tick = function(){
    timer = 0;

    let batch_limit = 5; // a bit arbitrary
    let arrays={};
    let msgs = [];

    // find batch_limit things to render...
    while(pkeys_pending_render.length > 0 && msgs.length < batch_limit){
        let pkey = pkeys_pending_render.shift();
        if(pkey && pkey_to_array.get(pkey) && !is_equal_simple(pkey_to_rendered_options.get(pkey), render_options)){
            msgs.push(get_group_hist(pkey, arrays));
        }
    }
    
    if(msgs.length){        
        exec_main_b('plot_hist', msgs, arrays);
    }

    touch_timer();
}

var get_group_hist = function(pkey, arrays){
    // note desired_max_delta_t and spike_times should both be in the same units
    let group_times = pick(spike_times, pkey_to_array.get(pkey));

    // build pairwise-diff histogram
    let hist = new Uint32Array(render_options.n_bins+1);
    get_group_hist_sub(hist, group_times, render_options.max_delta_t/1000*timebase, 
                        render_options.max_delta_t/1000*timebase/render_options.n_bins);
    
    hist = plot_histogram(hist, render_options.height);
    let opts = Object.assign({}, render_options);
    pkey_to_rendered_options.set(pkey, opts);

    arrays[pkey + ' hist'] = hist;
    return {
        pkey: pkey,
        generation: pkey_generation,
        hist: pkey + ' hist',
        dims: [opts.n_bins, opts.height],
        render_options: opts
    }
}

var get_group_hist_sub = function(ret, group_times, D, b){
    // For every pair of spikes separated in time by no more than time D, bin
    // up the time separation, with bin size b, and record it in hist, ret.
    for(var later_idx=1, earlier_idx=0; later_idx<group_times.length; later_idx++){
        let later_time = group_times[later_idx];
        while (group_times[earlier_idx] < later_time - D){
            earlier_idx++;
        }
        for(let i=earlier_idx; i<later_idx; i++){
            ret[0 | ((later_time - group_times[i])/b)]++;
        }
    }
}

// TODO: come with a better method than copy-pasting utility functions ....

var max = function(vals, w){
    let max = 0;
    for(let ii=0; ii<w; ii++){
        (vals[ii] > max) && (max = vals[ii]);
    }
    return max;
}
var plot_histogram = function(vals, h){
    let w = vals.length-1;
    let factor = h/max(vals, w);
    let color_a = 0xff0000ff;
    let im = new Uint32Array(w*h);
    for(let x=0, y=vals[0]; x<w; x++){
        let target_y = 0 | (vals[x]*factor);
        for(; y<target_y; y++){
            im[w*(h-y) + x] = color_a;
        }
        for(; y>target_y; y--){
            im[w*(h-y) + x] = color_a;
        }
        im[w*(h-y) + x] = color_a;
    }
    return im;
}

var pick = function(from, indices){
    // Take elements specified by indicies from the 1d array "from".
    var result =  new from.constructor(indices.length); //make an array of the same type as the from array
    for(let i=0;i<indices.length;i++)
        result[i] = from[indices[i]];
    return result;
}


var is_equal_simple = function(a, b){
    // very simple....
    if((a && !b) || (!a && b)){
        return false;
    }
    for(var aa in a){
        if(b[aa] !== a[aa]){
            return false;
        }
    }
    for(let bb in b){
        if(b[bb] !== a[bb]){
            return false;
        }
    }
    return true;
}
</script>

<template></template>


<script>
    "use strict";


    Polymer({
        is:'tac-plots',
        behaviors: [
            Polymer.ShortcutNotifyerBehavior
        ], properties: {
               max_delta_t: {
                type: Number, // in miliseconds
                value: 2,
                notify: true
            }, spike_times: {
                type: Object, // array akey "data" and timebase Number in Hz (ie per second not per milisecond)
                value: function(){ return {};},
                notify: true
            }, show: {
                type: String, // "y" or "n" (to match other modules which have multiple toggle-able things)
                value: "y",
                notify: true
            }, groups: {
                type: Array,
                value: function(){return [];},
                notify: true,
                observer: '_groups_set'
            }, want_spike_times: {
                type: Array,
                notify: true,
                observer: 'want_spike_times_set'
            }
        }, observers: [
            '_groups_spliced(groups.splices)', 
            '_options_modified(max_delta_t)',
            '_times_modified(spike_times)',
            '_show_changed(show)'
        ], created: function(){
            // copy-paste defaults from worker code above (could implement
            // something  more complicated, but hey this works and is easy).
            this._options = {
                max_delta_t: 500, // miliseconds
                n_bins: 100,
                height: 50 //px, width matches n_bins exactly
            };
            var worker_builder = Polymer.DomModule.import('tac-plots','#worker');
            this._worker = worker_builder.create_for(this);
            this._pkey_generation = 0;
            this._times_is_on_worker = false;
        }, want_spike_times_set: function(){
            this._show_changed(this.show);
        }, _update_okeys: function(okeys_to_remove, okeys_to_add, generation_remove, generation_add){
            var am = Utils.typed_array_manager;
            
            var added_arrays = {};
            var pkeys_to_add = []; 
            if (this.show === 'y'){
                // get clones of new arrays to send to worker
                for(let okey of okeys_to_add){
                    if(!okey) continue;
                    pkeys_to_add.push(okey._pkey);
                    added_arrays[okey._pkey] = am.get_array_clone(okey.akey);
                    okey._tac_is_on_worker = true;                    
                }
            }

            // free canvases, it's our responsiblity to do this, whereas 
            // freeing the inds arrays was the responsibility of cut-obj.
            var pkeys_to_remove = [];
            for(let okey of okeys_to_remove){
                if(!okey) continue;
                pkeys_to_remove.push(okey._pkey);
                okey.tac = null;
                okey._tac_other = null;
                okey._tac_other_options = {};
                okey._tac_is_on_worker = false;
            }

            // inform worker of the new/deleted arrays
            this._worker.exec_b('update_pkeys', {
                add: pkeys_to_add,
                remove: pkeys_to_remove,
                generation_remove: generation_remove,
                generation_add: generation_add
            }, added_arrays);

        }, _groups_set: function(new_val, old_val){
            this._groups_collection = Array.isArray(new_val) && Polymer.Collection.get(new_val);
            this._update_okeys(old_val || [], new_val || [], this._pkey_generation, ++this._pkey_generation); // added keys are for a new generation
        }, _groups_spliced: function(splices){
            let parsed = Utils.parse_splices(splices);
            this._update_okeys(parsed.removed, parsed.added, this._pkey_generation, this._pkey_generation);
        }, _options_modified: function(){
            this._options.max_delta_t = this.max_delta_t;
            this._use_other_if_possible(this.groups || []);
            this._worker.exec('set_options', this._options);
        }, _times_modified: function(){
            if(this.show === 'y'){
                if(this.spike_times){
                    var arr = Utils.typed_array_manager.get_array_clone(this.spike_times.times);
                    this._worker.exec_b('set_spike_times', this.spike_times.timebase, {data: arr});
                } else {
                    if(!this._worker) return;
                    this._worker.exec('set_spike_times', {});
                }
                this._times_is_on_worker = true;
            } else {
                if(!this.spike_times && this._times_is_on_worker){
                    this._worker.exec('set_spike_times', {});
                } 
                this._times_is_on_worker = false;
            }
        },  _use_other_if_possible: function(okeys){
            // The okey._tac_other stores the last canvas from the worker,
            // with okey._tac_other_options containing the render settings used.
            // Here we check whether the rendered options match what we currently
            // want, and if so we set the visible okey.tac property from the
            // okey._tac_other value. We also deal with hiding canvases on show='n'.
            for(let okey of okeys) if(okey){
                // are the okey.rm_x and okey._rm_x_other the same?
                let same = okey.tac === okey._tac_other;

                //0 : no-op, +1 : use _other values, -1: set to null
                let op = this.show === 'n' ? 
                           ( okey.tac ? -1 : 0 )
                         : ( !same && Utils.is_equal_simple(okey._tac_other_options, this._options) ? 1  : 0 );

                if(op){
                    okey.tac = op === 1 ? okey._tac_other : null;
                    this.shortcutNotify('tac', okey.tac, okey); // actual path: 'groups.' + okey._pkey + '.tac'
                }
            }

        }, _show_changed: function(show){
            if(!this.want_spike_times){
                return;
            }
            this._use_other_if_possible(this.groups || []);

            if (show === 'n'){
                let idx = this.want_spike_times.indexOf("tac-plots");
                (idx > -1) && this.splice('want_spike_times', idx, 1);

            } else if(show === 'y'){
                let idx = this.want_spike_times.indexOf("tac-plots");
                (idx === -1) && this.push('want_spike_times', "tac-plots");

                // while show was false we avoided sending times to worker...
                if(!this._times_is_on_worker){
                    this._times_modified();
                }

                // and we avoided sending group inds to worker...
                let added = [];
                for(let okey of (this.groups || []))if(okey && !okey._tac_is_on_worker){
                    added.push(okey);
                }
                this._update_okeys([], added, this._pkey_generation, this._pkey_generation);
            } else {
                console.log("invalid value for tac show");
                this.set('show', 'y');
                return;
            }

            this._worker.exec('set_show', this.show); // worker needs to know even if it's all 'n', because then it won't bother doing anything.
        }, plot_hist: function(msgs, arrays) {
            for(let msg of msgs){
                if(msg.generation !== this._pkey_generation)
                    continue; // pft! get with the times, dude.
                let okey = this._groups_collection.getItem(msg.pkey);
                if(!okey){
                    continue;
                }
                let cm = Utils.canvas_manager;
                okey._tac_other = {buffer: arrays[msg.hist].buffer, dims: msg.dims};
                okey._tac_other_options = msg.render_options;
                this._use_other_if_possible([okey]);
            }
        }

    });
</script>

  
</dom-module><script>

//Some suggested additions:
function validateNoneOfTheArgsAreUndefined(functionName, args) {
  for (var ii = 0; ii < args.length; ++ii) {
    if (args[ii] === undefined) {
      console.error("undefined passed to gl." + functionName + "(" +
                     WebGLDebugUtils.glFunctionArgsToString(functionName, args) + ")");
    }
  }
} 

function logGLCalls(functionName, args) {   
   console.log("gl." + functionName + "(" + 
      WebGLDebugUtils.glFunctionArgsToString(functionName, args) + ")");   
} 

function throwOnGLError(err, funcName, args) {
  throw WebGLDebugUtils.glEnumToString(err) + " was caused by call to: " + funcName;
};

function logAndValidate(functionName, args) {
   logGLCalls(functionName, args);
   validateNoneOfTheArgsAreUndefined (functionName, args);
}
/*
** Copyright (c) 2012 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/

// Various functions for helping debug WebGL apps.

WebGLDebugUtils = function() {

/**
 * Wrapped logging function.
 * @param {string} msg Message to log.
 */
var log = function(msg) {
  if (window.console && window.console.log) {
    window.console.log(msg);
  }
};

/**
 * Wrapped error logging function.
 * @param {string} msg Message to log.
 */
var error = function(msg) {
  if (window.console && window.console.error) {
    window.console.error(msg);
  } else {
    log(msg);
  }
};

/**
 * Which arguements are enums.
 * @type {!Object.<number, string>}
 */
var glValidEnumContexts = {

  // Generic setters and getters

  'enable': { 0:true },
  'disable': { 0:true },
  'getParameter': { 0:true },

  // Rendering

  'drawArrays': { 0:true },
  'drawElements': { 0:true, 2:true },

  // Shaders

  'createShader': { 0:true },
  'getShaderParameter': { 1:true },
  'getProgramParameter': { 1:true },

  // Vertex attributes

  'getVertexAttrib': { 1:true },
  'vertexAttribPointer': { 2:true },

  // Textures

  'bindTexture': { 0:true },
  'activeTexture': { 0:true },
  'getTexParameter': { 0:true, 1:true },
  'texParameterf': { 0:true, 1:true },
  'texParameteri': { 0:true, 1:true, 2:true },
  'texImage2D': { 0:true, 2:true, 6:true, 7:true },
  'texSubImage2D': { 0:true, 6:true, 7:true },
  'copyTexImage2D': { 0:true, 2:true },
  'copyTexSubImage2D': { 0:true },
  'generateMipmap': { 0:true },

  // Buffer objects

  'bindBuffer': { 0:true },
  'bufferData': { 0:true, 2:true },
  'bufferSubData': { 0:true },
  'getBufferParameter': { 0:true, 1:true },

  // Renderbuffers and framebuffers

  'pixelStorei': { 0:true, 1:true },
  'readPixels': { 4:true, 5:true },
  'bindRenderbuffer': { 0:true },
  'bindFramebuffer': { 0:true },
  'checkFramebufferStatus': { 0:true },
  'framebufferRenderbuffer': { 0:true, 1:true, 2:true },
  'framebufferTexture2D': { 0:true, 1:true, 2:true },
  'getFramebufferAttachmentParameter': { 0:true, 1:true, 2:true },
  'getRenderbufferParameter': { 0:true, 1:true },
  'renderbufferStorage': { 0:true, 1:true },

  // Frame buffer operations (clear, blend, depth test, stencil)

  'clear': { 0:true },
  'depthFunc': { 0:true },
  'blendFunc': { 0:true, 1:true },
  'blendFuncSeparate': { 0:true, 1:true, 2:true, 3:true },
  'blendEquation': { 0:true },
  'blendEquationSeparate': { 0:true, 1:true },
  'stencilFunc': { 0:true },
  'stencilFuncSeparate': { 0:true, 1:true },
  'stencilMaskSeparate': { 0:true },
  'stencilOp': { 0:true, 1:true, 2:true },
  'stencilOpSeparate': { 0:true, 1:true, 2:true, 3:true },

  // Culling

  'cullFace': { 0:true },
  'frontFace': { 0:true },
};

/**
 * Map of numbers to names.
 * @type {Object}
 */
var glEnums = null;

/**
 * Initializes this module. Safe to call more than once.
 * @param {!WebGLRenderingContext} ctx A WebGL context. If
 *    you have more than one context it doesn't matter which one
 *    you pass in, it is only used to pull out constants.
 */
function init(ctx) {
  if (glEnums == null) {
    glEnums = { };
    for (var propertyName in ctx) {
      if (typeof ctx[propertyName] == 'number') {
        glEnums[ctx[propertyName]] = propertyName;
      }
    }
  }
}

/**
 * Checks the utils have been initialized.
 */
function checkInit() {
  if (glEnums == null) {
    throw 'WebGLDebugUtils.init(ctx) not called';
  }
}

/**
 * Returns true or false if value matches any WebGL enum
 * @param {*} value Value to check if it might be an enum.
 * @return {boolean} True if value matches one of the WebGL defined enums
 */
function mightBeEnum(value) {
  checkInit();
  return (glEnums[value] !== undefined);
}

/**
 * Gets an string version of an WebGL enum.
 *
 * Example:
 *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());
 *
 * @param {number} value Value to return an enum for
 * @return {string} The string version of the enum.
 */
function glEnumToString(value) {
  checkInit();
  var name = glEnums[value];
  return (name !== undefined) ? name :
      ("*UNKNOWN WebGL ENUM (0x" + value.toString(16) + ")");
}

/**
 * Returns the string version of a WebGL argument.
 * Attempts to convert enum arguments to strings.
 * @param {string} functionName the name of the WebGL function.
 * @param {number} argumentIndx the index of the argument.
 * @param {*} value The value of the argument.
 * @return {string} The value as a string.
 */
function glFunctionArgToString(functionName, argumentIndex, value) {
  var funcInfo = glValidEnumContexts[functionName];
  if (funcInfo !== undefined) {
    if (funcInfo[argumentIndex]) {
      return glEnumToString(value);
    }
  }
  if (value === null) {
    return "null";
  } else if (value === undefined) {
    return "undefined";
  } else {
    return value.toString();
  }
}

/**
 * Converts the arguments of a WebGL function to a string.
 * Attempts to convert enum arguments to strings.
 *
 * @param {string} functionName the name of the WebGL function.
 * @param {number} args The arguments.
 * @return {string} The arguments as a string.
 */
function glFunctionArgsToString(functionName, args) {
  // apparently we can't do args.join(",");
  var argStr = "";
  for (var ii = 0; ii < args.length; ++ii) {
    argStr += ((ii == 0) ? '' : ', ') +
        glFunctionArgToString(functionName, ii, args[ii]);
  }
  return argStr;
};


function makePropertyWrapper(wrapper, original, propertyName) {
  //log("wrap prop: " + propertyName);
  wrapper.__defineGetter__(propertyName, function() {
    return original[propertyName];
  });
  // TODO(gmane): this needs to handle properties that take more than
  // one value?
  wrapper.__defineSetter__(propertyName, function(value) {
    //log("set: " + propertyName);
    original[propertyName] = value;
  });
}

// Makes a function that calls a function on another object.
function makeFunctionWrapper(original, functionName) {
  //log("wrap fn: " + functionName);
  var f = original[functionName];
  return function() {
    //log("call: " + functionName);
    var result = f.apply(original, arguments);
    return result;
  };
}

/**
 * Given a WebGL context returns a wrapped context that calls
 * gl.getError after every command and calls a function if the
 * result is not gl.NO_ERROR.
 *
 * @param {!WebGLRenderingContext} ctx The webgl context to
 *        wrap.
 * @param {!function(err, funcName, args): void} opt_onErrorFunc
 *        The function to call when gl.getError returns an
 *        error. If not specified the default function calls
 *        console.log with a message.
 * @param {!function(funcName, args): void} opt_onFunc The
 *        function to call when each webgl function is called.
 *        You can use this to log all calls for example.
 */
function makeDebugContext(ctx, opt_onErrorFunc, opt_onFunc) {
  init(ctx);
  opt_onErrorFunc = opt_onErrorFunc || function(err, functionName, args) {
        // apparently we can't do args.join(",");
        var argStr = "";
        for (var ii = 0; ii < args.length; ++ii) {
          argStr += ((ii == 0) ? '' : ', ') +
              glFunctionArgToString(functionName, ii, args[ii]);
        }
        error("WebGL error "+ glEnumToString(err) + " in "+ functionName +
              "(" + argStr + ")");
      };

  // Holds booleans for each GL error so after we get the error ourselves
  // we can still return it to the client app.
  var glErrorShadow = { };

  // Makes a function that calls a WebGL function and then calls getError.
  function makeErrorWrapper(ctx, functionName) {
    return function() {
      if (opt_onFunc) {
        opt_onFunc(functionName, arguments);
      }
      var result = ctx[functionName].apply(ctx, arguments);
      var err = ctx.getError();
      if (err != 0) {
        glErrorShadow[err] = true;
        opt_onErrorFunc(err, functionName, arguments);
      }
      return result;
    };
  }

  // Make a an object that has a copy of every property of the WebGL context
  // but wraps all functions.
  var wrapper = {};
  for (var propertyName in ctx) {
    if (typeof ctx[propertyName] == 'function') {
       wrapper[propertyName] = makeErrorWrapper(ctx, propertyName);
     } else {
       makePropertyWrapper(wrapper, ctx, propertyName);
     }
  }

  // Override the getError function with one that returns our saved results.
  wrapper.getError = function() {
    for (var err in glErrorShadow) {
      if (glErrorShadow.hasOwnProperty(err)) {
        if (glErrorShadow[err]) {
          glErrorShadow[err] = false;
          return err;
        }
      }
    }
    return ctx.NO_ERROR;
  };

  return wrapper;
}

function resetToInitialState(ctx) {
  var numAttribs = ctx.getParameter(ctx.MAX_VERTEX_ATTRIBS);
  var tmp = ctx.createBuffer();
  ctx.bindBuffer(ctx.ARRAY_BUFFER, tmp);
  for (var ii = 0; ii < numAttribs; ++ii) {
    ctx.disableVertexAttribArray(ii);
    ctx.vertexAttribPointer(ii, 4, ctx.FLOAT, false, 0, 0);
    ctx.vertexAttrib1f(ii, 0);
  }
  ctx.deleteBuffer(tmp);

  var numTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);
  for (var ii = 0; ii < numTextureUnits; ++ii) {
    ctx.activeTexture(ctx.TEXTURE0 + ii);
    ctx.bindTexture(ctx.TEXTURE_CUBE_MAP, null);
    ctx.bindTexture(ctx.TEXTURE_2D, null);
  }

  ctx.activeTexture(ctx.TEXTURE0);
  ctx.useProgram(null);
  ctx.bindBuffer(ctx.ARRAY_BUFFER, null);
  ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, null);
  ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
  ctx.bindRenderbuffer(ctx.RENDERBUFFER, null);
  ctx.disable(ctx.BLEND);
  ctx.disable(ctx.CULL_FACE);
  ctx.disable(ctx.DEPTH_TEST);
  ctx.disable(ctx.DITHER);
  ctx.disable(ctx.SCISSOR_TEST);
  ctx.blendColor(0, 0, 0, 0);
  ctx.blendEquation(ctx.FUNC_ADD);
  ctx.blendFunc(ctx.ONE, ctx.ZERO);
  ctx.clearColor(0, 0, 0, 0);
  ctx.clearDepth(1);
  ctx.clearStencil(-1);
  ctx.colorMask(true, true, true, true);
  ctx.cullFace(ctx.BACK);
  ctx.depthFunc(ctx.LESS);
  ctx.depthMask(true);
  ctx.depthRange(0, 1);
  ctx.frontFace(ctx.CCW);
  ctx.hint(ctx.GENERATE_MIPMAP_HINT, ctx.DONT_CARE);
  ctx.lineWidth(1);
  ctx.pixelStorei(ctx.PACK_ALIGNMENT, 4);
  ctx.pixelStorei(ctx.UNPACK_ALIGNMENT, 4);
  ctx.pixelStorei(ctx.UNPACK_FLIP_Y_WEBGL, false);
  ctx.pixelStorei(ctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
  // TODO: Delete this IF.
  if (ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL) {
    ctx.pixelStorei(ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL, ctx.BROWSER_DEFAULT_WEBGL);
  }
  ctx.polygonOffset(0, 0);
  ctx.sampleCoverage(1, false);
  ctx.scissor(0, 0, ctx.canvas.width, ctx.canvas.height);
  ctx.stencilFunc(ctx.ALWAYS, 0, 0xFFFFFFFF);
  ctx.stencilMask(0xFFFFFFFF);
  ctx.stencilOp(ctx.KEEP, ctx.KEEP, ctx.KEEP);
  ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);
  ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT | ctx.STENCIL_BUFFER_BIT);

  // TODO: This should NOT be needed but Firefox fails with 'hint'
  while(ctx.getError());
}

function makeLostContextSimulatingCanvas(canvas) {
  var unwrappedContext_;
  var wrappedContext_;
  var onLost_ = [];
  var onRestored_ = [];
  var wrappedContext_ = {};
  var contextId_ = 1;
  var contextLost_ = false;
  var resourceId_ = 0;
  var resourceDb_ = [];
  var numCallsToLoseContext_ = 0;
  var numCalls_ = 0;
  var canRestore_ = false;
  var restoreTimeout_ = 0;

  // Holds booleans for each GL error so can simulate errors.
  var glErrorShadow_ = { };

  canvas.getContext = function(f) {
    return function() {
      var ctx = f.apply(canvas, arguments);
      // Did we get a context and is it a WebGL context?
      if (ctx instanceof WebGLRenderingContext) {
        if (ctx != unwrappedContext_) {
          if (unwrappedContext_) {
            throw "got different context"
          }
          unwrappedContext_ = ctx;
          wrappedContext_ = makeLostContextSimulatingContext(unwrappedContext_);
        }
        return wrappedContext_;
      }
      return ctx;
    }
  }(canvas.getContext);

  function wrapEvent(listener) {
    if (typeof(listener) == "function") {
      return listener;
    } else {
      return function(info) {
        listener.handleEvent(info);
      }
    }
  }

  var addOnContextLostListener = function(listener) {
    onLost_.push(wrapEvent(listener));
  };

  var addOnContextRestoredListener = function(listener) {
    onRestored_.push(wrapEvent(listener));
  };


  function wrapAddEventListener(canvas) {
    var f = canvas.addEventListener;
    canvas.addEventListener = function(type, listener, bubble) {
      switch (type) {
        case 'webglcontextlost':
          addOnContextLostListener(listener);
          break;
        case 'webglcontextrestored':
          addOnContextRestoredListener(listener);
          break;
        default:
          f.apply(canvas, arguments);
      }
    };
  }

  wrapAddEventListener(canvas);

  canvas.loseContext = function() {
    if (!contextLost_) {
      contextLost_ = true;
      numCallsToLoseContext_ = 0;
      ++contextId_;
      while (unwrappedContext_.getError());
      clearErrors();
      glErrorShadow_[unwrappedContext_.CONTEXT_LOST_WEBGL] = true;
      var event = makeWebGLContextEvent("context lost");
      var callbacks = onLost_.slice();
      setTimeout(function() {
          //log("numCallbacks:" + callbacks.length);
          for (var ii = 0; ii < callbacks.length; ++ii) {
            //log("calling callback:" + ii);
            callbacks[ii](event);
          }
          if (restoreTimeout_ >= 0) {
            setTimeout(function() {
                canvas.restoreContext();
              }, restoreTimeout_);
          }
        }, 0);
    }
  };

  canvas.restoreContext = function() {
    if (contextLost_) {
      if (onRestored_.length) {
        setTimeout(function() {
            if (!canRestore_) {
              throw "can not restore. webglcontestlost listener did not call event.preventDefault";
            }
            freeResources();
            resetToInitialState(unwrappedContext_);
            contextLost_ = false;
            numCalls_ = 0;
            canRestore_ = false;
            var callbacks = onRestored_.slice();
            var event = makeWebGLContextEvent("context restored");
            for (var ii = 0; ii < callbacks.length; ++ii) {
              callbacks[ii](event);
            }
          }, 0);
      }
    }
  };

  canvas.loseContextInNCalls = function(numCalls) {
    if (contextLost_) {
      throw "You can not ask a lost contet to be lost";
    }
    numCallsToLoseContext_ = numCalls_ + numCalls;
  };

  canvas.getNumCalls = function() {
    return numCalls_;
  };

  canvas.setRestoreTimeout = function(timeout) {
    restoreTimeout_ = timeout;
  };

  function isWebGLObject(obj) {
    //return false;
    return (obj instanceof WebGLBuffer ||
            obj instanceof WebGLFramebuffer ||
            obj instanceof WebGLProgram ||
            obj instanceof WebGLRenderbuffer ||
            obj instanceof WebGLShader ||
            obj instanceof WebGLTexture);
  }

  function checkResources(args) {
    for (var ii = 0; ii < args.length; ++ii) {
      var arg = args[ii];
      if (isWebGLObject(arg)) {
        return arg.__webglDebugContextLostId__ == contextId_;
      }
    }
    return true;
  }

  function clearErrors() {
    var k = Object.keys(glErrorShadow_);
    for (var ii = 0; ii < k.length; ++ii) {
      delete glErrorShadow_[k];
    }
  }

  function loseContextIfTime() {
    ++numCalls_;
    if (!contextLost_) {
      if (numCallsToLoseContext_ == numCalls_) {
        canvas.loseContext();
      }
    }
  }

  // Makes a function that simulates WebGL when out of context.
  function makeLostContextFunctionWrapper(ctx, functionName) {
    var f = ctx[functionName];
    return function() {
      // log("calling:" + functionName);
      // Only call the functions if the context is not lost.
      loseContextIfTime();
      if (!contextLost_) {
        //if (!checkResources(arguments)) {
        //  glErrorShadow_[wrappedContext_.INVALID_OPERATION] = true;
        //  return;
        //}
        var result = f.apply(ctx, arguments);
        return result;
      }
    };
  }

  function freeResources() {
    for (var ii = 0; ii < resourceDb_.length; ++ii) {
      var resource = resourceDb_[ii];
      if (resource instanceof WebGLBuffer) {
        unwrappedContext_.deleteBuffer(resource);
      } else if (resource instanceof WebGLFramebuffer) {
        unwrappedContext_.deleteFramebuffer(resource);
      } else if (resource instanceof WebGLProgram) {
        unwrappedContext_.deleteProgram(resource);
      } else if (resource instanceof WebGLRenderbuffer) {
        unwrappedContext_.deleteRenderbuffer(resource);
      } else if (resource instanceof WebGLShader) {
        unwrappedContext_.deleteShader(resource);
      } else if (resource instanceof WebGLTexture) {
        unwrappedContext_.deleteTexture(resource);
      }
    }
  }

  function makeWebGLContextEvent(statusMessage) {
    return {
      statusMessage: statusMessage,
      preventDefault: function() {
          canRestore_ = true;
        }
    };
  }

  return canvas;

  function makeLostContextSimulatingContext(ctx) {
    // copy all functions and properties to wrapper
    for (var propertyName in ctx) {
      if (typeof ctx[propertyName] == 'function') {
         wrappedContext_[propertyName] = makeLostContextFunctionWrapper(
             ctx, propertyName);
       } else {
         makePropertyWrapper(wrappedContext_, ctx, propertyName);
       }
    }

    // Wrap a few functions specially.
    wrappedContext_.getError = function() {
      loseContextIfTime();
      if (!contextLost_) {
        var err;
        while (err = unwrappedContext_.getError()) {
          glErrorShadow_[err] = true;
        }
      }
      for (var err in glErrorShadow_) {
        if (glErrorShadow_[err]) {
          delete glErrorShadow_[err];
          return err;
        }
      }
      return wrappedContext_.NO_ERROR;
    };

    var creationFunctions = [
      "createBuffer",
      "createFramebuffer",
      "createProgram",
      "createRenderbuffer",
      "createShader",
      "createTexture"
    ];
    for (var ii = 0; ii < creationFunctions.length; ++ii) {
      var functionName = creationFunctions[ii];
      wrappedContext_[functionName] = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return null;
          }
          var obj = f.apply(ctx, arguments);
          obj.__webglDebugContextLostId__ = contextId_;
          resourceDb_.push(obj);
          return obj;
        };
      }(ctx[functionName]);
    }

    var functionsThatShouldReturnNull = [
      "getActiveAttrib",
      "getActiveUniform",
      "getBufferParameter",
      "getContextAttributes",
      "getAttachedShaders",
      "getFramebufferAttachmentParameter",
      "getParameter",
      "getProgramParameter",
      "getProgramInfoLog",
      "getRenderbufferParameter",
      "getShaderParameter",
      "getShaderInfoLog",
      "getShaderSource",
      "getTexParameter",
      "getUniform",
      "getUniformLocation",
      "getVertexAttrib"
    ];
    for (var ii = 0; ii < functionsThatShouldReturnNull.length; ++ii) {
      var functionName = functionsThatShouldReturnNull[ii];
      wrappedContext_[functionName] = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return null;
          }
          return f.apply(ctx, arguments);
        }
      }(wrappedContext_[functionName]);
    }

    var isFunctions = [
      "isBuffer",
      "isEnabled",
      "isFramebuffer",
      "isProgram",
      "isRenderbuffer",
      "isShader",
      "isTexture"
    ];
    for (var ii = 0; ii < isFunctions.length; ++ii) {
      var functionName = isFunctions[ii];
      wrappedContext_[functionName] = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return false;
          }
          return f.apply(ctx, arguments);
        }
      }(wrappedContext_[functionName]);
    }

    wrappedContext_.checkFramebufferStatus = function(f) {
      return function() {
        loseContextIfTime();
        if (contextLost_) {
          return wrappedContext_.FRAMEBUFFER_UNSUPPORTED;
        }
        return f.apply(ctx, arguments);
      };
    }(wrappedContext_.checkFramebufferStatus);

    wrappedContext_.getAttribLocation = function(f) {
      return function() {
        loseContextIfTime();
        if (contextLost_) {
          return -1;
        }
        return f.apply(ctx, arguments);
      };
    }(wrappedContext_.getAttribLocation);

    wrappedContext_.getVertexAttribOffset = function(f) {
      return function() {
        loseContextIfTime();
        if (contextLost_) {
          return 0;
        }
        return f.apply(ctx, arguments);
      };
    }(wrappedContext_.getVertexAttribOffset);

    wrappedContext_.isContextLost = function() {
      return contextLost_;
    };

    return wrappedContext_;
  }
}

return {
    /**
     * Initializes this module. Safe to call more than once.
     * @param {!WebGLRenderingContext} ctx A WebGL context. If
    }
   *    you have more than one context it doesn't matter which one
   *    you pass in, it is only used to pull out constants.
   */
  'init': init,

  /**
   * Returns true or false if value matches any WebGL enum
   * @param {*} value Value to check if it might be an enum.
   * @return {boolean} True if value matches one of the WebGL defined enums
   */
  'mightBeEnum': mightBeEnum,

  /**
   * Gets an string version of an WebGL enum.
   *
   * Example:
   *   WebGLDebugUtil.init(ctx);
   *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());
   *
   * @param {number} value Value to return an enum for
   * @return {string} The string version of the enum.
   */
  'glEnumToString': glEnumToString,

  /**
   * Converts the argument of a WebGL function to a string.
   * Attempts to convert enum arguments to strings.
   *
   * Example:
   *   WebGLDebugUtil.init(ctx);
   *   var str = WebGLDebugUtil.glFunctionArgToString('bindTexture', 0, gl.TEXTURE_2D);
   *
   * would return 'TEXTURE_2D'
   *
   * @param {string} functionName the name of the WebGL function.
   * @param {number} argumentIndx the index of the argument.
   * @param {*} value The value of the argument.
   * @return {string} The value as a string.
   */
  'glFunctionArgToString': glFunctionArgToString,

  /**
   * Converts the arguments of a WebGL function to a string.
   * Attempts to convert enum arguments to strings.
   *
   * @param {string} functionName the name of the WebGL function.
   * @param {number} args The arguments.
   * @return {string} The arguments as a string.
   */
  'glFunctionArgsToString': glFunctionArgsToString,

  /**
   * Given a WebGL context returns a wrapped context that calls
   * gl.getError after every command and calls a function if the
   * result is not NO_ERROR.
   *
   * You can supply your own function if you want. For example, if you'd like
   * an exception thrown on any GL error you could do this
   *
   *    function throwOnGLError(err, funcName, args) {
   *      throw WebGLDebugUtils.glEnumToString(err) +
   *            " was caused by call to " + funcName;
   *    };
   *
   *    ctx = WebGLDebugUtils.makeDebugContext(
   *        canvas.getContext("webgl"), throwOnGLError);
   *
   * @param {!WebGLRenderingContext} ctx The webgl context to wrap.
   * @param {!function(err, funcName, args): void} opt_onErrorFunc The function
   *     to call when gl.getError returns an error. If not specified the default
   *     function calls console.log with a message.
   * @param {!function(funcName, args): void} opt_onFunc The
   *     function to call when each webgl function is called. You
   *     can use this to log all calls for example.
   */
  'makeDebugContext': makeDebugContext,

  /**
   * Given a canvas element returns a wrapped canvas element that will
   * simulate lost context. The canvas returned adds the following functions.
   *
   * loseContext:
   *   simulates a lost context event.
   *
   * restoreContext:
   *   simulates the context being restored.
   *
   * lostContextInNCalls:
   *   loses the context after N gl calls.
   *
   * getNumCalls:
   *   tells you how many gl calls there have been so far.
   *
   * setRestoreTimeout:
   *   sets the number of milliseconds until the context is restored
   *   after it has been lost. Defaults to 0. Pass -1 to prevent
   *   automatic restoring.
   *
   * @param {!Canvas} canvas The canvas element to wrap.
   */
  'makeLostContextSimulatingCanvas': makeLostContextSimulatingCanvas,

  /**
   * Resets a context to the initial state.
   * @param {!WebGLRenderingContext} ctx The webgl context to
   *     reset.
   */
  'resetToInitialState': resetToInitialState
};

}();

</script><dom-module id="wave-plots" assetpath="/">

<template></template>


<script>
"use strict";

// WavesRender is a class that does all the hard work for the wave-plots
// (hopefully) you can safely have multiple WavesRendere instances, i.e.
// one per wave-plots, if there are multiple wave-plot instances.

var WavesRenderer = (function(){

var palette_flag_register_ind = 2;
var float_texture_register_ind = 0; //this may need to be fixed at 0, not sure

var n_c = 4; // number of channels
var n_w = 50; // number of t points per channel

// Define metrics for the "off_canv"

// The following are all in units of actual pixels
var off_canv_w = 512;  // full width 
var off_canv_h = 800;  // full height
var off_canv_wave_h = 128; // height of a wave
var off_canv_dt = 2; //distance from t to t+1 on the wave
var off_canv_wave_gap = 4; //horizontal and vertical gap between waves

// These two are applied in css..the actual width used matches the pixels on the off_canv
var on_canv_w = n_c*n_w*2;
var on_canv_h = 256; // this is absolutely critical, if it's smaller then drawimage is about 50x slower.

var off_canv_count_increment = 0.00001;

var shader_strs = (function(){
// multiline, template strings are nice, but it's wierd that they use the enclosing scope
// rather than accepting a .format(dict) like in python, anyway....

var delta_t_x_offset = (off_canv_dt/off_canv_w*2).toPrecision(3);
var y_factor =  (1/(off_canv_h/off_canv_wave_h) * (1/128)).toPrecision(3);

return {

    vertex_flag: `
        attribute lowp float is_t_plus_one; // 0 1 0 1 0 1 0 1 ... 1 
        attribute float voltage; // v_1(t) v_1(t+1) v_2(t) v_2(t+1) v_3(t) ... v_n(t+1)  values are on the interval [0 1]
        attribute vec2 wave_xy_offset; // x_1 y_1  #  x_1 y_1  #  x_2 y_2  #  x_2 y_2  #  ... x_n y_n  #  x_n y_n  #
        attribute float wave_color_tex; //  #   #  c_1  #   #  c_1  #   #  c_2  #   #  c_2 ...  #   #  c_n  #   #  c_n
        uniform mediump float t_x_offset;   // canavas x-coordiantes from the leftmost point of the wave to point t
        varying lowp vec4 v_color;
        uniform sampler2D palette;
        const mediump float delta_t_x_offset = ${delta_t_x_offset}; // canvas x-coordinates from point t to point t+1
        const mediump float y_factor = ${y_factor}; //scales voltage values, initially expressed in [0 1], to lie withn +- wave_h/2, in canvas coords [-1 +1]

        void main(void) {
            //v_color = vec4(1.,0.,0.,1.);
            v_color = texture2D(palette, vec2(wave_color_tex, 0.));

            //calculate the x coordiante in canvas coordinates
            gl_Position.x = wave_xy_offset.x*(1./128.) -1. + t_x_offset + delta_t_x_offset*is_t_plus_one;

            //calculate the y coordiante in canvas coordinates
            gl_Position.y = wave_xy_offset.y*(1./128.) -1. + voltage*y_factor;

            // best to set the fourth element to 1
            gl_Position[3] = 1.;
        }
    `,


    fragment_flag: `
        varying lowp vec4 v_color;
        void main(void) {
            gl_FragColor = v_color;
        }
    `,


    vertex_density_1: `
        attribute lowp float is_t_plus_one; // 0 1 0 1 0 1 0 1 ... 1 
        attribute float voltage; // v_1(t) v_1(t+1) v_2(t) v_2(t+1) v_3(t) ... v_n(t+1)  values are on the interval [0 1]
        attribute vec2 wave_xy_offset; // x_1 y_1  x_1 y_1  x_2 y_2  x_2 y_2  ... x_n y_n x_n y_n 
        uniform mediump float t_x_offset;   // canavas x-coordiantes from the leftmost point of the wave to point t
        const mediump float delta_t_x_offset = ${delta_t_x_offset}; // canvas x-coordinates from point t to point t+1
        const mediump float y_factor = ${y_factor}; //scales voltage values, initially expressed in [0 1], to lie with 128 pixels expressed in canvas coords [-1 +1]

        void main(void) {
            //calculate the x coordiante in canvas coordinates
            gl_Position.x = wave_xy_offset.x*(1./128.) -1. + t_x_offset + delta_t_x_offset * is_t_plus_one;

            //calculate the y coordiante in canvas coordinates
            gl_Position.y = wave_xy_offset.y*(1./128.) -1. + voltage*y_factor;

            // best to set the fourth element to 1
            gl_Position[3] = 1.;
        }
    `,
     

    fragment_density_1: `
        void main(void) {
            gl_FragColor = vec4(${off_canv_count_increment}, 0., 0., 1.); 
        }
    `,


    vertex_density_2: `
        attribute vec2 a_tex_coord;
        varying vec2 v_tex_coord;
        attribute vec2 a_position;
        const vec2 u_resolution = vec2(${off_canv_w}.0, ${off_canv_h}.0);
        void main() {
            vec2 zero_to_one = a_position / u_resolution;
            vec2 zero_to_two = zero_to_one * 2.0;
            vec2 clip_space = zero_to_two - 1.0;
            gl_Position = vec4(clip_space, 0, 1);
            v_tex_coord = a_tex_coord;
        }
    `,


    fragment_density_2: `
        precision mediump float;
        uniform sampler2D u_src;
        varying vec2 v_tex_coord;
        uniform highp float normalising_factor;
        void main() {
            highp vec4 src = texture2D(u_src, v_tex_coord);
            highp float counts = sqrt(src.r*normalising_factor*10.);
            gl_FragColor = vec4(counts > 0.5 ?
                                     counts > 0.75 ?
                                         4. - 4.*counts 
                                        : 4.*counts-2. 
                                    : counts > 0.25 ?
                                         2. - 4.*counts 
                                        : counts*4.
                                 ,
                                 counts < 0.5 ? 
                                        2.*counts 
                                       : 2.-2.*counts
                                 , 
                                 counts
                                 ,
                                 src.a);
        }
    `
};

})()


var add_line_numbers = function(str){
    str = str.split("\n");
    var new_str = [];
    var L = str.length;
    for(var i=0;i<L;i++){
        new_str.push((i+1) + ".\t");
        new_str.push(str.shift());
        new_str.push("\n");
    }
    return new_str.join('');
}


var get_shader_from_string = function(gl, str, type){
   var shader = gl.createShader(type);
   gl.shaderSource(shader, str);
   gl.compileShader(shader);
   if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) == 0){
        console.log("Shader failed to compile:\n" + gl.getShaderInfoLog(shader) + add_line_numbers(str));
        throw "shader did not compile, see above,";
    }
    return shader;
}

var validate_program = function(gl, test_prog, throw_on_error){
    gl.validateProgram(test_prog);
    if (!gl.getProgramParameter(test_prog, gl.VALIDATE_STATUS)){
        console.log("Error during program validation:\n" + gl.getProgramInfoLog(test_prog));
        if(throw_on_error){
            throw "program did not compile, see above.";
        } else {
            return false;
        }
    }
    return true;
}

var upload_palette = function(gl, register_ind, data){
    gl.activeTexture(gl.TEXTURE0 + register_ind);
    gl.bindTexture(gl.TEXTURE_2D, gl.createTexture());
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 256, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
}

var WavesRenderer = function(callback, debug){
    
    this._callback = callback; // we send it a map from okey to canvas every time we finish a bunch of rendering

    // create the off_canv
    this.el_off_canv = document.createElement('canvas');
    this.el_off_canv.width = off_canv_w;
    this.el_off_canv.height = off_canv_h;
    this.el_off_canv.style.imageRendering = 'pixelated';

    // initialise gl context for the off_canv
    var gl = this.gl = this.el_off_canv.getContext("webgl") || this.el_off_canv.getContext("experimental-webgl");
    if(!this.gl){
        throw "could not get gl context.";
    }

    if(debug){
        //gl = this.gl = WebGLDebugUtils.makeDebugContext(gl, throwOnGLError, validateNoneOfTheArgsAreUndefined);
        this.debug_show_off_canv();
    }

    // TODO: we could possibly do the following lazily, i.e. when switching programs for the first time

    if (!gl.getExtension('OES_texture_float')) {
        console.log("No support for OES_texture_float");
        // TODO: this is needed for density mode, so should disable that mode
    }

    // compile all the shaders and link into a library of programs
    this._prog_flag = gl.createProgram();   
    gl.attachShader(this._prog_flag, get_shader_from_string(gl, shader_strs.vertex_flag, gl.VERTEX_SHADER));
    gl.attachShader(this._prog_flag, get_shader_from_string(gl, shader_strs.fragment_flag, gl.FRAGMENT_SHADER)); 
    gl.linkProgram(this._prog_flag);
    validate_program(gl, this._prog_flag, true);

    this._prog_density_1 = gl.createProgram();  
    gl.attachShader(this._prog_density_1, get_shader_from_string(gl, shader_strs.vertex_density_1, gl.VERTEX_SHADER));
    gl.attachShader(this._prog_density_1, get_shader_from_string(gl, shader_strs.fragment_density_1, gl.FRAGMENT_SHADER)); 
    gl.linkProgram(this._prog_density_1);
    validate_program(gl, this._prog_density_1, true);

    this._prog_density_2 = gl.createProgram();  
    gl.attachShader(this._prog_density_2, get_shader_from_string(gl, shader_strs.vertex_density_2, gl.VERTEX_SHADER));
    gl.attachShader(this._prog_density_2, get_shader_from_string(gl, shader_strs.fragment_density_2, gl.FRAGMENT_SHADER)); 
    gl.linkProgram(this._prog_density_2);
    validate_program(gl, this._prog_density_2, true);

    this._mode = undefined;
    this._active_sub_prog = undefined;

    // get all the uniforms/attribute locations for all programs
    this._locs_flag = {};
    this._locs_flag.wave_xy_offset = gl.getAttribLocation(this._prog_flag, "wave_xy_offset");
    this._locs_flag.is_t_plus_one = gl.getAttribLocation(this._prog_flag, "is_t_plus_one");
    this._locs_flag.wave_color_tex = gl.getAttribLocation(this._prog_flag, "wave_color_tex");
    this._locs_flag.voltage = gl.getAttribLocation(this._prog_flag, "voltage");
    this._locs_flag.t_x_offset = gl.getUniformLocation(this._prog_flag, "t_x_offset");
    this._locs_flag.palette = gl.getUniformLocation(this._prog_flag, "palette");

    this._locs_density_1 = {};
    this._locs_density_1.wave_xy_offset = gl.getAttribLocation(this._prog_density_1, "wave_xy_offset");
    this._locs_density_1.is_t_plus_one = gl.getAttribLocation(this._prog_density_1, "is_t_plus_one");
    this._locs_density_1.voltage = gl.getAttribLocation(this._prog_density_1, "voltage");
    this._locs_density_1.t_x_offset = gl.getUniformLocation(this._prog_density_1, "t_x_offset");

    this._locs_density_2 = {};
    this._locs_density_2.a_position = gl.getAttribLocation(this._prog_density_2, "a_position");
    this._locs_density_2.a_tex_coord = gl.getAttribLocation(this._prog_density_2, "a_tex_coord");
    this._locs_density_2.u_src = gl.getUniformLocation(this._prog_density_2, "u_src");
    this._locs_density_2.normalising_factor = gl.getUniformLocation(this._prog_density_2, "normalising_factor");

    // create all the neccessarry buffers (no space is actually allocated at this stage for data)
    this._buf_wave = gl.createBuffer();
    this._buf_voltage = gl.createBuffer();
    this._buf_is_t_plus_one = gl.createBuffer();
    
    // well, these two buffers are small and simple... (used only in the density_2 program)
    this._buf_a_position = gl.createBuffer();
    this._buf_a_tex_coord = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this._buf_a_position);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, off_canv_w, 0, 0, off_canv_h, 0, off_canv_h, off_canv_w, 0, off_canv_w, off_canv_h]), gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, this._buf_a_tex_coord);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW);

    // upload flag palette texture
    upload_palette(gl, palette_flag_register_ind, Palettes.flag); 

    // turn off depth testing since we want to just render in order (negative z is still invisible)
    gl.disable(gl.DEPTH_TEST);

    // prepare intermediate texture/buffer for density mode rendering
    this._off_texture = gl.createTexture();
    this._off_fbo = gl.createFramebuffer();

    this._okey_to_part_rendered = new Map(); // this holds {mode, group_num, n_t, and canvas}. items here are pending
    this._n_t_to_okeys = []; // a list of sets. Items in _okey_to_part_rendered, appear in the set at index item.n_t
    for(let ii=0; ii<n_c*(n_w-1); ii++){
        this._n_t_to_okeys.push(new Set()); // slightly wasteful, but probably not terrible in the grand scheme of things
    }
    this._okey_to_rendered = new Map(); // when a render completes, we send the canvas back to the polymer element, and store the settings used here
    this._show = 'n'; // currently you cannot toggle individual channels.
    this._has_voltages = false;
    this._timer = 0;
}

WavesRenderer.prototype._switch_to_flag_prog = function(){
    var gl = this.gl;
    this._active_sub_prog = 'flag';
    this.gl.useProgram(this._prog_flag);

    gl.disable(gl.BLEND);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    this.gl.uniform1i(this._locs_flag.palette, palette_flag_register_ind); 

    gl.enableVertexAttribArray(this._locs_flag.is_t_plus_one);
    gl.enableVertexAttribArray(this._locs_flag.wave_xy_offset);
    gl.enableVertexAttribArray(this._locs_flag.wave_color_tex);
    gl.enableVertexAttribArray(this._locs_flag.voltage);
    gl.bindBuffer(gl.ARRAY_BUFFER, this._buf_is_t_plus_one);
    gl.vertexAttribPointer(this._locs_flag.is_t_plus_one, 1, gl.UNSIGNED_BYTE, true, 1, 0);     
    gl.bindBuffer(gl.ARRAY_BUFFER, this._buf_wave);
    gl.vertexAttribPointer(this._locs_flag.wave_xy_offset, 2, gl.UNSIGNED_BYTE, false, 3, 0); 
    gl.vertexAttribPointer(this._locs_flag.wave_color_tex, 1, gl.UNSIGNED_BYTE, true, 3, 2);       

}

WavesRenderer.prototype._switch_to_density_1_prog = function(){
    var gl = this.gl;
    this._active_sub_prog = 'density_1';
    gl.useProgram(this._prog_density_1);

    gl.enable(gl.BLEND);
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.ONE, gl.ONE);

    gl.activeTexture(gl.TEXTURE0 + float_texture_register_ind);
    gl.bindTexture(gl.TEXTURE_2D, this._off_texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, off_canv_w, off_canv_h, 0, gl.RGBA,  gl.FLOAT, null);

    gl.bindFramebuffer(gl.FRAMEBUFFER, this._off_fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + float_texture_register_ind, gl.TEXTURE_2D, this._off_texture, 0);

    gl.enableVertexAttribArray(this._locs_density_1.is_t_plus_one);
    gl.enableVertexAttribArray(this._locs_density_1.wave_xy_offset);
    gl.enableVertexAttribArray(this._locs_density_1.voltage);
    gl.bindBuffer(gl.ARRAY_BUFFER, this._buf_is_t_plus_one);
    gl.vertexAttribPointer(this._locs_density_1.is_t_plus_one, 1, gl.UNSIGNED_BYTE, true, 1, 0); 
    gl.bindBuffer(gl.ARRAY_BUFFER, this._buf_wave);
    gl.vertexAttribPointer(this._locs_density_1.wave_xy_offset, 2, gl.UNSIGNED_BYTE, false, 2, 0); 

}


WavesRenderer.prototype._switch_to_density_2_prog = function(){
    var gl = this.gl;
    this._active_sub_prog = 'density_2';

    gl.useProgram(this._prog_density_2);
    gl.disable(gl.BLEND);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    gl.enableVertexAttribArray(this._locs_density_2.a_position);
    gl.enableVertexAttribArray(this._locs_density_2.a_tex_coord);
    gl.bindBuffer(gl.ARRAY_BUFFER, this._buf_a_position);
    gl.vertexAttribPointer(this._locs_density_2.a_position, 2, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, this._buf_a_tex_coord);
    gl.vertexAttribPointer(this._locs_density_2.a_tex_coord, 2, gl.FLOAT, false, 0, 0);

    gl.uniform1i(this._locs_density_2.u_src, float_texture_register_ind); 
    gl.activeTexture(gl.TEXTURE0 + float_texture_register_ind);
    gl.bindTexture(gl.TEXTURE_2D, this._off_texture); 

    gl.uniform1f(this._locs_density_2.normalising_factor, 1/this._n/off_canv_count_increment); 
    
}



WavesRenderer.prototype._run_density_2_prog = function(){
    var gl = this.gl;
    gl.drawArrays(gl.TRIANGLES, 0, 6);
}

WavesRenderer.prototype.set_n = function(n){
    var gl = this.gl;
    this._n = n;
    if(this._active_sub_prog === 'density_2'){
        gl.uniform1f(this._locs_density_2.normalising_factor, 1/this._n/off_canv_count_increment); 
    } 

    // uploads an 2n-length vector to the gpu, the vector is of the form 0 1 0 1 ... 0 1
    var data = new Uint8Array(n*2);
    for(var i=1;i<data.length;i+=2){
        data[i] = 255;
    }

    // upload to the gpu
    gl.bindBuffer(gl.ARRAY_BUFFER, this._buf_is_t_plus_one);
    gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW); 

}

WavesRenderer.prototype.set_mode = function(mode){
    if(this._mode === mode){
        return;
    }
    var gl = this.gl;

    this._mode = mode;
    if(this._mode === "flag"){
        this._switch_to_flag_prog();
    }else if(this._mode === "density"){
        this._switch_to_density_1_prog();
        if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE) {
           throw "gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE";
        }
    } else {
        console.log("unrecognised mode");
    }

    // update all the pending logic...
    this._deal_with_modified_okeys(Array.from(this._okey_to_part_rendered.keys())); //need to copy this because the map may be modified inside the function
    this._deal_with_modified_okeys(this._okey_to_rendered.keys());
    this._render_metrics = undefined;
    this._touch_timer();
}

WavesRenderer.prototype.set_voltage_data = function(prepared_voltage_data){
    var gl = this.gl;
    this._voltage_data = prepared_voltage_data;
    // the voltage data is pre-prepared exactly the way we wanted by the parse-data module.

     // The prepared_voltage data is really a concatenated list of many separate arrays,
    // where each array contains the data for all spikes at a specific channel-time, and is of
    // the form: v_1(t) v_1(t+1) v_2(t) v_2(t+1) v_3(t) ... v_n(t+1)
    // note there are 1 fewer such arrays then time points on the wave, n_w.
    if(prepared_voltage_data){
        this._has_voltages = true;
        gl.bindBuffer(gl.ARRAY_BUFFER, this._buf_voltage);
        gl.bufferData(gl.ARRAY_BUFFER, prepared_voltage_data.buffer, gl.DYNAMIC_DRAW); 
    } else {
        this._has_voltages = false;
        gl.bindBuffer(gl.ARRAY_BUFFER, this._buf_voltage);
        gl.bufferData(gl.ARRAY_BUFFER, gl.NONE, gl.DYNAMIC_DRAW);       
    }

    // note we don't set vertexAttribPointer here, because we do it multiple times
    // during the render
    this._touch_timer();
}

WavesRenderer.prototype._prepare_render_metrics = function(okeys, from_t, to_t){
    // okeys is an array of objs, each with .akey property that gives a akey.

    okeys = [null].concat(Array.from(okeys)); // if it was a set, then make it an array with well-defined order
                                                  // also, make the 0th okey null, because we render the rubbish in that
                                                  // bit of the canvas.

    // we want to draw all okeys to the off_canv in one go,
    // but in general we cant fit the full width of each okey on at the same time,
    // instead we render small slices from t to t+something. 
    // the question is, how big is that something?

    let n_okeys = okeys.length;
    let n_rows = Math.floor(off_canv_h/(off_canv_wave_h+off_canv_wave_gap)); // TODO: we should really have a vertical gap between waves

    let success = false;
    let n_cols, batch_t;
    for(batch_t=to_t-from_t; batch_t>3; batch_t = Math.ceil(batch_t/2)){
        n_cols = Math.floor(off_canv_w/(batch_t*off_canv_dt + off_canv_wave_gap));
        if(n_okeys <= n_cols * n_rows){
            success = true;
            break;
        }
    }

    if(!success){
        throw "too many okeys to render using current render logic"; // TODO: we could page through the okeys
    }

    // Now we compute that offsets for each okey, in both pixel coordinates
    let x_offset = new Uint16Array(n_rows*n_cols);
    let y_offset = new Uint16Array(n_rows*n_cols);
    
    for(let row=0, p=0; row<n_rows; row++){
        for(let col=0; col<n_cols; col++, p++){
            x_offset[p] = col*(batch_t*off_canv_dt + off_canv_wave_gap) + off_canv_wave_gap; // dunno why the +gap at the end, but it helps the first column
            y_offset[p] = row*(off_canv_wave_h + off_canv_wave_gap);
        }
    }

    // We could have done the following in the above loop, but hey, we use a second loop...

    // convert x and y offsets to 8-bit, which are the values to be passed to the vertex-shader.
    // Then convert the rounded values back to pixels, thus correcting the pixel values to match the
    // rounding errors involved.
    let xy_offset_gl_i8 = new Uint8Array(x_offset.length*2);
    for(let p=0; p<x_offset.length; p++){
        let x_gl = 0 | (x_offset[p]/off_canv_w * 256);
        let y_gl = 0 | ((y_offset[p] + off_canv_wave_h/2)/off_canv_h * 256); 
        xy_offset_gl_i8[p*2] = x_gl;
        xy_offset_gl_i8[p*2+1] = y_gl;
        let y_gl_11 = (y_gl*(1/128) -1); // value on interval [-1 to 1]
        y_offset[p] =  Math.max(0, (y_gl_11+1)*off_canv_h/2 - off_canv_wave_h/2);
    }

    return {
        from_t: from_t,
        to_t: to_t,
        batch_t: batch_t,
        x_offset: x_offset,
        y_offset: y_offset,
        xy_offset_gl_i8: xy_offset_gl_i8,
        okeys: okeys
    }
}

WavesRenderer.prototype._upload_okey_data = function(){
    var gl = this.gl;
    // okeys is an array of objs, each with .akey property that gives a akey.
    // if render mode is flag it must also provide a .group_num property.

    // Convert easy pixel coords to the weird [-128, 127] x [-128, 127] coordinates.
    // we will be assigning two elements at a time, so lets use 16bit view
    var render_metrics = this._render_metrics;
    var okeys = render_metrics.okeys; // 0th entry is null,  because offsets are reserved for rubbish

    var xy_offset_gl_i16 = new Uint16Array(render_metrics.xy_offset_gl_i8.buffer);  

    if(this._mode === 'density'){
        // just need to provide x and y

        var data_i8 = new Uint8Array(this._n*4); // TODO: it might be worth holding a reference to this permanentyl to avoid GC and realoc
        var data_i16 = new Uint16Array(data_i8.buffer);

        for(let ii=1; ii<okeys.length; ii++){
            let inds = okeys[ii].akey.array;
            let xy = xy_offset_gl_i16[ii];
            for(let jj=0; jj<inds.length; jj++){
                data_i16[(inds[jj]<<1) +0] = xy;
                data_i16[(inds[jj]<<1) +1] = xy;
            }
        }
    }else{
        // need to give x, y, and palette index

        // TODO: test whether it's faster to provide the full rgb color rather than a palette index. I suspect it might be.

        var data_i8 = new Uint8Array(this._n*6);
        var data_i16 = new Uint16Array(data_i8.buffer);
    
        for(let ii=1; ii<okeys.length; ii++){
            let inds = okeys[ii].akey.array;
            let xy = xy_offset_gl_i16[ii];
            let gx = okeys[ii].group_num |  (xy << 8); 
            let yg = ((0xff00 & xy) >>> 8) | (okeys[ii].group_num << 8);
            for(let jj=0; jj<inds.length; jj++){
                data_i16[inds[jj]*3 +0] = xy;
                data_i16[inds[jj]*3 +1] = gx;
                data_i16[inds[jj]*3 +2] = yg;
            }
        }
    }

    // upload it to the wave buffer on the gpu
    gl.bindBuffer(gl.ARRAY_BUFFER, this._buf_wave);
    gl.bufferData(gl.ARRAY_BUFFER, data_i8.buffer, gl.DYNAMIC_DRAW); 

    // tell the gpu where to find the wave data
    if(this._mode === 'density'){
        gl.vertexAttribPointer(this._locs_density_1.wave_xy_offset, 2, gl.UNSIGNED_BYTE, false, 2, 0);        
    }else{
        gl.vertexAttribPointer(this._locs_flag.wave_xy_offset, 2, gl.UNSIGNED_BYTE, false, 3, 0); 
        gl.vertexAttribPointer(this._locs_flag.wave_color_tex, 1, gl.UNSIGNED_BYTE, true, 3, 2);       
    }

}

WavesRenderer.prototype._options_match = function(a, group_num){
    if(!a || a.mode !== this._mode){
        return false;
    }
    if(a.mode === 'density'){
        return true;
    } else if(this._mode === 'flag' && a.group_num == group_num){
        return true;
    }
    return false;
}


WavesRenderer.prototype._deal_with_modified_okeys = function(okeys_modified){
    let results = new Map(); // we may be able to provide some resutls already

    for(let okey of okeys_modified){
        if(this._options_match(this._okey_to_rendered.get(okey), okey.group_num)){
            // this matches the last canvas we sent, so abandon any partial render (if there was one)
            // and send the results back to main again
            if(this._okey_to_part_rendered.has(okey)){
                this._n_t_to_okeys[this._okey_to_part_rendered.get(okey).n_t].delete(okey);
                this._okey_to_part_rendered.delete(okey);
            }
            results.set(okey, this._okey_to_rendered.get(okey).el_canv);
        } if (!this._okey_to_part_rendered.has(okey)){
            // this is different to the last thing we renderd, and we weren't
            // previously planning on rendering it. So need to render from scratch
            let part = {
                n_t: 0,
                el_canv: document.createElement('canvas'),
                main_has_canv: false
            };
            part.el_canv.width = off_canv_dt*n_c*(n_w-1);
            part.el_canv.height = on_canv_h;
            part.el_canv.style.width = part.el_canv.width  + "px"; // if managed-canvas sets the height then this will hold the width fixed
            part.ctx = part.el_canv.getContext('2d');
            this._okey_to_part_rendered.set(okey, part);
            this._n_t_to_okeys[0].add(okey);
        } else if (this._options_match(this._okey_to_part_rendered.get(okey), okey.group_num)){
            // this matches what we are already in the middle of trying to render,
            // so don't change anything
        } else {
            // we were trying to render this, but we now need to start again with new options
            let parts = this._okey_to_part_rendered.get(okey);
            if(parts.n_t > 0){ // had we actually rendered anything yet?
                this._n_t_to_okeys[parts.n_t].delete(okey);
                parts.ctx.clearRect(0, 0, parts.n_t*off_canv_dt, off_canv_wave_h);
                parts.n_t = 0;
                this._n_t_to_okeys[0].add(okey);
            }
        }
    }

    if(results.size > 0){
        this._callback(results);
    }
}

WavesRenderer.prototype.update_okeys = function(okeys_to_remove, okeys_to_add, okeys_modified){
    // okeys_modified is used when group_num changes for an existing okey
    // note how _okey_to_rendered is a map defining both the pending okeys, 
    // and their current state of render. When we are done rendering the canvas
    // is sent to the polymer-element, and the settings are stored in _okey_to_rendered.

    for(let okey of okeys_to_remove){
        this._okey_to_rendered.delete(okey);
        let part = this._okey_to_part_rendered.get(okey);
        if(part){
            this._n_t_to_okeys[part.n_t].delete(okey);
            this._okey_to_part_rendered.delete(okey);
        }
    }

    // originally the idea was to wait till we've finished rendering before providing
    // results, but actually the first time we render an okey we can actually make the
    // canvas we are going to draw to, and send it to main immediately.
    let results = new Map();
    for(let okey of okeys_to_add){
        let part = {
            n_t: 0,
            el_canv: document.createElement('canvas'), // TODO: might be good to avoid creating canvas entierly when show="n"
            main_has_canv: this._show === "y"
        }
        this._okey_to_part_rendered.set(okey, part);
        part.el_canv.width = off_canv_dt*n_c*(n_w-1);
        part.el_canv.height = on_canv_h;
        part.el_canv.style.width = part.el_canv.width  + "px";  // if managed-canvas sets the height then this will hold the width fixed
        part.ctx = part.el_canv.getContext('2d');
        this._n_t_to_okeys[0].add(okey);
        results.set(okey, part.el_canv);
    }
    if(this._show === "y"){
        this._callback(results);        
    }

    // dealing with modifeid okey is more complicated (and we
    // also do it when render mode changes), hence it has a function...
    this._deal_with_modified_okeys(okeys_modified);

    this._render_metrics = undefined;
    this._touch_timer();

}


WavesRenderer.prototype.set_show = function(v){
    this._show = v;
    if(this._show === "n"){
        for(let opts of this._okey_to_part_rendered.values()){
            opts.main_has_canv = false;
        }        
    } else {
        this._deal_with_modified_okeys(this._okey_to_rendered.keys());
    }
    this._touch_timer();
}

WavesRenderer.prototype._touch_timer = function(){
    // turns timer on if there's work to be done, otherwise stops it (if it was running)
    // note it's not actually a timer, because the interval is zero!
    // the point of using this is that it enables messages from elsewhere to interupt
    // between ticks, we can thus cancel work as and when needed.
    if(this._has_voltages && this._okey_to_part_rendered.size && this._show === 'y'){
        this._timer = this._timer || setImmediate(this._timer_tick.bind(this));
    } else{
        clearImmediate(this._timer);
        this._timer = 0;
    }
}


WavesRenderer.prototype._timer_tick = function(){
    // This is the where the main render takes place.
    this._timer = 0;
    if(this._show === "n"){
        return;
    }

    // TODO: we really don't need this mode-switching stuff here, 
    // though it's not a big deal I suppose.
    if(this._mode === 'density'){
        if(this._active_sub_prog !== "density_1"){
            this._switch_to_density_1_prog();
        }
    } else {
        if(this._active_sub_prog !== "flag"){
            this._switch_to_flag_prog();
        }
    }

    if(!this._render_metrics){
        let from_t, to_t;
        // okeys were modified since the last tick, so find the
        // first set of okeys to render, and prepare their render metrics...
        for(from_t=0; from_t<n_c*(n_w-1); from_t++){
            if(this._n_t_to_okeys[from_t].size){
                break;
            }
        }
        for(to_t=from_t+1; to_t<n_c*(n_w-1); to_t++){
            if(this._n_t_to_okeys[to_t].size){
                break;
            }
        }
        this._render_metrics = this._prepare_render_metrics(this._n_t_to_okeys[from_t], from_t, to_t);
        this._upload_okey_data();

    } // else the last tick has already prepared the _render_metrics for us

    var from_t = this._render_metrics.from_t;
    var end_t = Math.min(from_t + this._render_metrics.batch_t, this._render_metrics.to_t);
    var okeys = this._render_metrics.okeys; // an array not a set

    if(this._mode === 'density'){
        this._render_batch_density(from_t, end_t);
    }else if(this._mode == 'flag'){
        this._render_batch_flag(from_t, end_t);
    }

    this.gl.finish();
    // copy fragments from off_canv into individual canvases
    var width = (end_t - from_t) * off_canv_dt;
    var x_offsets = this._render_metrics.x_offset;
    var y_offsets = this._render_metrics.y_offset;  
    for(let ii=1; ii<okeys.length; ii++){
        let okey = okeys[ii];
        let part = this._okey_to_part_rendered.get(okey);
        part.ctx.drawImage(this.el_off_canv, x_offsets[ii], off_canv_h - 1 - y_offsets[ii] - off_canv_wave_h,
                            width, off_canv_wave_h, part.n_t*off_canv_dt, 0, width, on_canv_h);
    }

    // record that the okeys have now increaed their n_t
    if(end_t < n_c*(n_w-1)){
        // more work to do still...
        for(let ii=1; ii<okeys.length; ii++){
            let okey = okeys[ii];
            this._okey_to_part_rendered.get(okey).n_t = end_t;
            this._n_t_to_okeys[end_t].add(okey);
        }   
    } else {
        // finished rendering (everything). Note that the results should be absolutely up to date
        // because we're on the same thread as main and get notifications about changes to groups etc..
        let results = new Map();
        for(let ii=1; ii<okeys.length; ii++){
            let okey = okeys[ii];
            let part = this._okey_to_part_rendered.get(okey);
            let item =  {
                mode: this._mode,
                group_num: okey.group_num,
                el_canv: part.el_canv
            };
            this._okey_to_rendered.set(okey, item);
            if(!part.main_has_canv){
                results.set(okey, item.el_canv);
            }
            this._okey_to_part_rendered.delete(okey);
        }
        this._callback(results)

    }
    this._n_t_to_okeys[this._render_metrics.from_t].clear();


    // update render_metrics for the next tick
    if (end_t === n_c*(n_w-1)){
        this._render_metrics = undefined; // nothing left to render

    }else if (end_t === this._render_metrics.to_t){
        // the current set of okeys has caught up with the next
        // non-empty set, so we need to change the render metrics...
        // note that if things changed during the render we would have
        // already recalculated the render_metrics.to_t at that point.

        var okeys = this._n_t_to_okeys[end_t]; // includes the stuff we just rendered and the new stuff

        for(var to_t=end_t+1; to_t<n_c*(n_w-1); to_t++){
            if(this._n_t_to_okeys[to_t].size){
                break;
            }
        }
        this._prepare_render_metrics(okeys, end_t, to_t);
        this._upload_okey_data(); // it's a bit awkward to upload here...
                                // as we could poentially end up changing the 
                                // render metrics before use, but whatever, right?

    } else {
        // more batches to do before we finsih or the set of okeys grows
        this._render_metrics.from_t += this._render_metrics.batch_t;
    }

    //return; //debug
    this._touch_timer(); // and so it continues...
}

WavesRenderer.prototype._render_batch_flag = function(from_t, end_t){
    var gl = this.gl;
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); 
    gl.bindBuffer(gl.ARRAY_BUFFER, this._buf_voltage);

    for(let t=from_t; t<end_t; t++){
        gl.uniform1f(this._locs_flag.t_x_offset, off_canv_dt*(t-from_t)/off_canv_w*2); 

        // bind the voltage buffer with data for (t,t+1) and render it
        gl.vertexAttribPointer(this._locs_flag.voltage, 1, gl.BYTE, false, 1, t*this._n*2); 
        gl.drawArrays(gl.LINES, 0, 2*this._n); 
    }
}

WavesRenderer.prototype._render_batch_density = function(from_t, end_t){
    this._switch_to_density_1_prog();
    var gl = this.gl;
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); 
    gl.bindBuffer(gl.ARRAY_BUFFER, this._buf_voltage);

    for(let t=from_t; t<end_t; t++){
        gl.uniform1f(this._locs_density_1.t_x_offset, off_canv_dt*(t-from_t)/off_canv_w*2); 

        // bind the voltage buffer with data for (t,t+1) and render it
        gl.vertexAttribPointer(this._locs_density_1.voltage, 1, gl.BYTE, false, 1, t*this._n*2); 
        gl.drawArrays(gl.LINES, 0, 2*this._n); 
    }

    this._switch_to_density_2_prog();
    this._run_density_2_prog();
}

WavesRenderer.prototype.mask_at_vt = function(inds, point){
    let t = 0 | (point[1] / off_canv_dt);
    let v = 0 | (127 - (point[0] /on_canv_h)*255);
    let m = new Uint8Array(inds.length);
    let vdata = new Int8Array(this._voltage_data.buffer);
    let n = this._n;
    for(let ii=0; ii<inds.length; ii++){
        m[ii] = vdata[n*t*2 + inds[ii]*2] > v ? 1 : 0;
    }
    return m;
}

WavesRenderer.prototype.debug_show_off_canv = function(){
    this.el_off_canv.style.position = 'fixed';
    this.el_off_canv.style.right = "0px";
    this.el_off_canv.style.bottom = "0px";
    this.el_off_canv.style.background = "#fff";
    this.el_off_canv.style.border = "1px solid #f00";
    //this.el_off_canv.style.transform = 'scale(0.5)';
    //this.el_off_canv.style.transformOrigin = 'bottom right';
    document.body.appendChild(this.el_off_canv);
}


return WavesRenderer;

})();
    

Polymer({
    is:'wave-plots',
    behaviors: [
        Polymer.ShortcutNotifyerBehavior
    ],
    properties: {
        palette_mode: {
            type: String,
            value: "density",
            notify: true
        },
        show_chans: {
            type: String,
            value: "yyyy",
            notify: true
        },
        groups: {
            type: Array,
            value: function(){return [];},
            notify: true,
            observer: '_groups_set'
        },
        data_for_gl: {
            type: Object,
            value: function(){return {};}, // has n value and typed-array-manager id for gl voltages
            notify: true
        },
        want_data_for_gl: {
            type: Array,
            notify: true,
            observer: 'want_data_for_gl_set'
        }
    },
    observers: [
        '_groups_spliced(groups.splices)',
        '_palette_mode_changed(palette_mode)',
        '_show_chans_changed(show_chans)',
        '_data_for_gl_changed(data_for_gl)'
    ], created: function(){
        try{
            this._renderer = new WavesRenderer(this._okey_rendered.bind(this), false);
        } catch (e){
            console.log("failed to create renderer....\n" + e);
        }
        this._has_want_data_for_gl_ref = false;
    }, want_data_for_gl_set: function(){
        this._show_chans_changed(this.show_chans);
    }, _data_for_gl_changed: function(){
        // note that if gl data was avaialble and then we turned off show we will
        // get a null-ing event the next time the tet file changes...which is good.
        let is_null = !(this.data_for_gl && this.data_for_gl.voltages);
        this._renderer_has_voltages = false;
        if(is_null || this.show_chans === "yyyy"){ 
            this._renderer_has_voltages = true;
            this._renderer.set_n(this.data_for_gl && this.data_for_gl.n);
            this._renderer.set_voltage_data(this.data_for_gl && this.data_for_gl.voltages && this.data_for_gl.voltages.array);   
        } 
    }, _show_chans_changed: function(show_chans){
        if(!this.want_data_for_gl){
            return;
        }
        // note that unlike in rm/tac-plots, we let the renderer deal
        // with the complexities of show/hide, i.e. _update_okeys always
        // sends it the full update lists.  That's because sending messages
        // in this case does not invlove cloning and posting arrays.
        if(show_chans === 'yyyy'){
            let idx = this.want_data_for_gl.indexOf("wave-plots");
            (idx === -1) && this.push('want_data_for_gl', "wave-plots");

            this._renderer.set_show('y');
            if(!this._renderer_has_voltages){
                this._data_for_gl_changed(); // neccessarry if the gl data is already available, we just didnt' use it
            }
        } else if (show_chans === 'nnnn'){
            let idx = this.want_data_for_gl.indexOf("wave-plots");
            (idx > -1) && this.splice('want_data_for_gl', idx, 1);

            this._renderer.set_show('n');
            for(let okey of this.groups) if(okey && okey.waves){
                this.set('groups.' + okey._pkey + '.waves', null); 
            }
        } else {
            this.set('show_chans', 'yyyy');
            console.log("currently channels cannot be toggled individually");
        }
    }, _palette_mode_changed: function(){
        this._renderer.set_mode(this.palette_mode);
    }, _update_okeys: function(okeys_to_remove, okeys_to_add){
        // free canvases, it's our responsiblity to do this, whereas 
        // freeing the inds arrays was the responsibility of cut-obj.
        for(let okey of okeys_to_remove) if(okey && okey.waves){
            okey.waves = null; // Note we don't both to use the Polymer .set machienery, because the okey is being (at least temporarily) discarded
        }
        okeys_to_add = okeys_to_add.filter(function(okey){
            return okey ? 1 : 0;
        });
        this._renderer.update_okeys(okeys_to_remove, okeys_to_add, []); 

    }, _groups_set: function(new_val, old_val){
        this.groups_collection = Array.isArray(new_val) && Polymer.Collection.get(new_val);
        this._update_okeys(old_val || [], new_val || [], []);
    }, _groups_spliced: function(splices){
        let parsed = Utils.parse_splices(splices, true); 
        this._update_okeys(parsed.removed, parsed.added, parsed.moved);
    }, _okey_rendered: function(results){
        // results is a map from okey to canvas.
        for(let [okey, el_canvas] of results){
            let key = this.groups_collection.getKey(okey);
            if(!key){
                throw "group rendered unneccesairly"; // this should never happen because it's all happening on the same thread
            }
            if(!okey.waves || okey.waves.canvas !== el_canvas){
                okey.waves = {canvas: el_canvas};
                this.shortcutNotify('waves', okey.waves, okey); // actual path: 'groups.' + key + '.waves'
            } // else the current rendered canvas aparently has the desired options already, and the renderer just re-sent it to us
        }
    }, mask_at_vt: function(inds, point){
        return this._renderer.mask_at_vt(inds, point);
    }
});


</script>

  
</dom-module><dom-module id="paint-tool" assetpath="/">
<style>
:host{
display: inline-block;
opacity: 0.4;
}
</style>
<template>
    <canvas id="canv" width="[[width]]" height="[[height]]" style$="height:{{_use_css_height(css_height)}};"></canvas>
</template>

<script>
"use strict";

Polymer({
    is: 'paint-tool',
    properties: {
        width: {
            type: Number,
            notify: true
        },
        height: {
            type: Number,
            notify: true
        },
        negative: {
            type: Boolean
        },
        r: {
            type: Number,
            notify: true
        },
        active: {
            type: Boolean,
            notify: true,
            value: false
        },
        color: {
            type: String,
            value: '#003300'
        },
        css_height: {
            type: Number,
            notify: true,
            observer: '_use_css_height'
        }
    }, observers: [
        '_set_state(active, negative, color, width, height)'
    ], _use_css_height: function(h){
        let str = h ? h + 'px' : '';
        this.style.height = str;
        return str;
    }, _set_state : function(active, negative, color, width, height){
        this._ctx = this.$.canv.getContext('2d');
        if(active){
            (!this._bound) && this.listen(document, 'mousemove', '_mousemove');
            this._bound = true;

            this._old_x = null;
            this._old_y = null;

            if(this.negative){
                this._ctx.fillStyle = color;
                this._ctx.globalCompositeOperation = "source-over";  
                this._ctx.fillRect(0, 0, width, height);
                this._ctx.globalCompositeOperation = "destination-out";
            } else {
                this._ctx.globalCompositeOperation = "source-over";         
                this._ctx.clearRect(0, 0, width, height);
            }
        } else {
            this._bound && this.unlisten(document, 'mousemove', '_mousemove');
            this._bound = false;
            this._ctx.clearRect(0, 0, width, height);
        }
    }, _mousemove: function(e){
        let rect = this.getBoundingClientRect();
        let scale = this.width/rect.width;
        let x = (e.clientX - rect.left) * scale;
        let y = (e.clientY - rect.top) * scale;
        if(this._old_x === null){
            this._old_x = x-0.0001;
            this._old_y = y;
        }

        this._ctx.beginPath();
        this._ctx.lineWidth = this.r*2*scale;
        this._ctx.strokeStyle = this.color;
        this._ctx.lineCap = 'round';
        this._ctx.moveTo(this._old_x, this._old_y);
        this._ctx.lineTo(x, y);
        this._ctx.stroke();
        this._ctx.closePath();

        this._old_x = x;
        this._old_y = y;
    }, get_data: function(){
        return this._ctx && this._ctx.getImageData(0, 0, this.width, this.height); // object with width, height and data 
    }
});


</script>
</dom-module>

<dom-module id="cluster-plots" assetpath="/">

<script is="worker-builder" id="worker" title="cluster-plots" type="javascript/worker">
"use strict";


var palette_flag;

var set_palettes = function(arrays){
    palette_flag = arrays.flag;
}

var n_spikes;
var chan_is_ok;
var amps;
var plot_names;
var timer = 0;

var pkey_generation = 0;
var pkey_to_array = new Map();
var pkey_to_desired_options = new Map();
var pkeys_pending_render = [];

var n_c = 4; // TODO: probably shouldn't hard code this here..see parsed-data
var s = 256; // currently there is a 1-to-1 from amp values to pixels

// note that we initalize arrays for the maximum number of plots and never delte them
var plots = (function(){
    let p = [];
    for(let ii=0; ii<n_c*(n_c-1)/2; ii++){
        p.push(new Uint32Array(s*s));
    }
    return p;
})();


var update_pkeys = function(changes, options, arrays){

    if(changes){
        if(changes.generation_remove !== pkey_generation){
            changes.remove = [];
            pkey_to_array.clear();
            pkey_to_desired_options.clear();
            pkeys_pending_render = [];
            console.log("tac-plots worker: key generation mismatch");
        }

        // note we don't both to remove keys from the pending list
        // unless we change key generation, in which case we drop 
        // everything that's pending. This is ensures that when we
        // attempt a render we can be sure that if we do find the
        // array for the given key we know it's for the relevant 
        // generation and that it's still wanted.

        var remove_pkeys = changes.remove || [];
        for(let pkey of remove_pkeys){
            pkey_to_array.delete(pkey);
            pkey_to_desired_options.delete(pkey);
        }

        if(changes.generation_add !== changes.generation_remove){
            pkeys_pending_render = [];
            pkey_generation = changes.generation_add;
        }

        let add_pkeys = changes.add || [];
        for(let pkey of add_pkeys){
            pkey_to_array.set(pkey, arrays[pkey]);
        }

    }


    for(let item of options){
        pkey_to_desired_options.set(item.pkey, item);
        pkeys_pending_render.push(item.pkey);
    }
    touch_timer();
}

var fill_0 = function(x){
    // TypedArray.fill is apparently unoptimized

    for(let ii=0; ii<x.length; ii++){
        x[ii] = 0;
    }
}

var set_amps = function(n_spikes_, chan_is_ok_, arrays){
    n_spikes = n_spikes_;
    chan_is_ok = chan_is_ok_;
    amps = arrays && arrays.data; 
    for(let ii=0; ii<plots.length; ii++){
        fill_0(plots[ii])
    }
    plot_names = [];
    if(chan_is_ok){
        for(let c1=0, p=0; c1<n_c; c1++)if(chan_is_ok[c1]){
            for(let c2=c1+1; c2<n_c; c2++, p++)if(chan_is_ok[c2]){
                let name = (c1+1) + 'Ax' + (c2+1) + 'A';
                plot_names.push(name);
            }
        }        
    }
    touch_timer();
}

var touch_timer = function(){
    // turns timer on if there's work to be done, otherwise stops it (if it was running)
    // note it's not actually a timer, because the interval is zero!
    // the point of using this is that it enables messages from main thread to interupt
    // between ticks, we can thus cancel work as an when needed.
    if(amps && pkeys_pending_render.length){
        timer = timer || setImmediate(timer_tick);
    } else{
        clearImmediate(timer);
        timer = 0;
    }
}

var perform_render_sub = function(group_inds, color){
    for(let c1=0, p=0; c1<n_c; c1++)if(chan_is_ok[c1]){
        for(let c2=c1+1; c2<n_c; c2++)if(chan_is_ok[c2]){
            let im = plots[p++];
            for(let ii=0; ii<group_inds.length; ii++){
                let a1 = amps[group_inds[ii]*n_c +c1];
                let a2 = amps[group_inds[ii]*n_c +c2];
                im[(s-1-a1)*s + a2] = color;
            }
        }
    }
}

var perform_render = function(){
    // unlike tac and rm we render all pending groups in a single tick and then *copy*
    // the results back.
    while(pkeys_pending_render.length){
        let pkey = pkeys_pending_render.shift();
        let group_inds = pkey_to_array.get(pkey);
        if(group_inds){
            let pkey_opts = pkey_to_desired_options.get(pkey);
            let color = palette_flag[pkey_opts.group_num];
            perform_render_sub(group_inds, color)
        }        
    }
}


var timer_tick = function(){
    timer = 0;

    perform_render();

    // copy plots into the object to send back to main, labeling each plot
    // with its channel numbers.
    var arrays = {};
    for(let [ii, name] of plot_names.entries()){
        arrays[name] = plots[ii].slice(0);
    }
    exec_main_b('plot_clusters', {
        generation: pkey_generation,
        plots: plot_names,
        dims: [s,s]
    }, arrays);
}

var get_group_at = function(msg){
    // this is called when the user mousemoves on a canvas
    // it's hardly worth putting this on the worker thread, but maybe on day we
    // will do something more exciting here.

    let point = msg.point;
    let plot = plots[plot_names.indexOf(msg.plot)];
    if(!plot){
        return;
    }

    // we do something a bit dodgy, which is to look at the color and lookup the
    // original value in the inverse of the palette, so first build the inverse map...
    let palette_flag_inverse = {};
    for(let ii=0; ii< palette_flag.length; ii++){
        palette_flag_inverse[palette_flag[ii]] = ii;
    }

    // now we can count the occurance of each group
    let r = 4; // square ball radius, i.e. width is 2w+1
    let group_counts = new Uint32Array(256);
    for(let ii=Math.max(0, point[0]-r); ii< Math.min(s, point[0]+r+1); ii++){
        for(let jj=Math.max(0, point[1]-r); jj< Math.min(s, point[1]+r+1); jj++){
            let color = plot[ii*s + jj];
            let group_num = palette_flag_inverse[color];
            group_num >=0 && group_counts[group_num]++;
        }
    }

    // find the argmax of group_counts
    let max_group=null;
    let max_val=0;
    for(let ii=0; ii<group_counts.length; ii++) if(group_counts[ii] > max_val){
        max_group = ii;
        max_val = group_counts[ii];
    }

    exec_main('got_group_at', {
        generation: pkey_generation,
        point: point, // provide the details back to main so it can decide whether or not to use the result
        plot: msg.plot,
        group_num: max_group
    })
}

var compute_paint_masks = function(msg, arrays){
    // This is called on the mouseup of a paint event
    if(msg.mask_height !== s || msg.mask_width !== s){
        throw "paint mask must be " + s + " x " + s + ".";
    }
    
    let im = arrays.mask;
    let [c1, c2] = msg.plot.split('x');
    c1 = parseInt(c1) - 1;
    c2 = parseInt(c2) - 1;
    let pkeys = msg.pkeys;

    let arrays_out = {};
    for(let pkey of msg.pkeys){
        let inds = pkey_to_array.get(pkey);
        if(!inds || !inds.length){
            continue;
        }
        let m = new Uint8Array(inds.length);
        for(let ii=0; ii<m.length; ii++){
            let a1 = amps[inds[ii]*n_c + c1];
            let a2 = amps[inds[ii]*n_c + c2];
            m[ii] = !!im[(s-a1-1)*s + a2];
        }
        arrays_out[pkey] = m;
    }
    exec_main_b('computed_paint_masks', {
        generation: pkey_generation,
        pkeys: msg.pkeys
    }, arrays_out);
}
</script>


<style>
.sticker{
display: inline-block;
line-height: 14px;
width: 20px;
height: 17px;
border: 1px solid #000;
text-align: center;
font-size: 10px;
padding-top: 3px;
margin: 1px;
cursor: pointer;
}
.sticker_list{
line-height: 19px;
display: inline;
font-size: 0px;
}
.braket{
line-height: 19px;
font-size: 24px;
vertical-align: top;
}
:host{
--paper-tooltip-opacity: 0.96;
padding-left: 2px;
padding-right: 2px;
display: flex;
flex-direction: column;
height: 100%;
font-size: 0px;
}
::-webkit-scrollbar {
width: 10px;
height: 10px;
}
::-webkit-scrollbar-button {
width: 0;
height: 0;
display: none;
}
::-webkit-scrollbar-thumb {
background-color: rgba(0,0,0,0.2);
-webkit-box-shadow: inset 1px 1px 0 rgba(0,0,0,0.10),inset 0 -1px 0 rgba(0,0,0,0.07);
}
.bottom{
flex: 2;
text-align: center;
position: relative;
cursor: none;
}
.active_stickers{
float: left;
display: inline-block;
}
.others{
text-align: right;
display: block;
}
.new_group{
background: #ffffe0;
}
.plot{
display: inline-block;
position: relative;
@apply(--cluster-plot-style);
}
.grabber{
position: absolute;
top: 0px;
left: 0px;
right: 0px;
bottom: 0px;
}
.grabber:hover{
@apply(--grabber-hover);
}

</style>

<template>
    <iron-a11y-keys keys="enter+only" on-keys-pressed="_new_dest" target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="e+only e+shift" on-keys-pressed="_active_to_dest" target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="f+only f+shift" on-keys-pressed="_active_to_src" target="[[keyboard_target]]"></iron-a11y-keys>

    
    <iron-a11y-keys keys="+only" on-keys-pressed="_inc_size" target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="+only" on-keys-pressed="_dec_size" target="[[keyboard_target]]"></iron-a11y-keys>

    <div class="top" style$="[[_scroll_shadow(scrolled_down)]]">
        <div class="active_stickers">
            <div class="sticker_list">
                <div class="sticker" style$="{{_sticker_style(painter_state.dest, active_group_a)}}" on-mouseenter="_mouseenter_sticker_dest" on-mouseleave="_mouseleave_sticker">
                    [[painter_state.dest]] <paper-tooltip position="below">destination group [e]</paper-tooltip>
                </div>
            </div>
            <span class="braket"></span>
            <div class="sticker_list"><span class="braket">{</span>
                <template is="dom-repeat" items="[[painter_state.srcs]]">
                   <div class="sticker" style$="{{_sticker_style(item, active_group_a)}}" on-mouseup="_sticker_click" on-mouseenter="_mouseenter_sticker" on-mouseleave="_mouseleave_sticker">[[item]]</div>
                </template>
                <span class="braket">}</span>
                <paper-tooltip>source groups [e]</paper-tooltip>
            </div>
        </div>
        <div class="sticker_list others">
            <div class="sticker new_group" on-tap="_new_dest">
                <paper-tooltip>new destination group [Enter]</paper-tooltip>
            </div>
            <template is="dom-repeat" items="[[other_groups]]">
               <div class="sticker" style$="{{_sticker_style(item, active_group_a)}}" on-mouseup="_sticker_click" on-mouseenter="_mouseenter_sticker" on-mouseleave="_mouseleave_sticker">[[item]]</div>
            </template>
        </div>
    </div>

    <div class="bottom" id="bottom" on-mousedown="_start_paint" on-mousemove="_mousemove" on-mouseleave="_mouseleave">
        <div style="position: absolute; top:0; left:0; right:0; bottom: 0;overflow-y: scroll;" on-scroll="_update_scrolled_down">
            <template is="dom-repeat" items="[[cluster_plots]]">
                <div class="plot" style$="{{_show(item.is_used)}}">
                    <canvas-with-axes ckey="[[item.ckey]]" x_label="[[item.x_axis]]" y_label="[[item.y_axis]]" fix_height="[[canvas_size]]" on-canvas-mousemove="_mousemove_canvas" on-mouseleave="_mouseleave_canvas"></canvas-with-axes>
                </div>
            </template>
        </div>
        <cross-hair style$="{{_show(mouse_x)}}" r="[[painter_r]]" show_bars="0" top="0" left="0" x="[[mouse_x]]" y="[[mouse_y]]"></cross-hair>
        <div class="grabber" hidden$="{{!grabber_mode}}" on-mouseup="_grab" on-mousedown="_stop_propagation"></div>
        </div>
    

</template>
<script>
    "use strict";
    Polymer({
        is:'cluster-plots',
        properties: {
            canvas_size: {
                type: Number,
                notify: true,
                value: 128
            }, amplitudes: {
                type: Object,
                notify: true,
                value: function(){return {};}
            }, cluster_plots: {
                type: Array,
                notify: true,
                value: function(){return [];}
            }, groups: {
                type: Array,
                notify: true,
                value: function(){return [];},
                observer: '_groups_set'
            }, painter_state: {
                type: Object,
                notify: true,
                value: function(){return {
                    srcs: [0],
                    dest: 0
                }}
            }, other_groups:{
                type: Array,
                notify: true,
                value: function(){return [];},
                readOnly: true // TODO: this is really a computed-property, but I couldn't get it to work with .splices
                                // instead we use observers
            }, keyboard_target: {
                type: Object,
                value: function(){return document.querySelector('body');}
            }, want_amplitudes: {
                type: Array,
                notify: true,
                observer: '_want_amplitudes_set'
            }, active_group_a:{
                type: Object,
                value: null,
                notify: true
            }, painter_r: {
                type: Number,
                notify: true,
                observer: '_painter_r_changed'
            }, mouse_x: {
                type: Number,
                value: -1,
                notify: true,
                readOnly: true
            }, mouse_y: {
                type: Number,
                value: -1,
                notify: true,
                readOnly: true
            }, scrolled_down: {
                type: Boolean,
                value: false,
                notify: true,
                readOnly: true
            }, grabber_mode: {
                type: Boolean,
                value: false,
                notify: true
            }
        }, observers: [
            '_groups_spliced(groups.splices)',
            '_compute_unused_groups(painter_state.*)',
            '_amplitudes_modified(amplitudes)'
        ], listeners: {
            'mousewheel': '_scroll'
        }, created: function(){
            var worker_builder = Polymer.DomModule.import('cluster-plots','#worker');
            this._worker = worker_builder.create_for(this);
            this._worker.exec_b('set_palettes', {flag: Palettes.flag32.slice(0)});
            this._pkey_generation = 0;
        }, ready: function(){
            let n_c = 4; // TODO: get this from parsed-data
            let s = 256; // TODO: this too, and maybe alow scaling
            let plots = [];
            for(let ii=0; ii<n_c*(n_c-1)/2; ii++){
                plots.push({
                    ckey: null,
                    is_used: false
                });
            }
            this.set('cluster_plots', plots);
            // TODO: we might want to tie the plots to the cut for ease of grabbing
        }, _want_amplitudes_set: function(){
            this.push('want_amplitudes', 'cluster-plots');
        }, _amplitudes_modified: function(){
            if(this.amplitudes){
                var arr = Utils.typed_array_manager.get_array_clone(this.amplitudes.amps);
                this._worker.exec_b('set_amps', this.amplitudes.n, this.amplitudes.chan_is_ok, 
                                    {data: arr});
            } else {
                if(!this._worker) return;
                this._worker.exec('set_amps', {});
            }
        }, _groups_set: function(new_val, old_val){
            this._compute_unused_groups();
            this._groups_collection = Array.isArray(new_val) && Polymer.Collection.get(new_val);
            this._update_okeys(old_val || [], new_val || [], this._pkey_generation, ++this._pkey_generation); // added keys are for a new generation
        }, _groups_spliced: function(splices){
            this._compute_unused_groups();
            let parsed = Utils.parse_splices(splices);
            this._update_okeys(parsed.removed, parsed.added, this._pkey_generation, this._pkey_generation);
        }, _update_okeys: function(okeys_to_remove, okeys_to_add, generation_remove, generation_add){
            var am = Utils.typed_array_manager;
            
            var added_arrays = {};
            var pkeys_to_add = []; 
            var options = [];
            // get clones of new arrays to send to worker
            for(let okey of okeys_to_add){
                if(!okey) continue;
                pkeys_to_add.push(okey._pkey);
                added_arrays[okey._pkey] = am.get_array_clone(okey.akey);
                options.push({
                    pkey: okey._pkey,
                    group_num: okey.group_num
                });
            }

            var pkeys_to_remove = [];
            for(let okey of okeys_to_remove){
                if(!okey) continue;
                pkeys_to_remove.push(okey._pkey);
            }

            // inform worker of the new/deleted arrays
            this._worker.exec_b('update_pkeys', {
                add: pkeys_to_add,
                remove: pkeys_to_remove,
                generation_remove: generation_remove,
                generation_add: generation_add
            }, options, added_arrays);

        }, _sticker_style: function(group_num, active_group_a){
            return "background-color:" + Palettes.flag_css[group_num] + ";color:" + Palettes.flag_css_text[group_num] + ";" +
                    (active_group_a && active_group_a.group_num===group_num ? "box-shadow:0px 0px 5px 3px #fc0;" : "");
        }, _compute_unused_groups: function(){
            if(!this.groups){
                this._setOther_groups([]);
                return [];
            }
            let others = [];
            for(let okey of this.groups)if(okey){
                if(this.painter_state.srcs.indexOf(okey.group_num) === -1 &&
                    this.painter_state.dest !== okey.group_num){
                    others.push(okey.group_num)
                }
            }
            this._setOther_groups(others);
        }, _new_dest: function(){
            // finds first unused number, ignoring zero
            for(let [ii, gg] of this.groups.entries()){
                if(!gg && ii>0){
                    this.set('painter_state.dest', ii);
                }
            }
            this.set('painter_state.dest', this.groups.length);
        }, _select_dest: function(num){
            this.set('painter_state.dest', num);
            let index_in_src = this.painter_state.srcs.indexOf(num);
            (index_in_src > -1) && this.splice('painter_state.srcs', index_in_src, 1);
        }, _select_src: function(num, shift){
            if(shift){
                let index_in_src = this.painter_state.srcs.indexOf(num);
                if(index_in_src > -1){
                    this.splice('painter_state.srcs', index_in_src, 1);
                } else {
                    this.push('painter_state.srcs', num);
                }
            }else{
                this.splice('painter_state.srcs', 0, this.painter_state.srcs.length, num); //remove all and replace with just num
            }
        }, _active_to_dest: function(e){
            (this.active_group_a !== null) && this._select_dest(this.active_group_a.group_num);
        }, _active_to_src: function(e){
             (this.active_group_a !== null) && this._select_src(this.active_group_a.group_num, e.detail.keyboardEvent.shiftKey);
        }, _sticker_click: function(e){
            let num = e.model.item;
            if(e.button === 0){
                // left button, select as dest
                this._select_dest(num);
            } else {
                // not left button, select as source, 
                // splice in/out if shift down, otherwise clear array and set to just num
                this._select_src(num, e.shiftKey);
            }
        }, plot_clusters: function(msg, arrays){
            if(msg.generation !== this._pkey_generation){
                return; // pft, get with the times
            }
            for(let [ii, label] of msg.plots.entries()){
                this.set('cluster_plots.' + ii + '.ckey', {
                    buffer: arrays[label].buffer,
                    dims: msg.dims
                });
                let axes = label.split('x');
                this.set('cluster_plots.' + ii + '.x_axis', axes[1]);
                this.set('cluster_plots.' + ii + '.y_axis', axes[0]);
                this.set('cluster_plots.' + ii + '.is_used', true);
            }
            for(let ii=msg.plots.length; ii<this.cluster_plots.length; ii++){
                this.set('cluster_plots.' + ii + '.is_used', false);
            }
        }, _inc_size: function(){
            this.set('canvas_size', Math.min(this.canvas_size+32, 512));
        }, _dec_size: function(){
            this.set('canvas_size', Math.max(this.canvas_size-32, 32));
        }, _show: function(v){
            return v ? '' : 'display: none;';
        }, _mousemove_canvas: function(e){
            let plot_name = e.model.item.y_axis + 'x' + e.model.item.x_axis;
            this._mouse_over_plot = plot_name;
            this._worker.exec('get_group_at', {
                plot: plot_name,
                point: e.detail.canvas_point
            });
        }, _mouseleave_canvas: function(){
            this._mouse_over_plot = null;
            this.set('active_group_a', null);
        }, got_group_at: function(msg){
            if(this._mouse_over_plot !== msg.plot){
                return; // TODO: we could check the msg.point to see if it's still close, but whatever
            }
            this.set('active_group_a', this._okey_from_group_num(msg.group_num));  
        }, _mouseenter_sticker: function(e){
            this.set('active_group_a', this._okey_from_group_num(e.model.item));  
        }, _mouseleave_sticker: function(){
            this.set('active_group_a', null);
        }, _mouseenter_sticker_dest: function(){
            this.set('active_group_a', this._okey_from_group_num(this.painter_state.dest));
        }, _okey_from_group_num: function(num){
            for(let okey of this.groups)if(okey && okey.group_num === num){
                return okey
            }
            return null;
        }, _start_paint: function(e){
            this._painter_el = document.createElement('paint-tool');
            this._painter_el.set('css_height', this.canvas_size);
            this._painter_el.set('width', 256); // this has to match the actual height used in cluster plots
            this._painter_el.set('height', 256);
            this._painter_el.set('r', this.painter_r);
            this._painter_el.style.position = 'absolute';
            this._painter_el.style.top = '1px';
            this._painter_el.style.left = '1px';
            this._painter_el.set('negative', e.button !== 0);
            this._painter_el.set('active', true);

            // work out which plot is closest (or underneath) the click location...
            let plots = Polymer.dom(this.root).querySelectorAll('.plot');
            let min_dist = Infinity;
            this._paint_ii = null;
            for(let [ii, plot] of plots.entries()){
                let rect = plot.getBoundingClientRect();
                let x_dist = e.clientX < rect.left ? 
                                 e.clientX - rect.left
                             : e.clientX > rect.left + rect.width ?
                                 e.clientX - (rect.left + rect.width)
                             : 0;
                let y_dist = e.clientY < rect.top ? 
                                 e.clientY - rect.top
                             : e.clientY > rect.top + rect.height ?
                                 e.clientY - (rect.top + rect.height)
                             : 0;
                let dist = Math.hypot(x_dist, y_dist);
                if(dist === 0){
                    this._paint_ii = ii;
                    break;
                } else if(dist< min_dist){
                    this._paint_ii = ii;
                    min_dist = dist;
                }
            }

            plots[this._paint_ii].appendChild(this._painter_el);
            this.listen(document, 'mouseup', '_end_paint');
            Polymer.dom.flush();
            this.fire('paint',{
                state: 'start'
            });
            this._painter_el._mousemove(e);
        }, _end_paint: function(){
            this.unlisten(document, 'mouseup', '_end_paint');
            let result = this._painter_el.get_data();

            this._worker.exec_b('compute_paint_masks', {
                plot: this.cluster_plots[this._paint_ii].y_axis + 'x' +
                      this.cluster_plots[this._paint_ii].x_axis,
                mask: 'mask',
                mask_width: result.width,
                mask_height: result.height,
                pkeys: this.painter_state.srcs.map(function(num){
                    return num != this.painter_state.dest && this.groups[num] && this.groups[num]._pkey
                }, this)
            }, {
                mask: new Uint32Array(result.data.buffer)
            });

            this._painter_el.set('active', false);
            this._painter_el.parentNode.removeChild(this._painter_el);
            this._painter_el = null;

        }, computed_paint_masks: function(msg, arrays){
            // convert from pkeys to group_nums, which is the reverse of what we did
            // when sending to the worker.  Note that we basically assume that nothing 
            // has changed in the interim.
            let coll =  Polymer.Collection.get(this.groups);
            let masks = {};
            for(let pkey of msg.pkeys){
                let g = coll.getItem(pkey);
                g && (masks[g.group_num] = arrays[pkey]);
            }
            this.fire('paint', {
                state: 'end',
                src_masks: masks,
                dest: this.painter_state.dest
            });
        }, _scroll: function(e){
            let inc = e.wheelDelta > 0 ? 5 : -5;
            this.set('painter_r', Math.max(Math.min(this.painter_r + inc, 80), 5));
            e.preventDefault();
        }, _mousemove: function(e){
            let rect = this.$.bottom.getBoundingClientRect();
            this._setMouse_x(e.clientX - rect.left);
            this._setMouse_y(e.clientY - rect.top);
        }, _mouseleave: function(e){
            this._setMouse_x(-1);
            this._setMouse_y(-1);
        }, _painter_r_changed: function(){
            if(this._painter_el){
                this._painter_el.set('r', this.painter_r);
            }
        }, _update_scrolled_down: function(e){
            this._setScrolled_down(e.target.scrollTop > 0);
        }, _scroll_shadow: function(v){
            return v ? 'box-shadow: 0px 3px 4px 0px #bbb;z-index: 1;' : '';
        }, _show: function(v){
            return v !== false && v>=0 ? '' : 'display: none;';
        }, highlight_group: function(group_num){
             let okey = this.groups[group_num];
             if(!okey){
                return;
             }
             this._worker.exec('update_pkeys',null,[{
                pkey: okey._pkey,
                group_num: group_num
                }]);
        }, _grab: function(e){
            let plots = [];
            for(let pp of this.cluster_plots){
                if(pp.is_used){
                    plots.push(Object.assign({}, pp));
                }
            }
            let rect  = this.getBoundingClientRect();
            this.fire('grab', {
                plots: plots,
                src_client_x: rect.left,
                src_client_y: rect.top
            });
        }, _stop_propagation: function(e){
            e.stopPropagation();
        }
    });
</script>

  
</dom-module></div>

<template is="dom-bind" id="wav">

    <iron-localstorage name="waveform" value="{{stored_options}}"></iron-localstorage>
    <value-transform value_b="{{options}}" value_a="{{stored_options}}" a_to_b="_sanitize_options"></value-transform>
            
    <floating-pane id="action_info" grabber_mode="[[grabber_mode]]" hidden="">
        <div class="pane_title">Action List [z]</div>
        <undo-stack-view undo_stack="[[cut_undo_stack]]" redo_stack="[[cut_redo_stack]]"></undo-stack-view>
    </floating-pane>

    <floating-pane id="tc_info" grabber_mode="[[grabber_mode]]" hidden="">
        <div class="pane_title">Temporal auto correlation [t]</div>
        <p class="nodrag">
            Time window <span class="slider_val">[[options.max_delta_t]] ms</span><br>
            <paper-slider pin="" snaps="" min="20" max="5000" step="20" value="{{options.max_delta_t}}" style="width:300px;"></paper-slider><br>
        </p><p>
            The number of bins is fixed at 100.
        </p>
    </floating-pane>

    <floating-pane id="drift_info" grabber_mode="[[grabber_mode]]" hidden="">
        <div class="pane_title">Drift [d]</div>
        Render the cluster plots and spatial spike plot using a palette that shows the average time for spikes in each pixel (smoothing is applied in the case of the cluster plots but not for the spatial plot). <br><br>
        <div style="/* background:#f00; */color: #fff; text-align: center;background: -moz-linear-gradient(left, #ff0000 0%, #00ff00 100%); /* FF3.6+ */  background: -webkit-gradient(linear, left top, right top, color-stop(0%,#ff0000), color-stop(100%,#00ff00)); /* Chrome,Safari4+ */  background: -webkit-linear-gradient(left, #ff0000 0%,#00ff00 100%); /* Chrome10+,Safari5.1+ */  background: -o-linear-gradient(left, #ff0000 0%,#00ff00 100%); /* Opera 11.10+ */  background: -ms-linear-gradient(left, #ff0000 0%,#00ff00 100%); /* IE10+ */  background: linear-gradient(to right, #ff0000 0%,#00ff00 100%); /* W3C */;">early mean time ------ late mean time</div><br><br>
        So red means that the spikes have "dissapeared" from that area of the plot as the trial progressed, while green means "new" spikes have "appeared" (scare quotes needed because it could be more complciated than this).<br>
    </floating-pane>
                
    <floating-pane id="shortcut_info" grabber_mode="[[grabber_mode]]" style="max-height: 350px;" hidden="">
        <div class="pane_title">Shortcuts [k]</div>
        <p>
            For most of the following shortcuts, if you use <b>alt-x</b> instead of just <b>x</b> you will toggle the settings 
            pane for the given feature, e.g. <b>alt-r</b> toggles the settings pane for spatial ratemap, whereas <b>r</b> 
            by itself toggles the actual ratemap plots.  (In some cases <b>alt</b> is not needed because toggling the pane is
            the only action linked to the shortcut.)
        </p><p>
             Shorcuts for the plots shown for each group; use <b>shift</b> to select multiple:
            </p><ul>
            <li><b>w</b> waveforms</li>
            <li><b>r</b> spatial ratemap</li>
            <li><b>c</b> directional ratemap ("c" is for circle)</li>
            <li><b>v</b> speed ratemap ("v" is for velocity)</li>
            <li><b>t</b> temporal autocorrelogram</li>
            </ul>
        <p></p><p>
            Shorcuts applied to the "active" group, which is the one under the cursor:
            </p><ul>
            <li><b>e</b> set the cluster painting destination group to the active group.</li>
            <li><b>f</b> set the cluster painting srouce group to the active group. Note you can hold down shift to toggle multiple source groups on/off.</li>
            <li><b>s</b> launch the swap dialog for the "active" group.</li>
            <li><b>ctrl-c</b> copy the active group's plots and some info text to the system clipboard.</li>
            </ul>           
        <p></p><p>
            Other shortcuts:
            </p><ul>
            <li><b>0-9</b> jump to tetrode number with 1s digit 0-9</li>
            <li><b>o</b> (the letter "o") toggle 10s digit of tetrode number</li>
            <li><b>d</b> toggle drift rendering on/off</li>
            <li><b>space</b> hold down space and click with mouse for plot grabbing or removal</li>
            <li><b>+/-</b> grow/shrink size of cluster plots (note that "+" is actually the "=" key)</li>
            <li><b>enter</b> increment cluster painting destination group</li>
            <li><b>esc</b> open/close the toolbar</li>
            <li><b>p</b> toggle waveform palette</li>
            <li><b>h</b> show header info</li>
            <li><b>x</b> show pos settings</li>
            <li><b>k</b> show this info ("k" is for keyboard)</li>
            <li><b>?</b> open GitHub info in a new tab</li>
            </ul>   
        <p></p>                    
    </floating-pane>
    
    <floating-pane id="speed_info" grabber_mode="[[grabber_mode]]" hidden="">
        <div class="pane_title">Speed ratemap [v]</div>
        <p>
            Bin size <span class="slider_val">4 cm/s</span><br>
            Upper limit <span class="slider_val">45 cm/s</span>
        </p><p>
            Histogram shows slowest speed at the top, and upper limit speed at the bottom.
        </p><p>
            WARNING: speed plots are still in alpha testing (unlike everything else which is just about in beta!).
        </p>
    </floating-pane>

    <floating-pane id="waves_info" grabber_mode="[[grabber_mode]]" hidden="">
        <div class="pane_title">Waves [w]</div>
        <p>
            There are two palette modes. 
        </p><p class="nodrag">
            Render in <span class="slider_val">[[options.waves_render_mode]]</span> mode.<br>
            <paper-toggle-button checked="{{waves_toggle_raw}}"></paper-toggle-button>
            <value-transform value_a="{{options.waves_render_mode}}" value_b="{{waves_toggle_raw}}" b_to_a="_to_render_mode_str" a_to_b="_from_render_mode_str"></value-transform>
        </p><p>
            In "flag" mode, each group from 0 to 30 gets its own color, and is rendered solidly in that color.
        </p><p>
            In "density" mode, the color of each pixel reflects the proportion of the waves which cross it.
        </p>
    </floating-pane>

    <floating-pane id="header_info" grabber_mode="[[grabber_mode]]" has_search="" search_text="{{options.header_filter}}" search_placeholder="filter headers" disable_shortcuts="{{disable_shortcuts}}" hidden="">
        <div class="pane_title">File headers [h]</div>
        <header-view set_header="[[set_header]]" pos_header="[[pos_header]]" tet_header="[[tet_header]]" cut_header="[[_get_safe(cut_box,'header')]]" header_filter="[[options.header_filter]]"></header-view>
    </floating-pane>

    <floating-pane id="rm_info" grabber_mode="[[grabber_mode]]" hidden="">
        <div class="pane_title">Spatial ratemap [r]</div>
        <p class="nodrag">
            Bin size <span class="slider_val">[[options.cm_per_spa_bin]] cm</span><br>
            <paper-slider pin="" snaps="" min="0.5" max="10" step="0.5" value="{{options.cm_per_spa_bin}}" style="width:300px"></paper-slider>
        </p><p class="nodrag">
            Smoothing kernel boxcar <span class="slider_val">(2x[[options.smoothing_spa_bins]]+1) by (2x[[options.smoothing_spa_bins]]+1) bins</span><br>
            <paper-slider pin="" snaps="" min="0" max="5" step="1" value="{{options.smoothing_spa_bins}}" style="width:300px;"></paper-slider>
        </p><p class="nodrag">
            Ratemap frequency values are <span class="slider_val">{{_make_max_rate_caption(options.max_rate_spa)}}</span><br>
            <paper-slider pin="" snaps="" min="0" max="20" step="1" value="{{options.max_rate_spa}}" style="width:300px"></paper-slider>
        </p><p>
            The true peak rate is shown as "spa max" when you move your cursor over a group.
        </p>
        <p class="nodrag">
            Ratemap height:<span class="slider_val">{{_make_spa_rm_height_caption(options.spa_rm_height)}}</span><br>
            <paper-slider pin="" snaps="" min="0" max="400" step="20" value="{{options.spa_rm_height}}"></paper-slider>
        </p>
    </floating-pane>
    
    <floating-pane id="dir_info" grabber_mode="[[grabber_mode]]" hidden="">
        <div class="pane_title">Directional ratemap [c]</div>
        <p class="nodrag">
            Bin size <span class="slider_val">[[options.deg_per_dir_bin]] degrees</span><br>
            <paper-slider pin="" snaps="" min="2" max="15" step="1" value="{{options.deg_per_dir_bin}}" style="width:300px"></paper-slider>
        </p><p class="nodrag">
            Smoothing kernel boxcar <span class="slider_val">([[options.smoothing_dir_bins]]x2+1) bins</span><br>
            <paper-slider pin="" snaps="" min="0" max="10" step="1" value="{{options.smoothing_dir_bins}}" style="width:300px"></paper-slider>
        </p><p>
            Note that in 2-spot LED mode, the relative position of the two LEDs is used, in 1-spot LED mode,
             the direction of movement is used (this is sometimes refered to as "displacement direction").
        </p><p>
            The true peak rate is shown as "dir max" when you move your cursor over a group.
        </p>
    </floating-pane>

    <floating-pane id="pos_info" grabber_mode="[[grabber_mode]]" hidden="">
        <div class="pane_title">position post processing [x]                          </div>
        <p>
            If you tracked with two LEDs you can read in both data streams.  "Standard" post-processing will be applied to decide when
            the two spots have swapped.
        </p><p class="nodrag">
            Use <span class="slider_val">[[options.use_n_leds]] LEDs</span>:<br>
            <paper-slider class="nodrag" pin="" snaps="" min="1" max="2" step="1" value="{{options.use_n_leds}}" style="width:80px"></paper-slider>
        </p><p>
            The following filtering and smoothing is applied to the one/two data streams separately.
            If two LEDs are used, a single estimate of position is produced at the end, using a weighted sum.
        </p><p class="nodrag">
            Speed <span class="slider_val">{{_make_max_speed_caption(options.speed_filter_mps)}}</span><br>
            <paper-slider class="nodrag" pin="" snaps="" min="0" max="10" step="0.25" value="{{options.speed_filter_mps}}" style="width:300px"></paper-slider><br>
        </p><p>
            Where the speed appears to rise above this threshold the data is considered invalid.
        </p><p>
            Where data is missing (either because no pixels were tracked for the given sample or the above filter invalidated the data),
            new values are created by linearly interpolated across the gaps.
        </p><p class="nodrag">
            Smoothing <span class="slider_val">{{_make_pos_smoothing_caption(options.pos_smoothing_s)}}</span><br>
            <paper-slider class="nodrag" pin="" snaps="" min="0" max="4" step="0.1" value="{{options.pos_smoothing_s}}" style="width:300px"></paper-slider>
        </p><p>
            Following filtering for speed and interpolation, the X and Y data is smoothed using a boxcar (i.e. moving average) of the above width.
        </p>
    </floating-pane>

    
    <template is="dom-repeat" items="[[grabbed_tiles]]">
        <floating-pane grabber_mode="[[grabber_mode]]" initial_x="[[item.x]]" initial_y="[[item.y]]" width="auto" on-close="_close_grabbed_tile">
            <div class="pane_title">[[item.title]]</div>
            <tile-element group_model="[[item.group]]" group_num="[[item.group_num]]" class="noborder"></tile-element>
        </floating-pane>
    </template>

    
    <template is="dom-repeat" items="[[grabbed_cluster_plots]]">
        <floating-pane grabber_mode="[[grabber_mode]]" initial_x="[[item.x]]" initial_y="[[item.y]]" on-close="_close_grabbed_cluster_plots" width="[[options.splitter_c_size]]">
            <div class="pane_title">[[item.title]]</div>
            <div style="text-align: center;">
                <template is="dom-repeat" items="[[item.plots]]">
                    <canvas-with-axes class="cluster_plot" ckey="[[item.ckey]]" x_label="[[item.x_axis]]" y_label="[[item.y_axis]]" fix_height="[[options.cluster_plot_size]]"></canvas-with-axes>
                </template>
            </div>
        </floating-pane>
    </template>

        
    <paper-toolbar style$="{{_style_toolbar(options.toggle_toolbar)}}">
        <div>
            <paper-icon-button icon="waveform:help-outline" on-tap="open_github"></paper-icon-button>
            <paper-tooltip position="right">help on GitHub [?]</paper-tooltip>
        </div>

        <div>
            <paper-icon-button icon="waveform:keyboard" on-tap="toggle_shorcut_pane"></paper-icon-button>
            <paper-tooltip>keyboard shortcuts [k]</paper-tooltip>
        </div>

        <div class="toolbar_divider"></div>

        <div>
            <paper-icon-button icon="waveform:undo" id="undo_button" on-tap="_undo"></paper-icon-button>
            <paper-tooltip>undo [z]</paper-tooltip>
        </div>

        <div>
            <paper-icon-button icon="waveform:redo" id="redo_button" on-tap="_redo"></paper-icon-button>
            <paper-tooltip>redo [y]</paper-tooltip>
        </div>

        <div class="toolbar_divider"></div>
        
        <div>
            <paper-icon-button icon="waveform:format-line-spacing" id="reorder_n_button"></paper-icon-button>
            <paper-tooltip>sort on group size [n]</paper-tooltip>
        </div>

        <div>
            <paper-icon-button icon="waveform:cached" id="reorder_n_button" on-tap="swap_groups"></paper-icon-button>
            <paper-tooltip>swap/move groups [s]</paper-tooltip>
        </div>

        <div class="toolbar_divider"></div>

        <div>
            <paper-icon-button icon="waveform:view-list" id="file_headers_button" on-tap="toggle_header_pane"></paper-icon-button>
            <paper-tooltip>file headers [h]</paper-tooltip>
        </div>

        <div>
            <paper-icon-button icon="waveform:access-time" id="drift_button"></paper-icon-button>
            <paper-tooltip>toggle drift [d]</paper-tooltip>
        </div>

        <div>
            <paper-icon-button icon="waveform:gesture" id="pos_settings" on-tap="toggle_pos_pane"></paper-icon-button>
            <paper-tooltip>position post processing settings [x]</paper-tooltip>
        </div>

        <div class="toolbar_divider"></div>
        
        <div>
            <paper-button selected$="{{_yn_to_bool(options.show_waves, 0)}}" on-tap="show_tap" id="show_wav">wav</paper-button>
            <paper-tooltip>waves [w]</paper-tooltip>
        </div>

        <div>
            <paper-button selected$="{{_yn_to_bool(options.show_rms, 0)}}" on-tap="show_tap" id="show_rm">rm</paper-button>
            <paper-tooltip>spatial ratemap [r]</paper-tooltip>
        </div>

        <div>
            <paper-button selected$="{{_yn_to_bool(options.show_rms, 1)}}" on-tap="show_tap" id="show_dir">dir</paper-button>
            <paper-tooltip>directional ratemap [c]</paper-tooltip>
        </div>

        <div>
            <paper-button selected$="{{_yn_to_bool(options.show_rms, 2)}}" on-tap="show_tap" id="show_spd">spd</paper-button>
            <paper-tooltip>speed ratemap [v]</paper-tooltip>
        </div>

        <div>
            <paper-button selected$="{{_yn_to_bool(options.show_tac, 0)}}" on-tap="show_tap" id="show_tc">tc</paper-button>
            <paper-tooltip>temporal autocorrelation [t]</paper-tooltip>
        </div>

    </paper-toolbar>

    <div style="flex: 1; display:flex; flex-direction:row; position:relative;">
        <document-focus-marker></document-focus-marker>
        
        <iron-resize-notifier style="display:flex; flex-direction:column;">

            <file-organiser style="flex:0 0 0%;" is_dragging_in="{{drop_in_progress}}" no_files="{{no_files}}" selected_files="{{selected_files}}" selected_trial="{{selected_trial}}" selected_tet_num="{{selected_tet_num}}"></file-organiser>
            
            <iron-splitter direction="up" size="{{options.splitter_a_size}}"></iron-splitter>

            <div style="flex:1 1 0%; position:relative;display: flex; flex-direction: row;">
                <managed-canvas style="margin:0 auto;" stretch_height="" ckey="[[pos_path]]"></managed-canvas>
                <div class="info_summary" style$="[[_info_summary_style(active_group_a)]]">
                    <div class="info_summary_text">[[_format_timespan(start_end_times)]]</div>
                    <canvas-with-axes style="width:55px;" ckey="[[pos_speed_hist]]" x_label="[[_caption_speed_max(options.speed_rm_max)]]" fix_height="92" flip_horizontal=""></canvas-with-axes>
                </div>
            </div>

            <iron-splitter direction="down" size="{{options.splitter_b_size}}"></iron-splitter>
                    
            <cluster-plots id="cluster_plots" style="flex:0 0 0%;" groups="[[cut_groups]]" painter_state="{{cut_painter_state}}" amplitudes="[[amplitudes]]" canvas_size="{{options.cluster_plot_size}}" want_amplitudes="{{want_amplitudes}}" active_group_a="{{active_group_a}}" painter_r="{{options.cluster_painter_r}}" grabber_mode="[[grabber_mode]]" on-paint="_paint" on-grab="_grab_cluster_plots">
               </cluster-plots>

        </iron-resize-notifier>

        <iron-splitter direction="left" size="{{options.splitter_c_size}}"></iron-splitter>
        
        <tile-wall style="flex:1 1 0%; position:relative;" groups="{{cut_groups}}" options="[[options]]" active_group_a="{{active_group_a}}" active_group_b="{{active_group_b}}" grabber_mode="[[grabber_mode]]" is_empty="[[tile_wall_is_empty]]" splitter_state="[[splitter_state]]" on-merge_groups="_merge_groups" on-grab_group="_grab_group" on-splitter="_splitter" on-tap_group="_highlight_group"></tile-wall>

    </div>

    <paper-icon-button icon="waveform:menu" class="menu_toggle" on-tap="_toggle_toolbar"></paper-icon-button>
    
    <paper-toast id="toast"></paper-toast>

    <div class="grabber_signifier" style$="{{_show(grabber_mode)}}">
        grabber mode
    </div>

    <drop-zone show_initial="[[no_files]]" drop_in_progress="[[drop_in_progress]]">
        <div class="primary_text">
            drag &amp; drop files here
        </div>
        <div class="secondary_text">
            the following types of data files are recognised: 
            <b><br>set | pos | tet | cut | clu</b><br>
            you can drag further files onto the window at any point<br>
            other file types will be ignored
        </div>
        <div class="initial_extra_under_secondary">
            <div class="github_button github_button_filedrop" on-tap="open_github">
                goto <b>readme, code, and issues</b> on github
            </div><br><br>
            <a href="https://www.youtube.com/watch?v=36o69CPu-1E" target="_blank">
                <img class="youtube_demo_img" src="img/demo_youtube.png" width="560" height="315">
            </a>
            <br><br>
            <span style="color:red; font-weight: bold;">
                This version is very new and exciting, but it's missing <a href="https://github.com/d1manson/waveform/issues/24" target="_blank">one or two features</a> and may have some bugs.<br>
                If neccessary, you can find the old version live <a href="https://annie2013.github.io/waveform" target="_blank">here</a>.<br>
                If you discover bugs of any kind please report them asap.  Happy experimenting!
            </span>
        </div>
        <div class="initial_extra_bottom_right">
            Waveform v0.9.9, by DM<br> Tested with Chrome 49 <img src="img/chromelogo.png" width="15px" style="float:right;margin-left:2px;">
        </div>
    </drop-zone>

    <parsed-data id="parser" selected_files="[[selected_files]]" use_n_leds="[[options.use_n_leds]]" speed_filter_mps="[[options.speed_filter_mps]]" pos_smoothing_s="[[options.pos_smoothing_s]]" duration="{{duration}}" start_end_times="{{start_end_times}}" spike_times="{{spike_times}}" pos_xy="{{pos_xy}}" pos_dir="{{pos_dir}}" pos_speed="{{pos_speed}}" amplitudes="{{amplitudes}}" data_for_gl="{{data_for_gl}}" cut_box="{{cut_box}}" tet_header="{{tet_header}}" pos_header="{{pos_header}}" set_header="{{set_header}}" want_data_for_gl="{{want_data_for_gl}}" want_amplitudes="{{want_amplitudes}}" want_spike_times="{{want_spike_times}}" no_groups="{{tile_wall_is_empty}}"></parsed-data>

    <cut-object id="cut" groups="{{cut_groups}}" painter_state="{{cut_painter_state}}" cut_box="[[cut_box]]" undo_stack_descriptions="{{cut_undo_stack}}" redo_stack_descriptions="{{cut_redo_stack}}"></cut-object>

    <rm-plots groups="{{cut_groups}}" pos_path="{{pos_path}}" pos_speed_hist="{{pos_speed_hist}}" active_group_a="{{active_group_a}}" active_group_b="{{active_group_b}}" spike_times="[[spike_times]]" pos_xy="[[pos_xy]]" pos_dir="[[pos_dir]]" pos_speed="[[pos_speed]]" show="[[options.show_rms]]" cm_per_spa_bin="[[options.cm_per_spa_bin]]" smoothing_spa_bins="[[options.smoothing_spa_bins]]" max_rate_spa="[[options.max_rate_spa]]" deg_per_dir_bin="[[options.deg_per_dir_bin]]" smoothing_dir_bins="[[options.smoothing_dir_bins]]" speed_rm_max="[[options.speed_rm_max]]" want_spike_times="{{want_spike_times}}"></rm-plots> 

    <tac-plots groups="{{cut_groups}}" max_delta_t="[[options.max_delta_t]]" spike_times="[[spike_times]]" show="[[options.show_tac]]" want_spike_times="{{want_spike_times}}"></tac-plots> 
                
    <wave-plots id="wave_plots" groups="{{cut_groups}}" data_for_gl="[[data_for_gl]]" palette_mode="[[options.waves_render_mode]]" show_chans="[[options.show_waves]]" want_data_for_gl="{{want_data_for_gl}}"></wave-plots> 
    
    <iron-a11y-keys keys="esc" on-keys-pressed="_toggle_toolbar" target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="h+only alt+h" on-keys-pressed="toggle_header_pane" target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="alt+p alt+w" on-keys-pressed="toggle_palette_pane" target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="p+only" on-keys-pressed="toggle_palette" target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="alt+r" on-keys-pressed="toggle_spa_rm_pane" target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="alt+c" on-keys-pressed="toggle_dir_rm_pane" target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="alt+v" on-keys-pressed="toggle_speed_rm_pane" target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="alt+t" on-keys-pressed="toggle_tac_pane" target="[[keyboard_target]]"></iron-a11y-keys>    
    <iron-a11y-keys keys="k+only alt+k" on-keys-pressed="toggle_keyboard_pane" target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="alt+z" on-keys-pressed="toggle_action_pane" target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="x+only alt+x" on-keys-pressed="toggle_pos_pane" target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="w+only w+shift" on-keys-pressed="show_key_wav" target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="r+only r+shift" on-keys-pressed="show_key_rm" target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="c+only c+shift" on-keys-pressed="show_key_dir" target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="v+only v+shift" on-keys-pressed="show_key_spd" target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="t+only t+shift" on-keys-pressed="show_key_tc" target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="s+only" on-keys-pressed="swap_groups" target="[[keyboard_target]]"></iron-a11y-keys>

      
    <iron-a11y-keys keys="+only" on-keys-pressed="open_github" target="[[keyboard_target]]"></iron-a11y-keys>
    
    
</template>


<script>
"use strict";
var wav = document.getElementById('wav')

wav.keyboard_target = document.querySelector('body'); // passed through to iron-a11y-keys

// :::: define default options and validate values read from localStorage :::::::::::::::

wav._sanitize_options = function(stored_options) {

    let opts = {
        max_delta_t: 500,
        show_rms: 'yyy',
        show_tac: 'y',
        show_waves: 'yyyy',
        cm_per_spa_bin: 2,
        smoothing_spa_bins: 2,
        max_rate_spa: -1,
        deg_per_dir_bin: 6,
        smoothing_dir_bins: 3,
        waves_render_mode: "density",
        use_n_leds: 2,
        speed_filter_mps: 4,
        pos_smoothing_s: 0.2,
        header_filter: '',
        spa_rm_height: 120,
        cluster_plot_size: 128,
        cluster_painter_r: 15,
        speed_rm_max: 45,
        splitter_a_size: "200px",
        splitter_b_size: "300px",
        splitter_c_size: "350px",
        toggle_toolbar: true
    };

    if(!stored_options){
        return opts;
    }

    for(let k in opts){
        if(stored_options[k] !== undefined){
            opts[k] = stored_options[k];
        }
    }
    return opts;
}

// :::: the cutting tools: split, paint, merge, swap ::::::::::::::::::::::::::

wav._splitter = function(e){
    if(e.detail.state === "finalize" || e.detail.state === "cancel"){
        if(e.detail.state === "cancel"){
            if(wav.splitter_state.group_b){
                wav.$.cut.undo();
            }
        }
        wav.splitter_state._akey_full = null;
        wav.set('splitter_state.group_a', null);
        wav.set('splitter_state.group_b', null);
        wav.set('splitter_state.metrics', null);
        this.set('disable_shortcuts', false);
        return;
    }

    if(e.detail.state === "start"){
        wav.splitter_state._akey_full = e.detail.group.akey;
        wav.set('splitter_state.group_a', e.detail.group);
        this.set('disable_shortcuts', true); // TODO: probably should disable more than just shortcuts or else have a mechanism for reseting the split.
    } 
    if(e.detail.point !== null){
        wav.splitter_state._point = e.detail.point;
        wav.set('splitter_state.metrics', {
            x: e.detail.x,
            y: e.detail.y,
            w: e.detail.w
        });       
    }
    if(e.detail.state === "update"){
        if(wav.splitter_state.group_b){
            wav.$.cut.undo();
        }
        let m = this.$.wave_plots.mask_at_vt(wav.splitter_state._akey_full.array, wav.splitter_state._point);
        let group_num_a = wav.splitter_state.group_a.group_num;
        wav.$.cut.split_group(group_num_a, m);
        wav.set('splitter_state.group_a', wav.cut_groups[group_num_a]);
        wav.set('splitter_state.group_b', wav.cut_groups[group_num_a + 1]);
    }
}

wav._paint = function(e){
    if(e.detail.state === "start"){
        wav.set('disable_shortcuts', true); // TODO: probably should disable more than just shortcuts
    }

    if(e.detail.state === "end"){
        wav.set('disable_shortcuts', false);
        wav.$.cut.transplant_groups(e.detail.dest, e.detail.src_masks);
    }
}

wav._merge_groups = function(e){
    if(wav.tile_wall_is_empty){
        return;
    }
    wav.$.cut.merge_groups(e.detail.a, e.detail.b);
}

wav.swap_groups = function(){
    if(wav.tile_wall_is_empty){
        return;
    }

    let a, b;
    if(!wav.active_group_a){
        a = parseInt(prompt("Swap two groups. Enter first group:", ""));
        if(!(a>=0)){
            return;
        }
        b = parseInt(prompt("Swap two groups. Enter second group:", ""));
    } else {
        a = wav.active_group_a.group_num;
        b = parseInt(prompt("Enter group to swap with group " + a + ":", ""));
    }
    if(!(b>=0)){
        return;
    }

    wav.$.cut.swap_groups(a, b);
}

// :::: the grab tools: tile, cluster (TODO: path) ::::::::::::::::::::::::::

wav._grab_group = function(e){
    if(!wav.grabbed_tiles){
        this.set('grabbed_tiles', []);
    }

    wav.push('grabbed_tiles', {
        title: wav.selected_trial +
               " t" + wav.selected_tet_num + 
                "c" + e.detail.group_num + " [Grabbed]",
        group_num: e.detail.group_num,
        group: e.detail.group, // this is already sufficently-deeply cloned
        x: e.detail.src_client_x + 20,
        y: e.detail.src_client_y + 20
    });
}

wav._close_grabbed_tile = function(e){
    // remove the grabbed tile from the list
    wav.splice('grabbed_tiles', wav.grabbed_tiles.indexOf(e.model.item), 1);
}

wav._grab_cluster_plots = function(e){
    if(!wav.grabbed_cluster_plots){
        this.set('grabbed_cluster_plots', []);
    }
    
    wav.push('grabbed_cluster_plots', {
        title: wav.selected_trial +
               " t" + wav.selected_tet_num,
        plots: e.detail.plots, // this is already sufficently-deeply cloned
        x: e.detail.src_client_x + 20,
        y: e.detail.src_client_y + 20
    });
}

wav._close_grabbed_cluster_plots = function(e){
    // remove the grabbed plots from the list
    wav.splice('grabbed_cluster_plots', wav.grabbed_cluster_plots.indexOf(e.model.item), 1);
}

// :::: plot toggling :::::::::::::::::::::::::::::::

wav.toggle_show = function(id, shiftKey){
    // This is a bit ugly sadly. We want to allow basic toggling
    // without shift, and multi-toggling with shift.
    let result;
    if(!shiftKey){
        result = {
            waves: 'nnnn',
            tac: 'n',
            rms: 'nnn'
        };
        switch (id){
            case "show_wav":
            result.waves = 'yyyy';
            break;

            case "show_tc":
            result.tac = 'y';
            break;

            case "show_rm":
            result.rms = "ynn";
            break;

            case "show_dir":
            result.rms = "nyn";
            break;

            case "show_spd":
            result.rms = "nny";
            break;
        } 
    } else {
        result = {
            waves: wav.options.show_waves,
            tac: wav.options.show_tac,
            rms: wav.options.show_rms
        };
        let n_selected = (result.waves.indexOf('y') > -1) + 
                       (result.tac === 'y') + 
                       (result.rms[0] === 'y') + (result.rms[1] === 'y') + (result.rms[2] === 'y');

        switch (id){
            case "show_wav":
            if(result.waves === "yyyy" && n_selected > 1){
                result.waves = 'nnnn';                
            } else {
                result.waves = 'yyyy';
            }
            break;

            case "show_tc":
            if(result.tac === "y" && n_selected > 1){
                result.tac = 'n';                
            } else {
                result.tac = 'y';
            }
            break;

            case "show_rm":
            if(result.rms[0] === "y" && n_selected > 1){
                result.rms = "n" + result.rms.slice(1);                
            } else {
                result.rms = 'y' + result.rms.slice(1);
            }
            break;

            case "show_dir":
            if(result.rms[1] === "y" && n_selected > 1){
                result.rms = result.rms[0] + "n" + result.rms[2];                
            } else {
                result.rms = result.rms[0] + 'y' + result.rms[2];
            }
            break;

            case "show_spd":
            if(result.rms[2] === "y" && n_selected > 1){
                result.rms = result.rms.slice(0,-1) + "n";                
            } else {
                result.rms = result.rms.slice(0,-1) + 'y';
            }
            break;
        } 
    }
    wav.set('options.show_waves', result.waves);
    wav.set('options.show_tac', result.tac);
    wav.set('options.show_rms', result.rms);
}

wav.show_tap = function(e){
    wav.toggle_show(e.target.id, e.detail.sourceEvent.shiftKey);
    e.preventDefault(); 
}

// :::: initialize application ::::::::::::::::::::::

wav.addEventListener('dom-change', function(){
    // remove keyboard handlers from buttons. Note that ripple still shows.
    let els =   Array.from(document.getElementsByTagName('paper-button'))
        .concat(Array.from(document.getElementsByTagName('paper-icon-button')));
    for(let el of els){
        el._unlistenKeyEventListeners();
    }

    // initialize some things which aren't part of options, and aren't initialzied elsewhere
    wav.set('splitter_state', {
        group_a: null,
        group_b: null,
        metrics: null,
        _akey_full: null,
        _point: null
    });
    wav.set('grabber_mode', false);
})


// :::: some very simple functions (this is the new ES6 "arrow function" syntax) :::::::::::::::

wav._to_render_mode_str = (is_checked) =>  is_checked ? "density" : "flag";
wav._from_render_mode_str = (str) => (str==="density");
wav._make_max_rate_caption = (v) => v > 0 ? "scaled to max of " + v + "Hz" : "individually scaled";
wav._make_max_speed_caption = (v) => v > 0 ? "capped at " + v + " m/s" : "not limited";
wav._make_pos_smoothing_caption = (v) =>  v > 0 ? v + " s" : "turned off";
wav._make_spa_rm_height_caption = (v) =>  v > 0 ? "stretch to " + v + "px" : "one pixel per bin";
wav._caption_speed_max = (v) => v + " cm/s";
wav._show = (v) => v ? '' : 'display: none;';
wav._yn_to_bool = (v, index) => (v && v[index] === 'y');
wav._style_toolbar = (toggle_toolbar) => toggle_toolbar ? '' : 'height:0px;overflow:hidden';
wav._get_safe = (a,b) => a && a[b]; // see https://github.com/Polymer/polymer/issues/1877
wav.toggle_action_pane = () => wav.$.action_info.toggle();
wav.toggle_keyboard_pane = () => wav.$.shortcut_info.toggle();
wav.toggle_tac_pane = () => wav.$.tc_info.toggle();
wav.toggle_spa_rm_pane = () => wav.$.rm_info.toggle();
wav.toggle_dir_rm_pane = () => wav.$.dir_info.toggle();
wav.toggle_speed_rm_pane = () => wav.$.speed_info.toggle();
wav.toggle_pos_pane = () => wav.$.pos_info.toggle();
wav.toggle_palette_pane = () => wav.$.waves_info.toggle();
wav.toggle_header_pane = () => wav.$.header_info.toggle();
wav.toggle_shorcut_pane = () => wav.$.shortcut_info.toggle();
wav.show_key_wav = (e) => wav.toggle_show('show_wav', e.detail.keyboardEvent.shiftKey);
wav.show_key_rm = (e) => wav.toggle_show('show_rm', e.detail.keyboardEvent.shiftKey);
wav.show_key_dir = (e) => wav.toggle_show('show_dir', e.detail.keyboardEvent.shiftKey);
wav.show_key_spd = (e) => wav.toggle_show('show_spd', e.detail.keyboardEvent.shiftKey);
wav.show_key_tc = (e) => wav.toggle_show('show_tc', e.detail.keyboardEvent.shiftKey);
wav._highlight_group = (e) => wav.$.cluster_plots.highlight_group(e.detail.group_num);
wav.toggle_palette = () =>  wav.set('options.waves_render_mode', wav.options.waves_render_mode === "density" ? "flag" : "density");
wav.open_github = () => window.open('https://github.com/d1manson/waveform', '_blank');
wav._toggle_toolbar = () => wav.set('options.toggle_toolbar', !wav.options.toggle_toolbar);
wav._info_summary_style = (v) => v ? 'opacity: 0;' : '';
wav._as_hour_and_mins = (v) => (new Date(v).toLocaleTimeString({}, {hour: '2-digit', minute: '2-digit'}));
wav._format_timespan = (v) => v && (wav._as_hour_and_mins(v.start) + " to " + wav._as_hour_and_mins(v.end));
wav._undo = () => wav.$.cut.undo();
wav._redo = () => wav.$.cut.redo();

// :::: and then some stuff that doesn't sit so well with polymer ::::::::

document.addEventListener('contextmenu', function(e){
    e.preventDefault();
});
document.addEventListener('keydown', function(e){
    if(e.which === 32){//  space
        wav.set('grabber_mode', true);
    }
    if(e.which == 32){ //space
        e.preventDefault(); // normally does things like toggle buttons and scroll divs
    } 
}, true);
document.addEventListener('keyup', function(e){
    if(e.which === 32){
        wav.set('grabber_mode', false);
    }
})

document.addEventListener('copy', function(e){
    if(!wav.active_group_a){
        return;
    }
    let group = wav.active_group_a;
    let title = wav.selected_trial +
               " t" + wav.selected_tet_num + 
                "c" + group.group_num;
    let n_spikes = group.n_spikes;
    let info_str = "";
    (group.n_spikes) && (info_str += " | " + group.n_spikes + " spikes");
    (group.rm.spa_max) && (info_str += " | spatial max: " + group.rm.spa_max + "Hz");
    (group.rm.dir_max) && (info_str += " | directional max: " + group.rm.dir_max + "Hz");

    let plot_str = "";
    (group.waves) && (plot_str += Utils.ckey_to_data_url(group.waves));
    (group.rm.spa) && (plot_str += Utils.ckey_to_data_url(group.rm.spa, wav.options.spa_rm_height));
    (group.rm.dir) && (plot_str += Utils.ckey_to_data_url(group.rm.dir));
    (group.rm.speed) && (plot_str += Utils.ckey_to_data_url(group.rm.speed));
    (group.tac) && (plot_str += Utils.ckey_to_data_url(group.tac));

    let html = `<span style="font-weight:bold;">${title}</span>${info_str}<br>${plot_str}`;
    e.clipboardData.setData('text/html', html);
    e.preventDefault();
    wav.$.toast.text = "plots for '" + title + "' copied to clipboard"
    wav.$.toast.open();
})


</script>


                       </body></html>
